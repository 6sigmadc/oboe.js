<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.6), see www.w3.org">

  <title></title>
</head>

<body>
  <h1 id="abstract"><a href="#abstract"><span class=
  "header-section-number">1</span> Abstract</a></h1>

  <p>A Javascript REST client library targeting both Node.js and
  web browsers that incorporates http streaming, pattern matching,
  and progressive JSON parsing, with the aim of improving
  performance, fault tolerance, and encouraging a greater degree of
  loose coupling between programs. Loose coupling is particularly
  considered in light of the application of Agile methodologies to
  SOA, providing a framework in which it is acceptable to partially
  restructure the JSON format in which a resource is expressed
  whilst maintaining compatibility with dependent systems.</p>

  <p>A critique is made of current practice under which resources
  are entirely retrieved before items of interest are extracted
  programmatically. An alternative model is presented allowing the
  specification of items of interest using a declarative syntax
  similar to JSONPath. The identified items are then provided
  incrementally while the resource is still downloading.</p>

  <p>In addition to a consideration of performance in absolute
  terms, the usability implications of an incremental model are
  also evaluated with regards to differences in user perception of
  performance.</p>

  <h1 id="introduction"><a href="#introduction"><span class=
  "header-section-number">2</span> Introduction</a></h1>

  <p>This dissertation does not focus on implementing software for
  any particular problem domain. Rather, its purpose is to
  encourage the REST paradigm to be viewed through a novel lens. In
  application this may be used to deliver tangible benefits to many
  common REST use cases. Although I express my thesis through
  programming, the contribution I hope to deliver is felt more
  strongly as a shift in how we <em>think</em> about http than it
  is a change in the underlying technology.</p>

  <p>In the interest of developer ergonomics, REST clients have
  tended to style the calling of remote resources similar to the
  call style of the host programming language. Depending on the
  language, one of two schemas are followed: a synchronous style in
  which the http call is an expression which evaluates to the
  resource that was fetched; or asynchronous or monadic in which
  some logic is specified which may be applied to the response once
  it is complete. This tendency to cast REST calls using terms from
  the language feels quite natural; we may call a remote service
  without having to make any adjustment for the fact that it is
  remote. However, we should remember that this construct is not
  the only possible mapping. Importing some moderate Whorfianism
  <span class="citation">(Whorf 1956)</span><span class=
  "citation">(Sapir 1958)</span> from linguistics, we might venture
  to say that the programming languages we use encourage us to
  think in the terms that they easily support. Also UML! For any
  multi-packet message sent via a network some parts will arrive
  before others, at least approximately in-order, but whilst coding
  a C-inspired language whose return statements yield single,
  discrete values it comfortable to conceptualise the REST response
  as a discrete event. Perhaps better suited to representing a
  progressively returned value would have been the relatively
  unsupported Generator routine <span class="citation">(Ralston
  2000)</span>.</p>

  <p>In most practical cases where software is being used to
  perform a task there is no reasonable distinction between being
  earlier and being quicker. Therefore, if our interest is to
  create fast software we should be using data at the first
  possible opportunity. Examining data <em>while</em> it streams
  rather than hold unexamined until the message ends.</p>

  <p>The coining of the term REST represented a shift in how we
  think about http, away from the transfer of hypertext documents
  to that of arbitrary data <span class="citation">(Fielding 2000,
  407&acirc;&euro;&ldquo;416)</span>. It introduced no
  fundamentally new methods. Likewise, no genuinely new computer
  science techniques need be invented to realise my thesis. As a
  minimum, the implementation requires an http client which exposes
  the response whilst it is in progress and a parser which can
  start making sense of a response before it sees all of it. I also
  could not claim this thesis to be an entirely novel composition
  of such parts. Few ideas are genuinely new and it is often wiser
  to mine for solved problems then to solve again afresh. The
  intense competition of Web browsers to be as fast as possible has
  already found this solution. Load any graphics rich with images
  -- essentially an aggregation of hypertext and images -- the HTML
  is parsed incrementally while it is downloading and the images
  are requested as soon as individual &lt;img&gt; tags are
  encountered. The browser's implementation involves a highly
  optimised parser created for a single task, that of displaying
  web pages. The new contribution of this dissertation is to
  provide a generic analog applicable to any problem domain.</p>

  <p>Also progressive SVGs.<sup><a href="#fn1" class="footnoteRef"
  id="fnref1" name="fnref1">1</a></sup></p>

  <h2 id="rest-aggregation-could-be-faster"><a href=
  "#rest-aggregation-could-be-faster"><span class=
  "header-section-number">2.1</span> REST aggregation could be
  faster</a></h2>

  <div class="figure">
    <img src="images/rest_timeline_1.png" alt=
    "Aggregation of lower-level resources exposed via REST. The client fetches a listing of an author's publications and then the first three articles. The sequence represents the most commonly used technique in which the client does not react to the response until it is complete. In this example the second wave of requests cannot be made until the original response is complete, at which time they are issued in quick succession. ">

    <p class="caption"><strong>Aggregation of lower-level resources
    exposed via REST.</strong> The client fetches a listing of an
    author's publications and then the first three articles. The
    sequence represents the most commonly used technique in which
    the client does not react to the response until it is complete.
    In this example the second wave of requests cannot be made
    until the original response is complete, at which time they are
    issued in quick succession.</p>
  </div>

  <div class="figure">
    <img src="images/rest_timeline_2.png" alt=
    "Revised sequence of aggregation performed by a client capable of progressively interpreting the fetched resource. Because UML sequence diagrams arrows draw the concept of a returned value as a one-off event rather than a continuous process, I have introduced the notation of lighter arrows illustrating fragments of an ongoing response. Each individual publication request is made at the earliest possible time, as soon as the its URL can be extracted from the publications list. Once the required data has been read from the original resource it is aborted rather than continue to download unnecessary data. This results in a moderate reduction in wait time to see all three articles but a dramatic reduction in waiting before the first content is presented. Note also how the cadence of requests is more even with four connections opened at roughly equal intervals rather than a single request followed by a rapid burst of three. Clients frequently limit the number of simultaneous connections per domain so avoiding bursts of requests is further to our advantage. ">

    <p class="caption"><strong>Revised sequence of aggregation
    performed by a client capable of progressively interpreting the
    fetched resource.</strong> Because UML sequence diagrams arrows
    draw the concept of a returned value as a one-off event rather
    than a continuous process, I have introduced the notation of
    lighter arrows illustrating fragments of an ongoing response.
    Each individual publication request is made at the earliest
    possible time, as soon as the its URL can be extracted from the
    publications list. Once the required data has been read from
    the original resource it is aborted rather than continue to
    download unnecessary data. This results in a moderate reduction
    in wait time to see all three articles but a dramatic reduction
    in waiting before the first content is presented. Note also how
    the cadence of requests is more even with four connections
    opened at roughly equal intervals rather than a single request
    followed by a rapid burst of three. Clients frequently limit
    the number of simultaneous connections per domain so avoiding
    bursts of requests is further to our advantage.</p>
  </div><!--- 
connections per peer limited:
http://stackoverflow.com/questions/5751515/official-references-for-default-values-of-concurrent-http-1-1-connections-per-se 
=-->

  <p>Figures and illustrate how a progressive REST client may
  without adjustments to the server be used to aggregate REST
  resources faster. The greatest improvement is in how early the
  first piece of data is able to be used. This is advantageous:
  firstly, progressive display in itself raises the human
  perception of performance <span class="citation">(Geelhoed et al.
  1995)</span>; secondly, a user wanting to scan from top to bottom
  may start reading the first article while waiting for the later
  ones to arrive; thirdly, on seeing the first content the user may
  notice that they have requested the wrong aggregation, allowing
  them to backtrack earlier.</p>

  <p>Although the label "client software" in the figures above
  hints at software running directly on a user's own device this is
  not necessarily the case, for example the client may in fact be
  an server-side aggregation layer. Nodes in an n-tier architecture
  commonly defy categorisation as 'client' or 'server' in a way
  which is appropriate from all frames of reference. Rather, nodes
  may be thought of as a client from the layer below and as a
  server from the layer above. A further example would be a
  server-side webpage generator maintaining a perceptual
  performance improvement by progressively writing out html using
  http chunked encoding. <span class="citation">(Stefanov
  2009)</span>. The demonstrated advantages hold regardless of
  where in the stack the 'client' is located.</p>

  <h2 id="stepping-outside-the-big-small-tradeoff"><a href=
  "#stepping-outside-the-big-small-tradeoff"><span class=
  "header-section-number">2.2</span> Stepping outside the big-small
  tradeoff</a></h2>

  <p>Where a domain model contains a series of data, of which
  ranges are made available via REST, I have often seen a trade-off
  with regards to how much of the series each call should request.
  Answering this question is usually a compromise between competing
  concerns in which it is not simultaneously possible to addresses
  all concerns satisfactorily. A good example might be a Twitter's
  pages listing a series of tweets where the interface designers
  adopted a currently trending pattern <span class=
  "citation">(Ahuvia 2013)</span>, Infinite Scrolling. Starting
  from an initial page showing some finite number of tweets, upon
  scrolling to the bottom the next batch is automatically
  requested. The new batch is fetched in a json format and, once
  loaded, presented as html and added to the bottom of the page.
  Applied repeatedly this allows the user to scroll indefinitely,
  albeit punctuated by slightly jolting pauses while new content is
  loaded. To frame the big-small tradeoff we might consider the
  extreme choices. Firstly, requesting just one tweet per http
  request. By requesting the smallest possible content individual
  calls would complete very quickly and the pauses would be short.
  Taking the extreme small end the page stutters, pausing
  momentarily but frequently. Taking the opposite extreme, by
  requesting some huge number of tweets we see long periods of
  smooth scrolling partitioned by long waits.</p>

  <p>I propose that my thesis may be applied used to stand down
  from this compromise by delivering pauses which are both
  infrequent and short. In the Twitter example, once we have
  thinking about http progressively this may be achieved quite
  simply by issuing large requests but instead of deferring all
  rendering until the request completes, render individual tweets
  incrementally as they are progressively parsed out of the ongoing
  response.</p>

  <p>Integrate: twitter: page could update at bottom and top with
  same transport perhaps.</p>

  <h2 id="staying-fast-on-a-fallible-network"><a href=
  "#staying-fast-on-a-fallible-network"><span class=
  "header-section-number">2.3</span> Staying fast on a fallible
  network</a></h2>

  <p>The reliability of networks that REST operates over varies
  widely. Considering the worst case we see mobile networks in
  marginal signal over which it is common for ongoing downloads to
  be abruptly disconnected. Existing http clients handle this kind
  of unexpected termination poorly. Consider the everyday situation
  of somebody using a smartphone browser to check their email. The
  use of Webmail necessitates that the communication in made via
  REST rather than a mail specific protocol such as IMAP. Mobile
  data coverage is less than network operators claim <span class=
  "citation">(Anon. 2011)</span> so while travelling the signal can
  be expected to be lost and reestablished many times. Whilst not
  strictly forbidding their inspection, the web developer's
  standard AJAX toolkit are structured in such a way as to
  encourage the developer to consider partially successful messages
  as wholly unsuccessful. For example, the popular AJAX library
  jQuery automatically parses complete JSON or XML responses before
  handing back to the application. But on failure there is no
  attempt to parse or deliver the partial response. To programmers
  who know where to look the partial responses are retrievable as
  raw text but handling them is a special case,
  bringing-your-own-parser affair. Because of this difficulty I can
  only find examples of partial messages being dropped without
  inspection. In practice this means that for the user checking her
  email, even if 90% of her inbox had been retrieved she will be
  shown nothing. When the network is available again the
  application will have to download from scratch, including the 90%
  which it already fetched. I see much potential for improvement
  here.</p>

  <p>Not every message, incomplete, is useful. Whilst of course a
  generic REST client cannot understand the semantics of specific
  messages fully enough to decide if a partially downloaded message
  is useful, I propose it would be an improvement if the content
  from incomplete responses could be handled using much the same
  programming as for complete responses. This follows naturally
  from a conceptualisation of the http response as a progressive
  stream of many small parts; as each part arrives it should be
  possible to use it without knowing if the next will be delivered
  successfully. This style of programming encourages thinking in
  terms of optimistic locking. Upon each partial delivery there is
  an implicit assumption that it may be acted on straight away and
  the next will also be successful. In cases where this assumption
  fails the application should be notified so that some rollback
  may be performed.</p>

  <h2 id=
  "agile-methodologies-frequent-deployments-and-compatibility-today-with-versions-tomorrow">
  <a href=
  "#agile-methodologies-frequent-deployments-and-compatibility-today-with-versions-tomorrow">
  <span class="header-section-number">2.4</span> Agile
  methodologies, frequent deployments, and compatibility today with
  versions tomorrow</a></h2>

  <p>In most respects SOA architecture fits well with the fast
  release cycle that Agile methodologies encourage. Because in SOA
  we may consider that all data is local rather than global and
  that the components are loosely coupled and autonomous, frequent
  releases of any particular sub-system shouldn't pose a problem to
  the correct operation of the whole. Following emergent design it
  should be possible for the format of resources to be realised
  slowly and iteratively as a greater understanding of the problem
  is achieved. Unfortunately in practice the ability to change is
  hampered by tools which encourage programming against rigidly
  specified formats. Working in enterprise I have often seen the
  release of dozens of components cancelled because of a single
  unit that failed to meet acceptance criteria. By allowing a tight
  coupling that depends on exact versions of formats, the perfect
  environment is created for contagion whereby the updating of any
  single unit may only be done as part of the updating of the
  whole.</p>

  <p>An effective response to this problem would be to integrate
  into a REST client library the ability to use a response whilst
  being only loosely coupled to the <em>shape</em> of the overall
  message.</p>

  <h2 id="deliverables"><a href="#deliverables"><span class=
  "header-section-number">2.5</span> Deliverables</a></h2>

  <p>To avoid feature creep I am paring down the software
  deliverables to the smallest work which can we said to realise my
  thesis. Amongst commentators on start-up companies this is known
  as a <em>zoom-in pivot</em> and the work it produces should be
  the <em>Minimum Viable Product</em> or MVP <span class=
  "citation">(Reis 2011 p. ??)</span>, the guiding principle being
  that it is preferable to produce a little well than more badly.
  By focusing tightly I cannot not deliver a full stack so I am
  forced to implement only solutions which interoperate with
  existing deployments. This is advantageous; to somebody looking
  to improve their system small additions are easier to action than
  wholesale change.</p>

  <p>To reify the vision above, a streaming client is the MVP.
  Because all network transmissions may be viewed though a
  streaming lens an explicitly streaming server is not required.
  Additionally, whilst http servers capable of streaming are quite
  common even if they are not always programmed as such, I have
  been unable to find any example of a streaming-capable REST
  client.</p>

  <h2 id="criteria-for-success"><a href=
  "#criteria-for-success"><span class=
  "header-section-number">2.6</span> Criteria for success</a></h2>

  <p>In evaluating this project, we may say it has been a success
  if non-trivial improvements in speed can be made without a
  corresponding increase in the difficulty of programming the
  client. This improvement may be in terms of the absolute total
  time required to complete a representative task or in a user's
  perception of the speed in completing the task. Because
  applications in the target domain are much more io-bound than
  CPU-bound, optimisation in terms of the execution time of a
  algorithms will be de-emphasised unless especially egregious. The
  measuring of speed will include a consideration of performance
  degradation due to connections which are terminated early.</p>

  <p>Additionally, I shall be looking at common ways in which the
  semantics of a message are expanded as a system's design emerges
  and commenting on the value of loose coupling in avoiding
  disruption given unanticipated format changes.</p>

  <h1 id="background"><a href="#background"><span class=
  "header-section-number">3</span> Background</a></h1>

  <h2 id="the-web-as-an-application-platform"><a href=
  "#the-web-as-an-application-platform"><span class=
  "header-section-number">3.1</span> The web as an application
  platform</a></h2>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "A webapp running with a front end generated partially on server and partially on client side. Ie, front-end client-side, front-end server-side, presentation layer a more meaningful distinction than">

    <p class="caption"><em>A webapp running with a front end
    generated partially on server and partially on client
    side.</em> Ie, front-end client-side, front-end server-side,
    presentation layer a more meaningful distinction than</p>
  </div>

  <p>Application design, particularly regarding the presentation
  layer, has charted an undulating path pulled by competing
  patterns of thick and thin clients. Having been taken up as the
  platform today for all but the most specialised applications, the
  web continues in this fashion by resisting easy categorisation as
  either mode. Although born on the network, at inception the web
  wasn't particularly graphical and didn't tread in the steps of
  networked graphical technologies such as X11 in which every
  presentation decision was made on a remote server<sup><a href=
  "#fn2" class="footnoteRef" id="fnref2" name="fnref2">2</a></sup>
  -- instead of sending fine-grained graphical instructions, a much
  more compact document mark-up format was used. At the same time,
  the markup-format was unlike like Gopher by being not totally
  semantic meaning that presentation layer concerns were kept
  partially resident on the server. At this time, whereas CGI was
  being used to serve documents with changeable content, it was not
  until 1996 with <em>ViaWeb</em> (later to become Yahoo Stores)
  that a user could be given pages comparable in function to the
  GUI interface of a desktop application. <span class=
  "citation">(Graham 2004 - get page number, in old dis)</span>.
  The interface of these early web applications comprised of pages
  dynamically generated on the server side, but handled statically
  on the client side so far as the browser was not able to be
  scripted to manipulate the page in any way.</p>

  <p>The modern, client-scripted web bears a striking resemblance
  to NeWS. Rather than send many individual drawings, the server
  could send parametrised instructions to show the client
  <em>how</em> some item of presentation is drawn. Having received
  the program, the only communications required are the parameters.
  This mixed-model provides no lesser degree of server-side control
  but by using client-side rendering a much faster experience was
  possible than would otherwise be possible over low-speed networks
  <span class="citation">(Hopkins 1994)</span>.</p>

  <p>Today it is agreed that program architecture should separate
  presentation from operational logic but there is no firm
  consensus on where each concern should be exercised. While it
  feels that Javascript is becoming requisite to even display a
  page, there are also actions in the opposite direction, for
  example in 2012 twitter moved much of their rendering back to the
  server-side reducing load times to one fifth of their previous
  design, commenting "The future is coming and it looks just like
  the past" <span class="citation">(Lea 2012)</span>. This model
  generated server-side short pages that load quick and are ready
  to be displayed but also sent the Javascript which would allow
  the display to be updated without another full server load. One
  weakness of this model is that the same presentational logic
  requires two expressions.</p>

  <p>Like most interactive programming, client-side scripts usually
  suffer greater delays waiting for io than because javascript
  execution times present a bottleneck. Because Javascript is used
  for user interfaces, frame-rates are important. Single threaded
  so js holds up rendering. Important to return control to the
  browser quickly. However, once execution of each js frame of
  execution is no more than the monitor refresh rate, further
  optimisation brings zero benefit. Hence, writing extremely
  optimised Javascript, especially focusing on micro-optimisations
  that hurt code readability is a bit silly.</p>

  <blockquote>
    <p>The user does something, then the app responds visually with
    immediacy at 30 frames per second or more, and completes a task
    in a few hundred milliseconds. As long as an app meets this
    user goal, it doesn&acirc;&euro;&trade;t matter how big an
    abstraction layer it has to go through to get to silicon.
    <span class="citation">(Mullany 2013)</span></p>
  </blockquote>

  <h2 id="node.js"><a href="#node.js"><span class=
  "header-section-number">3.2</span> Node.js</a></h2>

  <p>Include? Node not just for servers. CLI tools etc.</p>

  <p>Include? Compare to Erlang. Waiter model. Node restaurant much
  more efficient use of expensive resources.</p>

  <p>Include? No 'task' class or type, tasks are nothing more than
  functions, possibly having some values implicitly wrapped up in
  their closure.</p>

  <p>Include? Easy to distribute software (npm etc)</p>

  <p>It is difficult to say to what degree Node's use of Javascript
  is a distraction from the system's principled design aims and to
  what degree it defines the technology. Paradoxically, both may be
  so. Javascript has proven itself very effective as the language
  to meet Node's design goals but this suitability is not based on
  Javascript's association with web browsers, although it is
  certainly beneficial: for the first time it is possible to
  program presentation logic once which is capable of running on
  either client or server. Being already familiar with Javascript,
  web programmers were the first to take up Node.js first but the
  project mission statement makes no reference to the web; Node's
  architecture is well suited to any application domain where
  low-latency responses to i/o is more of a concern than
  heavyweight computation. Web applications fit well into this
  niche but they are far from the only domain that does so.</p>

  <p>In most imperative languages attempts at concurrency have
  focused on threaded execution, whereas Node is by design
  single-threaded. Threads are an effective means to speed up
  parallel computation but not well suited to concurrently running
  tasks which are mostly i/o dependent. Used for io, threads
  consume considerable resources while spending most of their lives
  waiting, occasionally punctuated with short bursts of activity.
  Programming Java safely with threads which share access to
  mutable objects requires great care and experience, otherwise the
  programmer is liable to create race conditions. If we consider
  for example a Java thread-based http aggregator; each 'requester'
  thread waits for seconds and then processes for milliseconds. The
  ratio of waiting to processing is so high that any gains achieved
  through actual concurrent execution of the active phase is
  pyrrhic. Following Node's lead, even traditionally thread-based
  environments such as Java are starting to embrace asynchronous,
  single-threaded servers with projects such as Netty.</p>

  <p>Node manages concurrency by managing an event loop of queued
  tasks and expects each task never to block. Non-blocking calls
  are used for all io and are callback based. Unlike Erlang, Node
  does not swap tasks out preemptively, it always waits for tasks
  to complete. This means that each task must complete quickly;
  while this might at first seem like an onerous requirement to put
  on the programmer, in practice the asynchronous nature of the
  toolkit makes following this requirement more natural than not.
  Indeed, other than accidental non-terminating loops or heavy
  number-crunching, the lack of any blocking io whatsoever makes it
  rather difficult to write a node program whose tasks do not exit
  quickly. This programming model of callback-based, asynchronous,
  non-blocking io with an event loop is already the model followed
  inside web browsers, which although multi-threaded in some
  regards, present a single-threaded virtual machine in terms of
  Javascript execution.</p>

  <p>A programmer working with Node's single-thread is able to
  switch contexts quickly to achieve a very efficient kind of
  concurrency because of Javascript's support for closures. Because
  of closures, under Node the responsibility to explicitly store
  state between making an asynchronous call and receiving the
  callback is removed from the programmer. Closures require no new
  syntax, the implicit storage of this data feels so natural and
  inevitable that looking at the typical program it is often not
  obvious that the responsibility exists at all.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">
<span class=
"co">// Rather than blocking, this function relies on non-blocking io and</span>
<span class=
"co">// schedules three tasks, each of which exit quickly, allowing this</span>
<span class=
"co">// node instance to continue with other tasks in between. </span>
<span class=
"co">// However sophisticated and performant this style of programming, </span>
<span class=
"co">// to the developer it is barely more difficult than if a blocking io</span>
<span class="co">// model were followed. </span>

<span class="kw">function</span> <span class=
"fu">makeRequest</span>( host, path ) {

   <span class="kw">var</span> options = { <span class=
"dt">host</span>: host, <span class="dt">path</span>: path };
   
   <span class="ot">http</span>.<span class=
"fu">get</span>(options, <span class=
"kw">function</span>(response){
      
      <span class=
"co">// This function will be called when the response starts. The callback</span>
      <span class=
"co">// having started listening to the response object will quickly exit</span>
      <span class=
"co">// as Node tasks are want to do. Because of closures we are able to</span>
      <span class=
"co">// access the path variable declared in a containing scope, even after</span>
      <span class=
"co">// the containing scope has exited.      </span>
      <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">"The response has started for "</span> + path);
   
      <span class="ot">response</span>.<span class=
"fu">on</span>(<span class="st">'data'</span>, <span class=
"kw">function</span>(chunk) {
      
         <span class=
"co">// This function is called each time some data is received from the </span>
         <span class="co">// http request</span>
         
         <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">'Got some response '</span> + chunk);
       
      });
   }).<span class="fu">on</span>(<span class=
"st">"error"</span>, <span class="kw">function</span>(e){
   
      <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">"Got error: "</span> + <span class="ot">e</span>.<span class=
"fu">message</span>);
   });
   
   <span class="ot">console</span>.<span class=
"fu">log</span>(<span class="st">"Request has been made"</span>);
}</code>
</pre>

  <h2 id="streams-in-node"><a href="#streams-in-node"><span class=
  "header-section-number">3.3</span> Streams in Node</a></h2>

  <blockquote>
    <p>Streams in node are one of the rare occasions when doing
    something the fast way is actually easier. SO USE THEM. not
    since bash has streaming been introduced into a high level
    language as nicely as it is in node." <a href=
    "https://gist.github.com/2401787">high level node style
    guide</a></p>
  </blockquote>

  <p>Bash streams a powerful abstraction easily programmed for
  linear streaming. Node more powerful, allows a powerful streaming
  abstraction which is no more complex to program than a javascript
  webapp front end. Essentially a lower-level (and therefore more
  powerful) interface to streaming such as unix sockets or tcp
  connections.</p>

  <blockquote>
    <p>Node Stream API, which is the core I/O abstraction in
    Node.js (which is a tool for I/O) is essentially an abstract
    in/out interface that can handle any protocol/stream that also
    happens to be written in JavaScript. [<a href=
    "http://maxogden.com/a-proposal-for-streaming-xhr.html">http://maxogden.com/a-proposal-for-streaming-xhr.html</a>]</p>
  </blockquote>

  <p>Streams in node are a variant of the observer pattern and fit
  into a wider Node event model. Streams emit 'readable' events
  when they have some data to be read and 'end' events when they
  are finished. Apart from error handling, so far as reading is
  concerned, that is the extent of the API.</p>

  <h2 id="web-browsers-hosting-rest-clients"><a href=
  "#web-browsers-hosting-rest-clients"><span class=
  "header-section-number">3.4</span> Web browsers hosting REST
  clients</a></h2>

  <p>Http is essentially a thinly-wrapped text response around some
  usually text-based (but sometimes binary) data. It may give the
  length of the content as a header, but is not obliged to. It
  supports an explicitly chunked mode, but even the non-chunked
  mode may be considered as a stream. For example, a program
  generating web pages on the server side might choose to use
  chunking so that the browser is better able to choose when to
  re-render during the progressive display of a page <span class=
  "citation">(Stefanov 2009)</span> but this is optional and
  without these hints progressive rendering will still take
  place.</p>

  <p>The requesting of http from Javascript, commonly termed AJAX,
  was so significant a technique in establishing the modern web
  application architecture that it is often taken as being a
  synonym for Javascript-heavy web pages. Although an acronym for
  Asynchronous Javascript and XML, for data services designed with
  delivery to client-side web applications in mind JSON is almost
  exclusively preferred to XML and the term is used without regard
  for the data format of the response (the unpronounceable
  <em>AJAJ</em> never took off). During the 'browser war' years
  adding non-standard features was a common form of competition
  between authors; following this pattern Internet Explorer
  originally made AJAX possible by exposing Microsoft's Active X
  <em>Xml Http Request</em>, or XHR, object to Javascript
  programmers. This was widely copied as functional equivalents
  were added to all major browsers and the technique was eventually
  formalised by the W3C<span class="citation">(van Kesteren and
  Jackson 2006)</span>. What followed was a period of stagnation
  for web browsers. HTML4 reached W3C Recommendation status in 2001
  but having subsequently found several evolutionary dead ends such
  as XHTML, the developer community would see no major updates
  until HTML5 started to gather pace some ten years later. In this
  context the web continued to rapidly mature as an application
  platform and AJAX programming inevitably overtook the original
  XHR specification, browser vendors again adding their own
  proprietary extensions to compensate.</p>

  <p>Given this backdrop of non-standard extensions and lagging
  standardisation, abstraction layers predictably rose in
  popularity. Despite a reputation Javascript being poorly
  standardised, as a language it is very consistently implemented.
  More accurately we should say that the libraries provided by the
  environment lack compatibility. Given an abstraction layer to
  gloss over considerable differences cross-browser webapp
  developers found little difficulty in targeting multiple
  platforms. The various abstraction competed on developer
  ergonomics with the popular jQuery and Prototype.js promoting
  themselves respectively as <em>"do more, write less"</em> and
  <em>"elegant APIs around the clumsy interfaces of Ajax"</em>.
  JSON being a subset of Javascript, web developers barely noticed
  their privileged position whereby the serialisation of their data
  format mapped exactly onto the basic types of their programming
  language. As such there was never any confusion as to which exact
  object structure to de-serialise to. If this seems like a small
  advantage, contrast with the plethora of confusing and
  incompatible representations of JSON output presented by the
  various Java JSON parsers; JSON's Object better resembles Java's
  Map than Object and the confusion between JSON null, Java null,
  and Jackson's NullNode<sup><a href="#fn3" class="footnoteRef" id=
  "fnref3" name="fnref3">3</a></sup> is a common cause of errors.
  Endowed with certainty regarding deserialisation, JSON parsers
  could be safely integrated directly into AJAX libraries. This
  provided a call style while working with remote resources so
  streamlined as to require hardly any additional effort.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"ot">jQuery</span>.<span class="fu">ajax</span>(<span class=
"st">'http://example.com/people.json'</span>, <span class=
"kw">function</span>( people ) {

   <span class=
"co">// The parsing of the people json into a javascript object</span>
   <span class=
"co">// feels so natural that it is easy to forget while looking </span>
   <span class="co">// at the code that it happens at all. </span>
   
   <span class="fu">alert</span>(<span class=
"st">'the first person is called '</span> + people[<span class=
"dv">0</span>].<span class="fu">name</span>);
});</code>
</pre>

  <p>Whilst simple, the above call style is built on the assumption
  that a response is a one-time event and no accommodation is made
  for a continuously delivered response. Meanwhile, the XHR2
  standardisation process had started and was busy observing and
  specifying proprietary extensions to the original XHR1. Given an
  interest in streaming, the most interesting of these is the
  progress event:</p>

  <blockquote>
    <p>While the download is progressing, queue a task to fire a
    progress event named progress about every 50ms or for every
    byte received, whichever is least frequent. <span class=
    "citation">(van Kesteren 2012)</span></p>
  </blockquote>

  <p>Prior to this addition there had been no mechanism, at least
  so far as the published specs to an XHR instance in a streaming
  fashion. However, while all major browsers currently support
  progress events in their most recently versions, the installed
  userbase of supporting browsers is unlikely to grow fast enough
  that this technique may be relied upon without a fallback for
  several years.</p>

  <p>In fact, this is exactly how web browsers are implemented.
  However, this progressive use of http is hardwired into the
  browser engines rather than exposing an API suitable for general
  use and as such is treated as something of a special case
  specific to web browsers and has not so far seen a more general
  application. I wish to argue that a general application of this
  technique is viable and offers a worthwhile improvement over
  current common methods.</p>

  <p>While until recently browsers have provided no mechanism to
  stream into AJAX, almost every other instance of downloading has
  taken advantage of streaming and progressive interpretation. This
  includes image formats, as the progressive PNG and JPEG; markup
  as progressive display of html and svg; video; and Javascript
  itself -- script interpretation starts before the script is
  wholly fetched. Each of these progressive considerations is
  implemented as a specific-purpose mechanism internal to the
  browser which is not exported to Javascript and as such is not
  possible to repurpose.</p>

  <h2 id="browser-streaming-frameworks"><a href=
  "#browser-streaming-frameworks"><span class=
  "header-section-number">3.5</span> Browser streaming
  frameworks</a></h2>

  <p>As the web's remit spread to include more applications which
  would previously have been native apps, to be truly 'live' many
  applications found the need to be able to receive real-time push
  events. Dozens of streaming transports have been developed
  sidestepping the browser's apparent limitations.</p>

  <p>The earliest and most basic attempt was to poll by making many
  requests, I won't consider this approach other than to say it
  came with all the usually associated downsides. Despite the
  inadequacy of this approach, from here the improved technique of
  <em>long polling</em> was invented. A client makes a request to
  the server side. Once the connection is open the server waits,
  writing nothing until a push is required. To push the server
  writes the message and closes the http connection; since the http
  response is now complete the content may be handled by the
  Javascript client which then immediately makes a new request,
  reiterating the cycle of wait and response. This approach works
  well where messages are infrequently pushed but where the
  frequency is high the limitation of one http transmission per
  connections requires imposes a high overhead.</p>

  <p>Observing that while browsers lack progressive ajax,
  progressive html rendering is available, <em>push tables</em>
  achieve progressive data transfer by serialising streaming data
  to a HTML format. Most commonly messages are written to a table,
  one row per message. On the client side this table is hidden in
  an off-screen frame and the Javascript streaming client watches
  the table and reacts whenever a new row is found. In many ways an
  improvement over long-polling, this approach nevertheless suffers
  from an unnatural data format. Whilst html is a textual format so
  provides a degree of human-readability, html was not designed
  with the goal of an elegent or compact transfer of asynchronous
  data. Contrasted with a SOA ideal of <em>'plumbing on the
  outside'</em>, peeking inside the system is difficult whilst
  bloated and confusing formats are tasked with conveying
  meaning.</p>

  <p>Both long polling and push tables are better throught of as a
  means to circumvent restrictions than indigene technology. A
  purose-built stack, <em>Websockets</em> is poised to take over,
  building a standardised duplex transport and API on top of http's
  chunked mode. While the newest browsers support websockets, most
  of the wild use base does not. Nor do older browsers provide a
  fine-grained enough interface into http in order to allow a
  Javascript implementation. In practice, real-world streaming
  libraries such as socket.io [CITE] are capable of several
  streaming techniques and can select the best for a given context.
  To the programmer debugging an application the assortment of
  transports only enhances the black-box mentality with regards to
  the underlying transports.</p><!---
*some or all of the below could move to A&R, it is wondering into
analysis* =-->

  <p>Whilst there is some overlap, each of the approaches above
  addresses a problem only tangentially related to this project's
  aims. Firstly, requiring a server that can write to an esoteric
  format feels quite anti-REST, especially given that the server is
  sending in a format which requires a specific, known, specialised
  client rather than a generic tool. In REST I have always valued
  how prominently the plumbing of a system is visible, so that to
  sample a resource all that is required is to type a URL and be
  presented with it in a human-comprehensible format.</p>

  <p>Secondly, as adaptations to the context in which they were
  created, these frameworks realise a view of network usage in
  which downloading and streaming are dichotomously split, whereas
  I aim to realise a schema without dichotomy in which
  <em>streaming is adapted as the most effective means of
  downloading</em>. In existing common practice a wholly distinct
  mechanism is provided vs for data which is ongoing vs data which
  is finite. For example, the display of real-time stock data might
  start by AJAXing in historical and then separately use a
  websocket to maintain up-to-the-second updates. This requires the
  server to support two distinct modes. However, I see no reason
  why a single transport could not be used for both. Such a server
  might start answering a request by write historic events from a
  database, then switch to writing out live data in the same format
  in response to messages from a MOM. By closing the dichotomy we
  would have the advantage that a single implementation is able to
  handle all cases.</p>

  <p>It shouldn't be a surprise that a dichotomous implementation
  of streaming, where a streaming transport is used only for live
  events is incompatible with http caching. If an event is streamed
  when it is new, but then when it is old made available for
  download, http caching between the two requests is impossible.
  However, where a single mode is used for both live and historic
  events the transport is wholly compatible with http caching.</p>

  <p>If we take streaming as a technique to achieve efficient
  downloading, not only for the transfer of forever-ongoing data,
  none of these approaches are particularly satisfactory.</p>

  <h2 id="json-and-xml"><a href="#json-and-xml"><span class=
  "header-section-number">3.6</span> Json and XML</a></h2>

  <p>Although AJAX started as a means to transfer XML, today JSON
  "The fat-free alternative to XML<span class="citation">(Douglas
  2009)</span>" is the more popular serialisation format. The goals
  of XML were to simplify SGML to the point that a graduate student
  would be able to implement a parser in a week [@javaxml p ???].
  For the student tackling JSON a few hours with a parser generator
  should surfice, being expressable in 15 CFGs. Indeed, because
  JSON is a strict subset of Javascript, in many cases the
  Javascript programmer requires no parser at all. Unimpeeded by
  SGML's roots as a document format, JSON provides a much more
  direct analogue to the metamodel of a canonical modern
  programming language with entities such as <em>string</em>,
  <em>number</em>, <em>object</em> and <em>array</em>. By closely
  mirroring a programmer's metamodel, visualising a mapping between
  a domain model and it's serialised objects becomes trivial.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">{
   <span class="dt">people</span>: [
      {<span class="dt">name</span>: <span class=
"st">'John'</span>, <span class="dt">town</span>:<span class=
"st">'Oxford'</span>},
      {<span class="dt">name</span>: <span class=
"st">'Jack'</span>, <span class="dt">town</span>:<span class=
"st">'Bristol'</span>}
   ]
}</code>
</pre>

  <p>This close resemblance to the model of the programming in some
  cases causes fast-changing formats.</p>

  <p>Like XML attributes, as a serialised text format, JSON objects
  have an order but are almost always parsed to and from orderless
  maps meaning that the order of the keys/value pairings as seen in
  the stream usually follows no defined order. No rule in the
  format would forbid representing of an ordered map in an ordered
  way but most tools on receiving such a message would ignore the
  ordering.</p>

  <p>(MINE SOA assignment). Also the diagram.</p>

  <h2 id="parsing-sax-and-dom"><a href=
  "#parsing-sax-and-dom"><span class=
  "header-section-number">3.7</span> Parsing: SAX and Dom</a></h2>

  <p>In the XML world two standard parser models exist, SAX and
  DOM, with DOM far the more popular. DOM performs a parse as a
  single evaluation, on the request of the programmer, returning an
  object model representing the whole of the document. At this
  level of abstraction the details of the markup are only distant
  concern. Conversely, SAX parsers are probably better considered
  as tokenisers, providing a very low-level event driven interface
  in line with the Observer pattern to notify the programmer of
  syntax as it is seen. Each element's opening and closing tag is
  noted</p>

  <p>This presents poor developer ergonomics by requiring that the
  programmer implement the recording of state with regard to the
  nodes that they have seen. For programmers using SAX, a
  conversion to their domain objects is usually implemented
  imperatively. This programming tends to be difficult to read and
  programmed once per usage rather than assembled as the
  combination of reusable parts. For this reason SAX is usually
  reserved for fringe cases where messages are very large or memory
  unusually scarce.</p>

  <p>DOM isn't just a parser, it is also a cross-language defined
  interface for manipulating the XML in real time, for example to
  change the contents of a web page in order to provide some
  interactivity. In JSON world, DOM-style parser not referring to
  the DOM spec, or what browser makers would mean. Rather,
  borrowing from the XML world to mean a parser which requires the
  whole file to be loaded.</p>

  <p>Suppose we want to extract the name of the first person. Given
  a DOM parser this is very easy:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"kw">function</span> <span class=
"fu">nameOfFirstPerson</span>( myJsonString ) {

   <span class=
"co">// Extracting an interesting part from JSON-serialised data is</span>
   <span class=
"co">// relatively easy given a DOM-style parser. Unfortunately this</span>
   <span class=
"co">// forbids any kind of progressive consideration of the data.</span>
   <span class=
"co">// All recent browsers provide a JSON parser as standard. </span>

   <span class="kw">var</span> document = <span class=
"ot">JSON</span>.<span class="fu">parse</span>( myJsonString );
   <span class="kw">return</span> <span class=
"ot">document</span>.<span class="fu">people</span>[<span class=
"dv">0</span>].<span class="fu">name</span>; <span class=
"co">// that was easy!</span>
}</code>
</pre>

  <p>Contrast with the programming below which uses the clarinet
  JSON SAX parser. To prove that I'm not exaggerating the case, see
  published usages at [Clarinet demos].</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"kw">function</span> <span class=
"fu">nameOfFirstPerson</span>( myJsonString, callbackFunction ){

   <span class=
"co">// The equivalent logic, expressed in the most natural way</span>
   <span class=
"co">// fora s JSON SAX parser is longer and much more </span>
   <span class=
"co">// difficult to read. The developer pays a high price for </span>
   <span class="co">// progressive parsing. </span>

   <span class="kw">var</span> clarinet = <span class=
"ot">clarinet</span>.<span class="fu">parser</span>(),
   
       <span class=
"co">// with a SAX parser it is the developer's responsibility </span>
       <span class=
"co">// to track where in the document the cursor currently is,</span>
       <span class=
"co">// requiring several variables to maintain.        </span>
       inPeopleArray = <span class="kw">false</span>,   
       inPersonObject = <span class="kw">false</span>,
       inNameAttribute = <span class="kw">false</span>,
       found = <span class="kw">false</span>;
   
   <span class="ot">clarinet</span>.<span class=
"fu">onopenarray</span> = <span class="kw">function</span>(){
      <span class=
"co">// for brevity we'll cheat by assuming there is only one</span>
      <span class=
"co">// array in the document. In practice this would be overly</span>
      <span class="co">// brittle.</span>
      
      inPeopleArray = <span class="kw">true</span>; 
   };
   
   <span class="ot">clarinet</span>.<span class=
"fu">onclosearray</span> = <span class="kw">function</span>(){
      inPeopleArray = <span class="kw">false</span>;
   };   
   
   <span class="ot">clarinet</span>.<span class=
"fu">onopenobject</span> = <span class="kw">function</span>(){
      inPersonObject = inPeopleArray; 
   };
   
   <span class="ot">clarinet</span>.<span class=
"fu">oncloseobject</span> = <span class="kw">function</span>(){
      inPersonObject = <span class="kw">false</span>;
   };   
      
   <span class="ot">clarinet</span>.<span class=
"fu">onkey</span> = <span class="kw">function</span>(key){
      inNameAttribute = ( inPeopleObject &amp;&amp; key == <span class="st">'name'</span>);
   };

   <span class="ot">clarinet</span>.<span class=
"fu">onvalue</span> = <span class="kw">function</span>(value){
      <span class=
"kw">if</span>( !found &amp;&amp; inNameAttribute ) {
         <span class="co">// finally!</span>
         <span class="fu">callbackFunction</span>( value );
         found = <span class="kw">true</span>;
      }
   };      
   
   <span class="ot">clarinet</span>.<span class=
"fu">write</span>(myJsonString);   
}</code>
</pre>

  <p>As we can see above, SAX's low-level semantics require a
  lengthy expression and for the programmer to maintain state
  regarding the position in the document -- usually recording the
  ancestors seen on the descent from the root to the current node
  -- in order to identify the interesting parts. This order of the
  code is also quite unintuitive; generally event handlers will
  cover multiple unrelated concerns and each concern will span
  multiple event handlers. This lends to programming in which
  separate concerns are not separately expressed in the code.</p>

  <h2 id="common-patterns-when-connecting-to-rest-services">
  <a href="#common-patterns-when-connecting-to-rest-services"><span class="header-section-number">
  3.8</span> Common patterns when connecting to REST
  services</a></h2>

  <p>Marshaling provides two-way mapping between a domain model and
  a serialisation as JSON or XML, either completely automatically
  or based on a declarative specification. To handle a fetched rest
  response it is common to automatically demarshal it so that the
  application may make use of the response from inside its own
  model, no differently from objects assembled in any other way.
  From the perspective of the programmer it is as if the domain
  objects themselves had been fetched. Another common design
  pattern, intended to give a degree of isolation between concerns,
  is to demarshal automatically only so far as Data Transfer
  Objects (DTOs), instances of classes which implement no logic
  other than storage, and from there programmatically instantiate
  the domain model objects. Going one step further, for JSON
  resources sent to loosely-typed languages with a native
  representation of objects as generic key-value pairs such as
  Javascript or Clojure, the marshaling step is often skipped: the
  output from the parser so closely resembles the language's
  built-in types that it is simplest to use it directly. Depending
  on the programming style adopted we might say that the JSON
  parser's output <em>is</em> the DTO and create domain model
  objects based on it, or that no further instantiation is
  necessary.</p>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "Degrees of automatic marshaling. From marshaling directly to domain objects, DTOs, using parser output as a DTO, or using objects directly. Distinguish work done by library vs application programmer's domain">

    <p class="caption"><em>Degrees of automatic marshaling</em>.
    From marshaling directly to domain objects, DTOs, using parser
    output as a DTO, or using objects directly. Distinguish work
    done by library vs application programmer's domain</p>
  </div>

  <p>Ultimately the degree of marshaling that is used changes only
  the level of abstraction of the resource that the REST client
  library hands over to the application developer. Regardless of
  the exact form of the response model, the developer will usually
  programmatically extract one or more parts from it via calls in
  the programming language itself. For example, on receiving a
  resource de-marshaled to domain objects, a Java developer will
  inspect it by calling a series of getters in order to narrow down
  to the interesting parts. This is not to say that the whole of
  the message might not in some way be interesting, only that by
  using it certain parts will need to be identified as distinct
  areas of concern.</p>
  <pre class="sourceCode java">
<code class="sourceCode java"><span class=
"co">// An example programmatic approach to a domain model interrogation </span>
<span class=
"co">// under Java; upon receiving a list of people, each person's name</span>
<span class=
"co">// is added to a database. The methods used to drill down to the</span>
<span class=
"co">// pertinent components of the response are all getters: getPeople, </span>
<span class="co">// getGivenName, and getSurname. </span>
<span class="dt">void</span> <span class=
"fu">handleResponse</span>( RestResponse response ) {

   <span class="kw">for</span>( Person p : response.<span class=
"fu">getPeople</span>() ) {
      <span class="fu">addNameToDb</span>( p.<span class=
"fu">getGivenName</span>(), p.<span class=
"fu">getSurname</span>() );
   }   
}</code>
</pre>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"co">// Although in this Javascript example the objects passed to the handler </span>
<span class=
"co">// remain in the form given by the JSON parser, containing no domain-specific</span>
<span class=
"co">// getters, the programming represents a different expression of the same </span>
<span class="co">// basic process.</span>
<span class="kw">function</span> <span class=
"fu">handleResponse</span>( response ){

   <span class="ot">response</span>.<span class=
"ot">people</span>.<span class="fu">forEach</span>( <span class=
"kw">function</span>( person ){
      <span class="fu">addNameToDb</span>( <span class=
"ot">p</span>.<span class="fu">givenName</span>, <span class=
"ot">p</span>.<span class="fu">surname</span> );
   });
}</code>
</pre>

  <p>Because it is applied directly to the metamodel of the
  language[^ It could be argued that getters aren't a part of the
  metamodel of Java itself, but they form such a common pattern
  that it is a part ], this extraction has become such a natural
  component of a workflow that it maye be used while thinking of it
  as wholly unremarkable. In the examples above we are interacting
  with the model in the way that the language makes the most easy
  to conceptualise. However se should consider that, however subtly
  embedded, the technique is an invented construct and only one of
  the possible formulations which might have been drawn.</p>

  <p>One weakness of this inspection model is that, once much code
  is written to interrogate models in this way, the interface of
  the model becomes increasingly expensive to change as the code
  making the inspections becomes more tightly coupled with the
  thing that it is inspecting. Taking the above example, if the
  model were later refactored such that the concepts of firstName
  and surName were pulled from the Person class into an extracted
  Name class, because the inspection relies on a sequence of calls
  made directly into domain objects, the code making the query
  would also have to change. Whilst following the object oriented
  principle of encapsulation of data, such that the caller does not
  have to concern themselves with the data structures hidden behind
  the getter, there is no such abstraction for when the structure
  itself changes. Given an Agile environment where the shape of
  data is refactored regularly, this would be a problem when
  programming against any kind of resource; for example, if change
  of objects formats propagates knock-on changes where ever the
  object is used it is very difficult to commit small diffs to the
  VCS which make incremental changes to a tightly focused area of
  the system. A method of programming which truly embraced extreme
  programming would allow constant change without disparate, barely
  related parts having to be modified in parallel when structural
  refactoring occurs. The coupling is all the more acute where the
  format of the item being inspected is defined by an independently
  maintained service.</p>

  <p><em>contagion problem</em></p>

  <p>Extraneous changes dilute the changelog, making it less easily
  defined by code changes which are intrinsically linked to the
  actual change in the logic being expressed by the program, and
  therefore to the thinking behind the change and the reason for
  the change.</p>

  <h2 id="jsonpath-and-xpath"><a href=
  "#jsonpath-and-xpath"><span class=
  "header-section-number">3.9</span> JsonPath and XPath</a></h2>

  <p>Both the above difficulty in identifying the interesting parts
  of a message whilst using a streaming parser and the problem with
  tight coupling of programmatic drilling down to REST formats
  leads me to search for areas where this problem has already been
  solved.</p>

  <p>In the domain of markup languages there are associated query
  languages such as XPATH whose coupling is loose enough that their
  expressions may continue to function after the exact shape of a
  message is refactored. While observing this is nothing more
  radical than using the query languages in more-or-less they were
  intended, their employment is not the most natural coming from a
  programming context in which the application developer's
  responsibilities usually start where the demarshaler's end.
  Consider the following XML:</p>
  <pre class="sourceCode xml">
<code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;givenName&gt;</span>...<span class=
"kw">&lt;/givenName&gt;</span>   
      <span class="kw">&lt;familyName&gt;</span>Bond<span class=
"kw">&lt;/familyName&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code>
</pre>

  <p>The XPath //person[0]//surname//text() would continue to
  identify the correct part of the resource without being updated
  after the xml analogue of the above Java Name refactor:</p>
  <pre class="sourceCode xml">
<code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;name&gt;</span>
         <span class="kw">&lt;givenName&gt;</span>...<span class=
"kw">&lt;/givenName&gt;</span>
         <span class="kw">&lt;familyName&gt;</span>Bond<span class=
"kw">&lt;/familyName&gt;</span>
      <span class="kw">&lt;/name&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code>
</pre>

  <p>Luckily in JSON there exists already an attempt at an
  equivalent named Jsonpath. JsonPath closely resembles the
  javascript code which would select the same nodes. Not a real
  spec.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">
<span class=
"co">// an in-memory person with a multi-line address:</span>
<span class="kw">let</span> person = {
   <span class="dt">name</span>: {<span class=
"dt">givenName</span>:<span class="st">''</span>, <span class=
"dt">familyName</span>:<span class="st">''</span>},
   <span class="dt">address</span>: [
      <span class="st">"line1"</span>,
      <span class="st">"line2"</span>,
      <span class="st">"line3"</span>
   ]
}


<span class=
"co">// in javascript we can get line two of the address as such:</span>
<span class="kw">let</span> address = <span class=
"ot">person</span>.<span class="fu">address</span>[<span class=
"dv">2</span>]

<span class=
"co">// the equivalent jsonpath expression is identical:</span>
<span class="kw">let</span> jsonPath = <span class=
"st">"person.address[2]"</span>

<span class=
"co">// although jsonpath also allows ancestor relationships which are not</span>
<span class=
"co">// expressible quite so neatly as basic Javascript:</span>
<span class="kw">let</span> jsonPath2 = <span class=
"st">"person..given"</span></code>
</pre>

  <p>Xpath is able to express identifiers which often survive
  refactoring because XML represents a tree, hence we can consider
  relationships between entities to be that of contains/contained
  in (also siblings?). In application of XML, in the languages that
  we build on top of XML, it is very natural to consider all
  elements to belong to their ancestors. Examples are myriad, for
  example consider a word count in a book written in DOCBook format
  - it should be calculable without knowing if the book is split
  into chapters or not since this is a concept internal to the
  organisation of the book itself nd not something that a querier
  is likely to find interesting - if this must be considered the
  structure acts as barrier to information rather than enabling the
  information's delivery. Therefore, in many cases the exact
  location of a piece of information is not as important as a more
  general location of x being in some way under y.</p>

  <p>This may not always hold. A slightly contrived example might
  be if we were representing a model of partial knowledge:</p>
  <pre class="sourceCode xml">
<code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;name&gt;</span>
         <span class=
"kw">&lt;isNot&gt;&lt;surname&gt;</span>Bond<span class=
"kw">&lt;/surname&gt;&lt;/isNot&gt;</span>
      <span class="kw">&lt;/name&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code>
</pre>

  <p>The typical use pattern of XPath or JSONPath is to search for
  nodes once the whole serialisation has been parsed into a
  DOM-style model. JSONPath implementation only allows for
  search-type usage: <a href=
  "https://code.google.com/p/jsonpath/To">https://code.google.com/p/jsonpath/To</a>
  examine a whole document for the list of nodes that match a
  jsonpath expression the whole of the tree is required. But to
  evaluate if a single node matches an expression, only the
  <em>path of the descent from the root to that node</em> is
  required -- the same state as a programmer usually maintains
  whilst employing a SAX parser. This is possible because JSONPath
  does not have a way to express the relationship with sibling
  nodes, only ancestors and decedents.</p>

  <p>One limitation of the JSONPath language is that it is not
  possible to construct an 'containing' expression. CSS4 allows
  this in a way that is likely to become familiar to web developers
  over the next five years or so.</p>

  <h2 id="testing"><a href="#testing"><span class=
  "header-section-number">3.10</span> Testing</a></h2>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "Relationship between the main players in the JS testing landscape. JSTD, Karma, Jasmine, NodeUnit, jasmine-node, Browsers">

    <p class="caption">Relationship between the main players in the
    JS testing landscape. JSTD, Karma, Jasmine, NodeUnit,
    jasmine-node, Browsers</p>
  </div>

  <p>By the commonjs spec, test directory should be called 'test'
  (<a href=
  "http://wiki.commonjs.org/wiki/Packages/1.0">http://wiki.commonjs.org/wiki/Packages/1.0</a>#Package_Directory_Layout)
  doesn't matter for my project since not using commonjs, but might
  as well stick to the convention.</p>

  <p>How TDD helps How can fit into methodology</p>

  <ul>
    <li>JSTD</li>

    <li>NodeUnit</li>

    <li>Karma</li>

    <li>Jasmine</li>
  </ul>

  <p>Initially started with jstestdriver but found it difficult.
  Karma started because engineers working on the Angular project in
  Google were "struggling a lot with jstd": <a href=
  "http://www.youtube.com/watch?v=MVw8N3hTfCI">http://www.youtube.com/watch?v=MVw8N3hTfCI</a>
  - jstd is a google project Even Jstd's authors seems to be
  disowning it slightly. Describe what was once its main mode of
  operation as now being for stress testing of jstd itself only.
  Problems: browsers become unresponsive. Generally unreliable, has
  to be restarted frequently.</p>

  <p>JSTD, as a Java program, is difficult to start via Grunt. Also
  an issue that Grunt post-dates Karma by enough that JSTD doesn't
  have the attention of the Grunt community.</p><!---
Chapter 4+5 40 to 60 pages

@333w/p, 13,000 to 19,000
=-->

  <h1 id="design-and-reflection"><a href=
  "#design-and-reflection"><span class=
  "header-section-number">4</span> Design and Reflection:</a></h1>

  <p>Using a combination of the techniques investigated in the
  previous chapter, I propose that a simple design is possible
  which makes REST clients more efficient whilst being no more
  difficult to program. Although simple, this model fits poorly
  with established vocabulary, requiring a transport that sits
  <em>somewhere between 'stream' and 'download'</em> and a parsing
  strategy which <em>takes elements from SAX and DOM</em> but
  follows neither model.</p>

  <p>Implementation in Javascript gives me the widest deployment
  options, covering client-side browser programming, server
  programming, use in command line tools, or any other usage. This
  context dictates a design which is non-blocking, asynchronous and
  callback based. While influenced by the language, the model of
  REST client proposed here is not limited to Javascript or web
  usage and I intent to comment briefly also on the applicability
  to other platforms. Likewise, I have also chosen to focus on JSON
  although I will also be commenting on the parallel applicability
  of these ideas to XML.</p>

  <p>From DOM we may observe that as a programmer, using a resource
  is simpler when a parsed entity is passed whole to a single
  callback, rather than the SAX model which requires the programmer
  to infer the entity from a lengthy series of callbacks. From
  observing SAX parsers or progressive HTML rendering, we can say
  that http is more efficient if we no not wait until we have
  everything before we start using the parts that we do have. DOM
  parsers pass a fully parsed node to registered callbacks, whole
  and ready to use, invariably at the root of the parsed document.
  From the vantage of the library's user, my thesis duplicates this
  convenience but removes one restriction; that the node which is
  passed must be the root. Because the mark-up formats we are
  dealing with are hierarchical and serialised depth-first it is
  possible to fully parse any sub-tree without fully knowing the
  parent node. From these observations we may program a new kind of
  REST client which is as performant as SAX but as easy to program
  as DOM.</p>

  <p>To follow this progressive-but-complete model, identifying the
  interesting parts of a document involves turning the traditional
  model for drilling down inside-out. Traditionally the
  programmer's callback receives the document then inside that
  callback drills down to locate the parts that they are interested
  in. Instead I propose taking the drilling-down logic out from
  inside the callback and instead wrap the callback in it. This
  means that the callback receives selected parts of the response
  which the library has already drilled down to on behalf of the
  programmer.</p>

  <p>Whilst JSONPath's existing implementation is only implemented
  for searching over already gathered objects, this kind of
  searching is just one application for the query language. I find
  that this is a very suitable declarative language to use to
  specify the parts of a response that a developer would like to
  drill-down to given the context of a document whose parse is in
  progress. JSONPath is especially applicable because it specifies
  only 'contained-in/contains' type relationships. On encountering
  any node in a serialised JSON stream, because of the depth-first
  serialisation order I will always have previously seen its
  ancestors. Hence, having written a suitably flexible JSONPath
  expression compiler such that it does not require a complete
  document, I will have enough information to evaluate any
  expression against any node at the time when it is first
  identified in the document. Because XML is also written
  depth-first, the same logic would apply to an XPath/XML variant
  of this project.</p>

  <p>The definition of 'interesting' will be generic and
  accommodating enough so as to apply to any data domain and allow
  any granularity of interest, from large object to individual
  datums. With just a few lines of programming</p>

  <h2 id="jsonpath-and-types"><a href=
  "#jsonpath-and-types"><span class=
  "header-section-number">4.1</span> JSONPath and types</a></h2>

  <p>Given its use to identify interesting parts of a document, not
  all of the published JSONPath spec is useful. Parts of a document
  will be considered interesting because of their type, position,
  or both. This contrasts with filter-type queries such as 'books
  costing less than X'. Examining REST responses it is likely we
  will not be explicitly searching through a full model but rather
  selecting from a resource subset that the programmer requested,
  assembled on their behalf using their parameters so we can expect
  the developer to be interested in most of the content. In
  creating a new JSONPath implementation, I have chosen to follow
  the published spec only loosely, thereby avoiding writing
  unnecessary code. This is especially the case, as in the books
  example above whereby a user of the library could easily add the
  filter in the callback itself. Following the principle of writing
  less, better I feel it is better to deliver only the features I
  am reasonably certain will be well used but keep open the ability
  to add more later should it be required.</p>

  <p>JSON markup describes only a few basic types. On a certain
  level this is also true for XML -- most nodes are of either type
  Elements or Text. However, the XML metamodel provides tagnames,
  essentially a built-in Element sub-typing mechanism. Floating
  above this distinction, a reader abstracting over the details of
  the markup may forget that a node is an Element instance and
  describe it as an instance of its tagname, without considering
  that the tagname is a sub-type of Element. JSON comes with no
  such built-in type description language. On top of JSON's largely
  typeless model we often place a concept of type. Drawing
  parallels with the physical world, this imposition of type is the
  responsibility of the observer, rather than of the observed. A
  document reader has a free choice of the taxonomy they will use
  to impose type on the parts of the document, and this decision
  will vary depending on the purpose of the reader. The specificity
  required of a taxonomy differs by the level of involvement in a
  field, whereas 'watch' may be a reasonable type to most data
  consumers, to a horologist it is unlikely to be satisfactory
  without further sub-types. In the scope of this dissertation,
  since selecting on type is desirable, my JSONPath variant must be
  able to distinguish types at various levels of specificity;
  whilst my selection language will have no inbuilt concept of
  type, the aim is to support programmers in creating their
  own.</p>

  <p><em>integrate with above or discard, maybe move to
  compatibility with future versions</em> Relationship between type
  of a node and its purpose in the document (or, perhaps, the
  purpose the reader wishes to put it to). Purpose is often obvious
  from a combination of URL and type so can disregard the place in
  the document. This structure may be carefully designed but
  ultimately a looser interpretation of the structure can be
  safer.</p>
  <pre class="sourceCode xml">
<code class="sourceCode xml"><span class=
"co">&lt;!--  XML leaves no doubt as to the labels we give to the types</span>
<span class=
"co">      of the nodes. This is a 'person' --&gt;</span>
<span class="kw">&lt;person</span><span class=
"ot">  name=</span><span class="st">'...'</span><span class=
"ot"> gender=</span><span class="st">"male"</span>
<span class="ot">         age=</span><span class=
"st">"45"</span><span class="ot"> height=</span><span class=
"st">"175cm"</span><span class="ot"> profession=</span><span class=
"st">"architect"</span><span class="kw">&gt;</span>
<span class="kw">&lt;/person&gt;</span></code>
</pre>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"co">/*    JSON meanwhile provides no such concrete concept. This node's</span>
<span class=
"co">      type might be 'thing', 'animal', 'human', 'man', 'architect',</span>
<span class=
"co">      'artist' or any other of many overlapping impositions depending </span>
<span class=
"co">      on what purpose the document it is read for */</span>
{  <span class="st">"name"</span>:<span class=
"st">"..."</span>, <span class="st">"gender"</span>:<span class=
"st">"male"</span>, <span class="st">"age"</span>:<span class=
"st">"45"</span> 
   <span class="st">"height"</span>:<span class=
"st">"175cm"</span> <span class=
"st">"profession"</span>:<span class="st">"architect"</span>&gt;
}         </code>
</pre>

  <p>In the absence of node typing beyond the categorisation as
  objects, arrays and various primitive types, the key immediately
  mapping to the object is often taken as a lose concept of the
  type of the object. Quite fortunately, rather than because of a
  well considered object design, this tends to play well with
  automatically marshaling of domain objects expressed in a
  Java-style OO language because there is a strong tendency for
  field names -- and by extension, 'get' methods -- to be named
  after the <em>type</em> of the field, the name of the type also
  serving as a rough summary of the relationship between two
  objects. See figure below.</p>

  <p>In the below example, we impose the the type 'address' because
  of the parent node's field name. Other than this, these are
  standard arrays of strings:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">{
   <span class="dt">name</span>: <span class="st">'...'</span>
,  <span class="dt">residence</span>: {
      <span class="dt">address</span>: [
         <span class="st">'...'</span>, <span class=
"st">'...'</span>, <span class="st">'...'</span>
      ]
   }
,  <span class="dt">employer</span>: {
      <span class="dt">name</span>: <span class="st">'...'</span>
   ,  <span class="dt">address </span>:[
         <span class="st">'...'</span>, <span class=
"st">'...'</span>, <span class="st">'...'</span>      
      ]
   }   
}</code>
</pre>

  <p>Although, being loosely typed, in Javascript there is no
  protection against using arrays to contain disparate object, by
  sensible convention the items will usually be of some common
  type. Likewise in JSON, although type is a loose concept, on some
  level the elements of an array will generally be of the same
  type. This allows a sister convention seen in the below example,
  whereby each of a list of items are typed according to the key in
  the grandparent node which maps to the array.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">{
   <span class="dt">residences</span>: {
      <span class="dt">addresses</span>: [
         [<span class="st">'Townhouse'</span>, <span class=
"st">'Underground street'</span>, <span class=
"st">'Far away town'</span>]      
      ,  [<span class="st">'Beach Hut'</span>, <span class=
"st">'Secret Island'</span>, <span class="st">'Bahamas'</span>]
      ]
   }
}</code>
</pre>

  <p>The pluralisation of 'address' to 'addresses' above may be a
  problem to a reader wishing to detect address nodes. I considered
  introducing an 'or' syntax for this situation, resembling
  <code>address|addresses.*</code> but instead decided this
  problem, while related to type, is simpler to solve outside of
  the JSONPath language. A programmer may simply use two JSONPaths
  mapping to the same callback function.</p>

  <p>In the below example typing is trickier still.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">{
   <span class="dt">name</span>: <span class="st">'...'</span>
,  <span class="dt">residence</span>: {
      <span class="dt">number</span>:<span class=
"st">'...'</span>, <span class="dt">street</span>:<span class=
"st">'...'</span>, <span class="dt">town</span>:<span class=
"st">'...'</span> 
   }
,  <span class="dt">employer</span>:{
      <span class="dt">name</span>: <span class="st">'...'</span>
   ,  <span class="dt">premises</span>:[
         { <span class="dt">number</span>:<span class=
"st">'...'</span>, <span class="dt">street</span>:<span class=
"st">'...'</span>, <span class="dt">town</span>:<span class=
"st">'...'</span> }
      ,  { <span class="dt">number</span>:<span class=
"st">'...'</span>, <span class="dt">street</span>:<span class=
"st">'...'</span>, <span class="dt">town</span>:<span class=
"st">'...'</span> }
      ,  { <span class="dt">number</span>:<span class=
"st">'...'</span>, <span class="dt">street</span>:<span class=
"st">'...'</span>, <span class="dt">town</span>:<span class=
"st">'...'</span> }
      ]
   ,  <span class="dt">registeredOffice</span>:{
         <span class="dt">number</span>:<span class=
"st">'...'</span>, <span class="dt">street</span>:<span class=
"st">'...'</span>, <span class="dt">town</span>:<span class=
"st">'...'</span>
      }
   }
}  </code>
</pre>

  <p>The properties holding addresses are named by the relationship
  between the parent and child nodes rather than the type of the
  child. There are two ways we may be able to select objects out as
  addresses. Firstly, because of an ontology which subtypes
  'residence', 'premises', and 'office' as places with addresses.
  More simply, we may import the idea of duck typing from Python
  programing.</p>

  <blockquote>
    <p>In other words, don't check whether it IS-a duck: check
    whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc,
    depending on exactly what subset of duck-like behaviour you
    need to play your language-games with.</p>
  </blockquote>

  <p>Discussion of typing in Python language, 2000. <a href=
  "https://groups.google.com/forum/?hl=en">https://groups.google.com/forum/?hl=en</a>#!msg/comp.lang.python/CCs2oJdyuzc/NYjla5HKMOIJ</p>

  <p>A 'duck-definition' of address might be any object which has a
  number, street and town. That is to say, type is
  individualistically communicated by the object itself rather than
  by examining the relationships described by its containing
  ancestors. JSONPath comes with no such expressivity but I find
  this idea so simple and useful that I have decided to create one.
  The JSONPath language is designed to resemble programmatic
  Javascript access but Javascript has no syntax for a list of
  value-free properties. The closest available is the object
  literal format; my duck-type syntax is a simplification with
  values and commas omitted. In the case of the addresses a
  duck-type expression would be written as <code>{number street
  town}</code>. Generally, when identifying items of a type from a
  document it makes sense if the type expression is contravariant
  so that sub-types are also selected. If we consider that we
  create a sub-duck-type when we add to a list of required fields
  and super-duck-types when we remove them, we have a non-tree
  shaped type space with root type <code>{}</code> which matches
  any object. Therefore, the fields specified need not be an
  exhaustive list of the object's properties.</p>

  <p>The various means of discerning type which are constructable
  need not be used exclusively. For example, <code>aaa{bbb
  ccc}</code> is a valid construction combining duck typing and the
  relationship with the parent object.</p>

  <h2 id="jsonpath-improving-stability-over-upgrades"><a href=
  "#jsonpath-improving-stability-over-upgrades"><span class=
  "header-section-number">4.2</span> JSONPath improving stability
  over upgrades</a></h2>

  <p><em>need to look at this an check doesn't duplicate rest of
  diss</em>.</p>

  <ul>
    <li>Use of <code>..</code> over <code>.</code></li>

    <li>Keep this short. Might not need diagram if time
    presses.</li>
  </ul>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "extended json rest service that still works - maybe do a table instead ">

    <p class="caption">extended json rest service that still works
    - maybe do a table instead</p>
  </div>

  <p>Programming to identify a certain interesting part of a
  resource today should with a high probability still work when
  applied to future releases.</p>

  <p>Requires some discipline on behalf of the service provider:
  Upgrade by adding of semantics only most of the time rather than
  changing existing semantics.</p>

  <p>Adding of semantics should could include adding new fields to
  objects (which could themselves contain large sub-trees) or a
  "push-down" refactor in which what was a root node is pushed down
  a level by being suspended from a new parent.</p>

  <p>why JSONPath-like syntax allows upgrading message semantics
  without causing problems [SOA] how to guarantee non-breakages?
  could publish 'supported queries' that are guaranteed to work</p>

  <h2 id="importing-css4-selector-capturing-to-oboe-jsonpath">
  <a href=
  "#importing-css4-selector-capturing-to-oboe-jsonpath"><span class="header-section-number">
  4.3</span> Importing CSS4 selector capturing to Oboe
  JSONPath</a></h2>

  <p>Sometimes when downloading a collection of items it is less
  useful to be given each element individually than being kept up
  to date as the collection is expanded. Certain Javascript
  libraries such as d3.js and Angular interface more naturally with
  arrays of items than individual entities. To allow integration
  with these libraries, on receiving an array of items it is useful
  to be repeatedly passed the same containing array whenever a new
  element is concatenated onto it.</p>

  <p>Expressing a 'contained in' relationship comes naturally to
  JSONPath, but no provision is made for a 'containing'
  relationship. Cascading Style Sheets, or CSS, the web's styling
  language has long shared this restriction but a recent proposal,
  currently at Editor's Draft stage <span class="citation">(Etemad
  and Atkins 2013)</span> provides an elegant means to cover this
  gap. Rather than add an explicit 'containing' relationship, the
  css4 proposal observes that css selectors have previously only
  allowed selection of the right-most of the terms given, allowing
  only the deepest element mentioned to be selected. This
  restriction is removed by allowing terms may be prefixed with
  <code>$</code> in order to make them capturing: in the absence of
  an explicitly capturing term the right-most continues to capture.
  Whereas <code>form.important input.mandatory</code> selects for
  styling mandatory inputs inside important forms,
  <code>$form.important input.mandatory</code> selects important
  forms with mandatory fields.</p>

  <p>Importing the CSS4 dollar into Oboe's JSONPath should make it
  much easier to integrate with libraries which treat arrays as
  their basic unit of operation and uses a syntax which the
  majority of web developers are likely to be familiar with over
  the next few years.</p>

  <h2 id="parsing-the-json-response"><a href=
  "#parsing-the-json-response"><span class=
  "header-section-number">4.4</span> Parsing the JSON
  Response</a></h2>

  <p>While SAX parsers provide an unfriendly interface to
  application developers, as a starting point for higher-level
  parsers they work very well (in fact, most XML DOM parsers are
  made in this way). The pre-existing project Clarinet is well
  tested, liberally licenced and compact, meeting the goals of this
  project perfectly. In fact, the name of this project, Oboe.js,
  was chosen in tribute to the value delivered by Clarinet.</p>

  <h2 id="api-design"><a href="#api-design"><span class=
  "header-section-number">4.5</span> API design</a></h2>

  <p><em>API allows body to be given as Object and converts into
  JSON because it is anticipated that REST services which emmit
  JSON will also accept it</em></p>

  <p>In designing the API developer ergonomics are the top
  priority. This is especially pertinent given that the library
  does nothing that can't be done with existing tools such as JSON
  SAX parsers but that those tools are not used because they
  require too much effort to form a part of most developers'
  everyday toolkit.</p>

  <p><em>Expose single global.</em></p>

  <p>To pursue good ergonomics, I will study successful libraries
  and, where appropriate, copy their APIs. We may assume that the
  existing libraries have already over time come to refined
  solutions to similar problems. Working in a style similar to
  existing libraries also makes the library easier to learn.
  Lastly, if we create a library which functions similarly enough
  to existing tools it should be easy to modify an existing project
  to adopt it. In the most common use cases, it should be possible
  to create a library with a close functional equivalence that can
  be used as a direct drop-in replacement. Used in this way, no
  progressive loading would be done but it opens the door for the
  project taking up the library to be refactored towards a
  progressive model over time. By imitating existing APIs we allow
  adoption as a series of small, easily manageable steps rather
  than a single leap. This is especially helpful for teams wishing
  to adopt this project working under Scrum because all tasks must
  be self-contained and fit within a fairly short timeframe.</p>

  <p>jQuery's basic call style for making an AJAX GET request
  follows:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"ot">jQuery</span>.<span class="fu">ajax</span>(<span class=
"st">"resources/shortMessage.txt"</span>)
   .<span class="fu">done</span>(<span class=
"kw">function</span>( text ) {
      <span class="ot">console</span>.<span class=
"fu">log</span>( <span class=
"st">'Got the text: '</span> + text ); 
   }).
   .<span class="fu">fail</span>(<span class=
"kw">function</span>(data) {
      <span class="ot">console</span>.<span class=
"fu">log</span>( <span class=
"st">'the request failed'</span> );      
   });</code>
</pre>

  <p>While for simple web applications usage is much as above,<br>
  In real world usage on more complex apps jQuery.ajax is often
  injected into the scope of the code which wants to use it. Easier
  stubbing so that tests don't have to make actual AJAX calls.</p>

  <p>While certainly callback-based, the jQuery is somewhat
  implicit in being event-based. There are no event names separate
  from the methods which add the listeners and there are no event
  objects, preferring to pass the content directly. The names used
  to add the events (done, fail) are also generic, used for all
  asynchronous requests. The methods are chainable which allows
  several listeners to be added in one statement.</p>

  <p>By method overloading, if the request requires more
  information than the parameter to <code>jQuery.ajax</code> may be
  an object. This pattern of accepting function parameters as an
  object is a common in Javascript for functions that take a large
  number of optional arguments because it makes understanding the
  purpose of each argument easier to understand from the callsite
  than if the meaning depended on the position in a linear
  arguments list and the gaps filled in with nulls.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"ot">jQuery</span>.<span class="fu">ajax</span>({ <span class=
"dt">url</span>:<span class=
"st">"resources/shortMessage.txt"</span>,
              <span class="dt">accepts</span>: <span class=
"st">"text/plain"</span>,
              <span class="dt">headers</span>: { <span class=
"st">'X-MY-COOKIE'</span>: <span class="st">'123ABC'</span> }
           });</code>
</pre>

  <p>Taking on this style,</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"fu">oboe</span>(<span class="st">'resources/someJson.json'</span>)
   .<span class="fu">node</span>( <span class=
"st">'person.name'</span>, <span class=
"kw">function</span>(name, path, ancestors) {
      <span class="ot">console</span>.<span class=
"fu">log</span>(<span class="st">"got a name "</span> + name);   
   })
   .<span class="fu">done</span>( <span class=
"kw">function</span>( wholeJson ) {
      <span class="ot">console</span>.<span class=
"fu">log</span>(<span class="st">'got everything'</span>);
   })
   .<span class="fu">fail</span>( <span class=
"kw">function</span>() {
      <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">'actually, the download failed. Forget the'</span> + 
                  <span class=
"st">' people I just told you about'</span>);
   });</code>
</pre>

  <p>Because I foresee several patterns being added for most types
  of JSON documents, a shortcut format is also available for adding
  multiple patterns in a single call by using the patterns as the
  keys and the callbacks as the values in a key/value mapping:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"fu">oboe</span>(<span class="st">'resources/someJson.json'</span>)
   .<span class="fu">node</span>({  
      <span class="st">'person.name'</span>: <span class=
"kw">function</span>(personName, path, ancestors) {
         <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">"let me tell you about "</span> + name);
      },
      <span class="st">'person.address.town'</span>: <span class=
"kw">function</span>(townName, path, ancestors) {
         <span class="ot">console</span>.<span class=
"fu">log</span>(<span class=
"st">"they live in "</span> + townName);
      }
   });</code>
</pre>

  <p>Note the path and ancestors parameters in the examples above.
  Most of the time giving the callback the matching content is
  enough to be able to act but it is easy to imagine cases where a
  wider context matters. Consider this JSON:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">{ 
   <span class="st">"event"</span>: <span class=
"st">"mens 100m"</span>,
   <span class="st">"date"</span>: <span class=
"st">"5 Aug 2012"</span>,
   <span class="st">"medalWinners"</span>: {
      <span class="st">"gold"</span>:     {<span class=
"st">"name"</span>: <span class="st">'Bolt'</span>,    <span class=
"st">"time"</span>: <span class="st">"9.63s"</span>},
      <span class="st">"silver"</span>:   {<span class=
"st">"name"</span>: <span class="st">'Blake'</span>,   <span class=
"st">"time"</span>: <span class="st">"9.75s"</span>},
      <span class="st">"bronze"</span>:   {<span class=
"st">"name"</span>: <span class="st">'Gatlin'</span>,  <span class=
"st">"time"</span>: <span class="st">"9.79s"</span>}
   }
}  </code>
</pre>

  <p>Here we can extract the runners by the patterns such as
  <code>{name time}</code> or <code>medalWinners.*</code> but
  clearly the location of the node in the document is interesting
  as well as the context. The <code>path</code> parameter provides
  this information by way of an array of strings plotting the
  descent from the JSON root to the match, for example
  <code>['medalWinners', 'gold']</code>. Similarly, the
  <code>ancestors</code> array is a list of the ancestors starting
  at the immediate parent of the found node and ending with the
  JSON root node. For all but the root node (which has no ancestors
  anyway) the nodes in this list will be only partially parsed.
  Being untyped, Javascript does not enforce the arity of the
  callback. Because much of the time only the content itself is
  needed, the API design orders the callback parameters to take
  advantage of the loose typing so that a unary function taking
  only the content may be given.</p>

  <p>For the widest context currently available, the whole document
  as it has been parsed so far may be accessed using the
  <code>.root</code> method. Since <code>.root</code> relates to
  the oboe instance itself rather than the callback per-say, it can
  be accessed from any code with a reference to the oboe
  object.</p>

  <p>
  <code>http://nodejs.org/docs/latest/api/events.html#events_emitter_on_event_listener</code></p>

  <p>In node.js the code style is more obviously event-based.
  Listeners are added via a <code>.on</code> method with a string
  event name given as the first argument. Adopting this style, my
  API design for oboe.js also allows events to be added as:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"fu">oboe</span>(<span class="st">'resources/someJson.json'</span>)
   .<span class="fu">on</span>( <span class=
"st">'node'</span>, <span class=
"st">'medalWinners.*'</span>, <span class=
"kw">function</span>(person, path, ancestors) {
      <span class="ot">console</span>.<span class=
"fu">log</span>( <span class="ot">person</span>.<span class=
"fu">name</span> + <span class=
"st">' won the '</span> + <span class=
"fu">lastOf</span>(path) + <span class="st">' medal'</span> );
   });</code>
</pre>

  <p>While allowing both styles uncountably creates an API which is
  larger than it needs to be, creating a library which is targeted
  at both the client and server side, I hope this will help
  adoption by either camp. The Two styles are similar enough that a
  person familiar with one should be able to pick up the other
  without difficulty. In implementation a duplicative API should
  require only a minimal degree of extra coding because these parts
  may be expressed in common and their scope reduced using partial
  completion. Because <code>'!'</code> is the JSONPath for the root
  of the document, for some callback c, <code>.done(c)</code> is a
  synonym for <code>.node('!', c)</code> and therefore below a thin
  interface layer may share an implementation. Likewise,
  <code>.node</code> is easily expressible as a partial completion
  of <code>.on</code> with <code>'node'</code>.</p>

  <h2 id="earlier-callbacks-when-paths-are-matched"><a href=
  "#earlier-callbacks-when-paths-are-matched"><span class=
  "header-section-number">4.6</span> Earlier callbacks when paths
  are matched</a></h2>

  <p>Following with the project's aim of giving callbacks as early
  as possible, sometimes useful work can be done when a node is
  known to exist but before we have the contents of the node. This
  means that each node found in a JSON document has the potential
  to trigger notifications at two points: when it is first
  discovered and when it is complete. The API facilitates this by
  providing a <code>path</code> callback following much the same
  pattern as the <code>node</code> callback.</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"fu">oboe</span>(<span class="st">'events.json'</span>)
   .<span class="fu">path</span>( <span class=
"st">'medalWinners'</span>, <span class="kw">function</span>() {
      <span class=
"co">// We don't know the winners yet but we know we have some so let's</span>
      <span class=
"co">// start drawing the table already:    </span>
      <span class="kw">interface</span>.<span class=
"fu">showMedalTable</span>();
   })
   .<span class="fu">node</span>( <span class=
"st">'medalWinners.*'</span>, <span class=
"kw">function</span>(person, path) {    
      <span class="kw">interface</span>.<span class=
"fu">addPersonToMedalTable</span>(person, <span class=
"fu">lastOf</span>(path));
   })
   .<span class="fu">fail</span>( <span class=
"kw">function</span>(){
      <span class="co">// That didn't work. Revert!</span>
      <span class="kw">interface</span>.<span class=
"fu">hideMedalTable</span>();
   });</code>
</pre>

  <p>In implementation providing path notifications is a simple
  matter of allowing the evaluation of the json path expressions
  when items are pushed to the stack of current nodes in addition
  to when they are popped.</p>

  <h2 id="oboe.js-as-a-micro-library"><a href=
  "#oboe.js-as-a-micro-library"><span class=
  "header-section-number">4.7</span> Oboe.js as a
  Micro-Library</a></h2>

  <p>Http traffic, especially sending entropy-sparse text formats
  is often gzipped at point of sending in order to deliver it more
  quickly, so in measuring a download footprint it usually makes
  more sense to compare post-gzipping. A Javascript library
  qualifies as being <em>micro</em> if it is delivered in 5k or
  less, 5120 bytes. Micro-libraries also tend to follow the ethos
  that it is better for a developer to gather together several tiny
  libraries than one that uses a one-size-fits-all approach,
  perhaps echoing the unix command line tradition of small programs
  which each do do exactly one thing. Javascript Micro-libraries
  are listed at,<sup><a href="#fn4" class="footnoteRef" id="fnref4"
  name="fnref4">4</a></sup> which includes this project. Oboe.js
  feels on the edge of what is possible to elegantly do as a
  micro-library so while the limit is somewhat arbitrary, for the
  sake of adoption smaller is better and keeping below this limit
  whilst writing readable code is an interesting challenge. As well
  as being a small library, in the spirit of a micro-library a
  project should impose as few restrictions as possible on its use
  and be designed to be completely agnostic as to which other
  libraries or programming styles that it is used with.</p>

  <h2 id="handling-transport-failures"><a href=
  "#handling-transport-failures"><span class=
  "header-section-number">4.8</span> Handling transport
  failures</a></h2>

  <p>Oboe should allow requests to fail while the response is being
  received without necessarily losing the part that was
  successfully received.</p>

  <p>Researching error handing, I considered the option of
  automatically resuming failed requests without intervention from
  the containing application. Http 1.1 provides a mechanism for
  Byte Serving via the <code>Accepts-Ranges</code> header [<a href=
  "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>#sec14.5]
  which is used to request any contiguous fragment of a resource --
  in our case, the part that we missed when the download failed.
  Having examined this option I came to the conclusion that it
  would encourage brittle systems because it assumes two requests
  to the same URL will give byte-wise equal responses.</p>

  <p>A deeper problem is that Oboe cannot know the correct
  behaviour when a request fails so this is better left to the
  containing applications. Generally on request failure, two
  behaviours may be anticipated. If the actions performed in
  response to data received up to time of failure remain valid in
  the absence of a full transmission, their effects may be kept and
  a URL may be constructed to request just the lost part.
  Alternatively, under optimistic locking, the application
  developer may choose to perform rollback. In either case,
  responding to errors beyond informing the calling application is
  outside of Oboe's scope.</p>

  <p>IO errors in a non-blocking system cannot be handled via
  exception throwing because the call which will later cause an
  error will no longer be on the stack at the time that the error
  occurs. Error-events will be used instead.</p>

  <h2 id="fallback-support-on-less-capable-platforms"><a href=
  "#fallback-support-on-less-capable-platforms"><span class=
  "header-section-number">4.9</span> Fallback support on
  less-capable platforms</a></h2>

  <p><em>something about market share and link to figures in an
  appendix?</em></p>

  <p>Because of differences in the capabilities in browsers,
  providing a streaming REST client is not possible on all
  browsers. If this were possible, it would not have been necessary
  to invent push pages or long polling. Specifically, none but the
  most recent versions of Internet Explorer provide any way to
  access an AJAX response before it is complete. I have taken the
  design decision that it is ok to degrade on these platforms so
  long as the programmer developing with Oboe.js does not have to
  make special cases for these platforms. Likewise, nor should the
  REST service need be aware of the client, disallowing detecting
  client capabilities and switching transport strategy. Requiring
  branching on either side places extra responsibilities on the
  programmer which they would not otherwise be required to consider
  whilst viewing REST through a non-streaming lens.</p>

  <p>Given that streaming is not possible on older platforms, I
  must considering the best experience that is possible. We may
  imagine a situation in which the whole download completes
  followed by all listeners being notified from a single Javascript
  frame of execution. While not progressive in any way, this
  situation is essentially standard REST plus JSONPath routing and
  no less performant than if more traditional libraries were used.
  I find this satisfactory: for the majority of users the
  experience is improved and for the others it is made no worse,
  resulting in a net overall benefit.</p>

  <p>In the Javascript language itself interoperability is very
  rarely an issue. Javascript's model of prototypical inheritance
  allows changes to be made to the browser's libraries on the fly;
  as soon as a prototype is changed all instances of the type
  reflect the change even if they has already been created
  (source). Because the base types that come with the browser are
  essentially global, changing them for the use of a single
  codebase is generally deprecated because of the possibility of
  collisions. However, this technique is often used to retrofit new
  standards onto older platforms. For example, the Functional-style
  Array iteration methods remove the need to write C-style for
  loops and are defined in the ECMAScript 5 specification <a href=
  "http://www.jimmycuadra.com/posts/ecmascript-5-array-methods">http://www.jimmycuadra.com/posts/ecmascript-5-array-methods</a>
  - all of these methods are implementable in pure Javascript.
  There exist several mature pure Javascript projects for browsers
  which lack native support, licenced to allow inclusion in this
  project (CITE ONE). While I am constrained in the ability to
  accept streaming AJAX in older browsers, there is no such
  restriction on my ability to express my thesis in a more modern,
  functional style of Javascript.</p>

  <p>Node is highly capable, with no shortcomings that will make
  Oboe.js difficult to implement. It does, however use its own
  stream API rather than emulate the browser API so will require
  platform-specific programming inside the library. This
  abstraction will be hidden from the library user so will not
  require any special programming on their part.</p>

  <h1 id="implementation"><a href="#implementation"><span class=
  "header-section-number">5</span> Implementation</a></h1>

  <h2 id="components-of-the-project"><a href=
  "#components-of-the-project"><span class=
  "header-section-number">5.1</span> Components of the
  project</a></h2>

  <div class="figure">
    <img src="images/overallDesign.png" alt=
    "Major components that make up Oboe.js illustrating program flow from http transport to registered callbacks. Every component is not shown here. Particularly, components whose responsibility it is to initialise the oboe instance but have no role once it is running are omitted. UML facet/receptacle notation is used to show the flow of events with event names in capitals. ">

    <p class="caption"><strong>Major components that make up
    Oboe.js</strong> illustrating program flow from http transport
    to registered callbacks. Every component is not shown here.
    Particularly, components whose responsibility it is to
    initialise the oboe instance but have no role once it is
    running are omitted. UML facet/receptacle notation is used to
    show the flow of events with event names in capitals.</p>
  </div>

  <p>Oboe's architecture has been designed to so that I may have as
  much confidence as possible regarding the correct working of the
  library through automated testing. Designing a system to be
  amenable to testing in this case meant splitting into many
  co-operating parts each with an easily specified remit.</p>

  <p>Internally, communication between components is facilitated by
  an event bus which is local to to Oboe instance. Most components
  interact solely by picking up events, processing them and
  publishing further events in response. Essentially, Oboe's
  architecture resembles a fairly linear pipeline visiting a series
  of units, starting with http data and sometimes ending with
  callbacks being notified. This use of an event bus is a variation
  on the Observer pattern which removes the need for each unit to
  obtain a reference to the previous one so that it may observe it,
  giving a highly decoupled shape to the library. Once everything
  is wired into the bus very little central control is required and
  the larger behaviours emerge as the consequence of this
  interaction between finer ones. One downside is perhaps that a
  central event bus does not lend itself to a UML class diagram,
  giving a diagram shape with an event bus as a central hub and
  everything else hanging off it as spokes.</p>

  <h2 id="automated-testing"><a href=
  "#automated-testing"><span class=
  "header-section-number">5.2</span> Automated testing</a></h2>

  <p>Automated testing improves what can be written, not just
  making what is written more reliable. Tests deal with the problem
  of "irreducible complexity" - when a program is made out of parts
  whose correct behaviour cannot be observed without all of the
  program. Allows smaller units to be verified before verifying the
  whole.</p>

  <div class="figure">
    <img src="images/testPyramid.png" alt=
    "The test pyramid. Relying on the assumption that verification of small parts provides a solid base from which to compose system-level behaviours. A Lot of testing is done on the low-level components of the system, less on the component level and less still on a whole-system level where only smoke tests are provided. ">

    <p class="caption"><strong>The test pyramid</strong>. Relying
    on the assumption that verification of small parts provides a
    solid base from which to compose system-level behaviours. A Lot
    of testing is done on the low-level components of the system,
    less on the component level and less still on a whole-system
    level where only smoke tests are provided.</p>
  </div>

  <p>The testing itself is a non-trivial undertaking with 80% of
  code written for this project being test specifications. Based on
  the idea that a correct system must be built from individually
  correct units, the majority of the specifications are unit tests,
  putting each unit under the microscope and describing the correct
  behaviour as completely as possible. Component tests zoom out
  from examining individual components to focus on their correct
  composition, falsifying only the http traffic. To avoid testing
  implementation details the component tests do not look at the
  means of coupling between the code units but rather check for the
  behaviours which should emerge as a consequence of their
  composition. At the apex of the test pyramid are a small number
  of integration tests. These verify Oboe as a black box without
  any knowledge of, or access to the internals, using only the APIs
  which are exposed to application programmers. When running the
  integration tests a REST service is first spun up so that
  correctness of the whole library may be examined against an
  actual server.</p>

  <p>The desire to be amenable to testing influences the boundaries
  on which the application splits into components. Confidently
  black box testing a stateful unit as is difficult; because of
  side-effects it may later react differently to the same calls.
  For this reason where state is required it is stored in very
  simple state-storing units with intricate program logic removed.
  The logic may then be separately expressed as functions which map
  from one state to the next. Although comprehensive coverage is of
  course impossible and tests are inevitably incomplete, for
  whatever results the functions give while under test,
  uninfluenced by state I can be sure that they will continue to
  give in any future situation. The separate unit holding the state
  is trivial to test, having exactly one responsibility: to store
  the result of a function call and later pass that result to the
  next function. This approach clearly breaks with object oriented
  style encapsulation by not hiding data behind the logic which
  acts on them but I feel the departure is worthwhile for the
  greater certainty it allows over the correct functioning of the
  program.</p>

  <p>Largely for the sake of testing Oboe has also embraced
  dependency injection. This means that components do not create
  the further components that they require but rather rely on them
  being provided by an external wiring. The file
  <code>wire.js</code> performs the actual injection. One such
  example is the streamingHttp component which hides various
  incompatible http implementations by publishing their downloaded
  content progressively via the event bus. This unit does not know
  how to create the underlying browser XHR which it hides.
  Undoubtedly, by not instantiating its own dependencies a it
  presents a less friendly interface, although this is mitigated
  somewhat by the interface being purely internal, the objects it
  depends on are no longer a hidden implementation detail but
  exposed as a part of the component's API. The advantage of
  dependency injection here is that unit testing is much simpler.
  Unit tests should test exactly one behaviour of one unit. Were
  the streaming http object to create its own transport, that part
  would also be under test, plus whichever external service that it
  connects to. Because Javascript allows redefinition of built in
  types, this could be avoided by overwriting the XHR constructor
  to return a mock but modifying the built in types for tests opens
  up the possibilities of changes leaking between cases. Dependency
  injection allows a much simpler test style because it is trivial
  to inject a stub in place of the XHR.</p>

  <p>Integration tests run against a node service which returns
  known content according to known timings, somewhat emulating
  downloading via a slow internet connection. For example, the url
  <code>/tenSlowNumbers</code> writes out a JSON array of the first
  ten natural numbers at a rate of one per second, while
  <code>/echoBackHeaders</code> writes back the http headers that
  it received as a JSON object. The test specifications which use
  these services interact with Oboe through the public API alone as
  an application author would and try some tricky cases. For
  example, requesting ten numbers but registering a listener
  against the fifth and aborting the request on seeing it. The
  correct behaviour is to get no callback for the sixth, even when
  running on platforms where the http is buffered so that all ten
  will have already been downloaded. <em>ref apx for
  streamsource</em></p>

  <h2 id="running-the-tests"><a href=
  "#running-the-tests"><span class=
  "header-section-number">5.3</span> Running the tests</a></h2>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "Relationship between various files and test libraries other half of sketch from notebook">

    <p class="caption"><strong>Relationship between various files
    and test libraries</strong> <em>other half of sketch from
    notebook</em></p>
  </div>

  <p>The Grunt task runner was used to automate routine tasks such
  as executing the tests and building. Unit and component tests run
  automatically whenever a source file changes. As well as being
  correct execution, the project is required to not surpass a
  certain size so the built size is also checked. As a small,
  tightly focused project the majority of programming is
  refactoring already working code. Running tests on save provides
  quick feedback so that mistakes are found as soon as they are
  made. Agile practitioners emphasise the importance of tests that
  execute quickly <span class="citation">(Martin 2008, T9)</span>,
  the 220 unit and component tests run in less than a second so
  discovering mistakes is near instant. If the "content of any
  medium is always another medium&acirc;&euro; <span class=
  "citation">(McLuhan 1964 p8)</span>, we might say that the
  content of programming is the program that is realised by its
  execution. A person working in arts and crafts sees the thing as
  they work but a programmer will usually not see the execution
  simultaneously as they program. Conway observed that an artisan
  works by transform-in-place "start with the working material in
  place and you step by step transform it into its final form"
  whereas software is created through intermediate proxies, and
  attempts to close this gap by merging programming with the
  results of programming <span class="citation">(Conway 2004
  side8-9)</span>. When we bring together the medium and the
  message the cost of small experimentation is very low and I feel
  that programming becomes more explorative and expressive.</p>

  <p>The integration tests are not run on save because they
  intentionally simulate slow transfers and take some time to run.
  The integration tests are used as a final check against built
  code before a branch in git can be merged into the master. Once
  the code has been packaged for distribution the internals are no
  longer visible the integration tests which are coded against the
  public API are the only runnable tests. While these tests don't
  individually test every component, they are designed to exercise
  the whole codebase so that a mistake in any component will be
  visible through them. Grunt executes the build, including
  starting up the test REST services that give the integration
  tests something to fetch.</p>

  <h2 id="packaging-as-a-single-distributable-file"><a href=
  "#packaging-as-a-single-distributable-file"><span class=
  "header-section-number">5.4</span> Packaging as a single,
  distributable file</a></h2>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "Packaging of many javascript files into multiple single-file packages. The packages are individually targeted at different execution contexts, either browsers or node get from notebook, split sketch diagram in half">

    <p class="caption"><strong>Packaging of many javascript files
    into multiple single-file packages.</strong> The packages are
    individually targeted at different execution contexts, either
    browsers or node <em>get from notebook, split sketch diagram in
    half</em></p>
  </div>

  <p>As an interpreted language, Javascript may of course be ran
  directly without any prior compilation. While running the same
  code as I see in the editor is convenient while programming, it
  is much less so for distribution. Although the languages imposes
  no compulsory build phase, in practice one is necessary.
  Dependency managers have not yet become standard for client-side
  web development (although Bower is looking good) so most files
  are manually downloaded. For a developer wishing to include my
  library in their own project a single file is much more
  convenient. Should they not have a build process of their own, a
  single file is also much faster to transfer to their users,
  mostly because of the cost of establishing connections and the
  http overhead.</p>

  <p>Javascript files are interpreted in series by the browser so
  load-time dependencies must precede dependants. Unsurprisingly,
  separate files once concatenated following the same order as
  delivered to the browser will load more quickly but are
  functionally equivalent, at least barring syntax errors. Several
  tools exist to automate this stage of the build process,
  incorporating a topological sort of the dependency digraph in
  order to find a working concatenation order.</p>

  <p>Early in this project I chose <em>Require.js</em> although I
  later moved on because it was too heavyweight. Javascript as a
  language doesn't have an import statement. Require contributes
  the importing ability to Javascript from inside the language
  sandbox as the <code>require</code> function, a standard
  asynchronous call. Calls to <code>require</code> AJAX in and
  execute the imported source, returning any exported symbols by a
  callback. For non-trivial applications this mode is intended
  mostly for debugging; because a network hop is involved the
  protocol is chatty and slowed by highly latent calls between
  modules. For efficient delivery Require also has the
  <code>optimise</code> command which concatenates into a single
  file by using static analysis to deduce a workable source order.
  Because <code>require</code> may appear anywhere in the source,
  this in the general case is of course undecidable so Require
  falls back to lazy loading. In practice undecidability isn't a
  problem because imports are generally not subject to branching.
  In larger webapps lazy loading speeding up the initial page load
  and is actually an advantage. The technique of <em>Asynchronous
  Module Definition</em> (AMD) intentionally imports rarely-loaded
  modules in response to events. By resisting the static analysis
  the units will not be downloaded until they are needed.</p>

  <p>AMD is mostly of interest to web applications with a central
  hub but also some rarely used parts. Oboe does not fit this
  profile: everybody who uses it will use all of the library.
  Regardless, I hoped to use <code>optimise</code> to generate my
  combined Javascript file. Even after optimisation, Require's
  design necessitates that calls to <code>require</code> stay in
  the code and that the require.js run-time component is available
  to handle these calls. For a micro-library a ???k overhead was
  too large to accommodate. Overall, Require seems more suited to
  developing stand-alone applications than programming
  libraries.</p>

  <p>Having abandoned Require, I decided to pick up the simplest
  tool which could possibly work. With only 15 source files and a
  fairly sparse dependency graph finding a working order on paper
  wasn't a daunting task. Combined with a Grunt analogue to the
  unix <code>cat</code> command I quickly had a working build
  process. I adjusted each Javascript file to, when loaded
  directly, place its API in the global namespace, then
  post-concatenation wrapped the combined in a single function,
  converting the APIs inside the function from global to the scope
  of that function, thereby hiding the implementation for code
  outside of Oboe.</p>

  <p>For future consideration there is Browserify. This library
  reverses the 'browser first' image of Javascript by converting
  applications targeted at Node into a single file efficiently
  packaged for delivery to a web browser, conceptually making Node
  the primary environment for Javascript and adapting browser
  execution to match. Significantly, require leaves no trace of
  itself in the concatenated Javascript other than Adaptors
  presenting browser APIs as the Node equivalents. Browserify's
  http adaptor<sup><a href="#fn5" class="footnoteRef" id="fnref5"
  name="fnref5">5</a></sup> is complete but more verbose compared
  to Oboe's version<sup><a href="#fn6" class="footnoteRef" id=
  "fnref6" name="fnref6">6</a></sup>.</p>

  <p>As well as combining into a single file, Javascript source can
  made significantly smaller by removing comments and reducing
  inaccessible tokens to a single character. For Oboe the popular
  library <em>Uglify</em> is used for minification. Uglify performs
  only surface optimisations, operating on the AST level but
  concentrating mostly on compact syntax. I also considered
  Google's Closure compiler. Closure resembles a traditional
  compiler optimiser by leveraging a deeper understanding to search
  for smaller representations, unfortunately at the cost of safety.
  Decidability in highly dynamic languages is often impossible and
  Closure operates on a well-advised subset of Javascript,
  delivering no reasonable guarantee of equivalence when code is
  not written as the Closure authors expected. Integration tests
  should catch any such failures but for the time being I have a
  limited appetite for a workflow which forces me to be suspicious
  of the project's build process.</p>

  <h2 id="styles-of-programming"><a href=
  "#styles-of-programming"><span class=
  "header-section-number">5.5</span> Styles of Programming</a></h2>

  <p>The implementation of Oboe is mixed paradigm. Events flow
  throughout the whole library but in terms of code style the
  components are a mix of procedural, functional and
  object-oriented programming. Object orientation is used only to
  wrap the library in an Object-oriented public API and as a
  tuple-like store for multiple values. Constructors are not used,
  nor is there any inheritance or notable polymorphism. Closures,
  not objects, are used as the primary means of data storage and
  hiding. Many of the entities painted in figure map onto no
  single, addressable language construct and exist only as a set of
  event handlers trapped inside the same closure, taking advantage
  of the fact that their reachability from some event emitter
  prevents required parameters from being garbage collected. From
  outside the closure hidden values are not only private as would
  be seen in an OO model, they are inherently unaddressable.
  Although only sparingly OO, the high-level design's
  componentisation hasn't departed from how it might be implemented
  in an OO metamodel and Object Oriented design patterns remain
  influential despite being only loosely followed.</p>

  <p>Because of the pressures on code size I decided not to use a
  general purpose functional library and instead create my own with
  only the parts that I need; see functional.js. Functional
  programming in Javascript is known to be slower than other
  styles, particularly under Firefox because it lacks Lambda
  Lifting and other similar optimisations <span class=
  "citation">(Guo 2013)</span>. Considering to what degree
  performance concerns should dissuade us from a functional style,
  we may consider the library's execution context. Because of the
  single-threaded model any application's Javascript execution is
  in between frames serving concurrent concerns so to minimise the
  impact on latency for the other tasks it is important that no
  task occupies the CPU for very long. On the browser about 16ms is
  a fair maximum, allowing painting to occur at 60 frames per
  second. In Node there is no hard limit but any CPU-hogging task
  degrades the responsiveness of other responses. Context switching
  imposes a very low overhead and responsive sharing generally
  proffers many small frames over a few larger ones. In any case,
  server-side tasks especially are more often i/o bound than CPU
  bound. Oboe's progressive design naturally splits tasks which
  would otherwise be performed in a single frame over many. For
  example, parsing and marshaling. Although the overall computation
  may be higher, the total performance of the system should be
  improved.</p>

  <p>Javascript is of course an imperative language but over many
  iterations Oboe has tended towards a declarative style. In
  incrementalContentBuilder.js programming was initially stateful
  and procedural, reading like the instructions to perform a task.
  Over many refactors the flavour of the code has changed, the
  reading now tending towards a description of desired
  behaviour.</p>

  <h2 id="incrementally-building-up-the-content"><a href=
  "#incrementally-building-up-the-content"><span class=
  "header-section-number">5.6</span> Incrementally building up the
  content</a></h2>

  <p>As shown in figure , there is an incremental content builder
  and ascent tracer which handle the output from the Clarinet JSON
  SAX parser. Taken together, these might be considered a variant
  of the Adaptor pattern, providing to the controller a simpler
  interface than is presented by Clarinet. However, this is not the
  model implementation of the pattern; the adapted interface is
  even-driven rather than call-driven: we receive six kinds of
  event and in response emmit from a narrower vocabulary of
  two.</p>

  <p>To evaluate JSONPath expressions the controller requires a
  path to the current JSON node, the node itself, and any ancestor
  nodes. This is delivered by the incremental content builder as
  the payload of the NODE_FOUND and PATH_FOUND events. For each
  Clarinet event the builder provides a corresponding function
  which, working from the current path, returns the next path after
  the event has been applied. For example, the
  <code>objectopen</code> and <code>arrayopen</code> events move
  the current node deeper in the document and are handled by adding
  new items to the path, whereas for <code>closeobject</code> and
  <code>closearray</code> we remove one. Over the course of parsing
  a complete JSON file the path will in this way be manipulated to
  visit every node, allowing each to be tested against the
  registered JSONPath expressions. Internally, the builder's event
  handlers are declared as the combination of a smaller number of
  basic reusable handler parts. Oboe is largely unconcerned
  regarding a JSON node's type so given that several of the
  Clarinet events differ only by the type of the nodes they
  announce, Oboe is able to generify their handling by composing
  from a common pool of handler-parts. Picking up
  <code>openobject</code> and <code>openarray</code> events, both
  fall through to the same 'nodeFound', differing only in a
  parameter. Similarly, consider the <code>value</code> event which
  is fired when Clarinet encounters a String or Number. Because
  primitive nodes are always leaves the builder regards this as a
  node which instantaneously starts and ends, handled
  programmatically as the functional composition of the
  <code>nodeFound</code> and <code>curNodeFinished</code>. The
  reuse of smaller instructions to build up larger ones is perhaps
  slightly reminiscent of CISC CPU design in which
  micro-instructions are combined to implement the chip's
  advertised interface.</p>

  <p>Although the builder functions are stateless, ultimately the
  state regarding the current path needs to be stored between
  clarinet calls. This is handled by the ascent tracker. This tiny
  component merely serves as a holder for this data, starting from
  an empty path it passes the path to each builder function and
  stores the result to be given to the next one.</p>

  <div class="figure">
    <img src="images/ascent.png" alt=
    "List representation of an ascent from leaf to root of a JSON tree. Note the special ROOT token which represents the path mapping to the root node (of course nothing maps to the root) - this is an object, taking advantage of object identity to ensure that the token is unequal to anything but itself. This list form is built up by the incremental content builder and is the format that compiled JSONPath expressions test against for matches ">

    <p class="caption">List representation of an ascent from leaf
    to root of a JSON tree. Note the special ROOT token which
    represents the path mapping to the root node (of course nothing
    maps to the root) - this is an object, taking advantage of
    object identity to ensure that the token is unequal to anything
    but itself. This list form is built up by the incremental
    content builder and is the format that compiled JSONPath
    expressions test against for matches</p>
  </div>

  <p>The path of the current node is maintained as a singly linked
  list, with each list element holding the field name and the node
  and the node itself, see figure . The list is arranged with the
  JSON root at the far end and the current node at the head. As we
  traverse the JSON the current node is appended and removed many
  times whereas the root is immutable. This ordering was chosen
  because it is computationally very efficient since all updates to
  the list are at the head. Each link in the list is immutable,
  enforced by newer Javascript engines as frozen
  objects.<sup><a href="#fn7" class="footnoteRef" id="fnref7" name=
  "fnref7">7</a></sup></p>

  <p>Linked lists were chosen in preference to the more
  conventional approach of using native Javascript Arrays for
  several reasons. Firstly, I find this area of the program more
  easy to test and debug given immutable data structures. Handling
  native Arrays without mutating would be very expensive because on
  each new path the array would have to be copied rather than
  edited in-place. Unpicking a stack trace is easier if I know that
  every value revealed is the value that has always occupied that
  space because I don't have to think four-dimensionally projecting
  my mind forwards and back in time to different values that were
  there when the variable was used. The lack of side effects means
  I can try explore new commands in the debugger's CLI without
  worrying about breaking the execution of the program. Most
  Javascript virtual machines are also quite poor at array growing
  and shrinking so for collections whose size changes often are
  outperformed by linked lists. Finally, this is a very convenient
  format for the JSONPath engine to perform matching on as will be
  discussed in the next section. The Javascript file lists.js
  implements the list functions: <code>cons</code>,
  <code>head</code>, <code>tail</code>, <code>map</code>,
  <code>foldR</code>, <code>all</code>.</p>

  <p>Because it is more common to quote paths as descents rather
  than ascent, on the boundary to the outside world Oboe reverses
  the order and, because Javascript programmers will not be
  familiar with this structure, converts to arrays.</p>

  <h2 id="oboe-jsonpath-implementation"><a href=
  "#oboe-jsonpath-implementation"><span class=
  "header-section-number">5.7</span> Oboe JSONPath
  Implementation</a></h2>

  <p>Not surprisingly given its importance, the JSONPath
  implementation is one of the most refactored and considered parts
  of the Oboe codebase. Like many small languages, on the first
  commit it was little more than a series of regular
  expressions<sup><a href="#fn8" class="footnoteRef" id="fnref8"
  name="fnref8">8</a></sup> but has slowly evolved into a
  featureful and efficient implementation<sup><a href="#fn9" class=
  "footnoteRef" id="fnref9" name="fnref9">9</a></sup>. The extent
  of the rewriting was possible because the correct behaviour is
  well defined by test specifications<sup><a href="#fn10" class=
  "footnoteRef" id="fnref10" name="fnref10">10</a></sup>.</p>

  <p>The JSONPath compiler exposes a single higher-order function
  to the rest of Oboe. This function takes a JSONPath as a String
  and, proving it is a valid expression, returns a function which
  tests for matches to the JSONPath. Both the compiler and the
  functions that it generates benefit from being stateless. The
  type of the compiler, expressed as Haskell syntax would be:</p>
  <pre class="sourceCode haskell">
<code class="sourceCode haskell"><span class=
"dt">String</span> <span class="ot">-&gt;</span> <span class=
"dt">Ascent</span> <span class="ot">-&gt;</span> <span class=
"dt">JsonPathMatchResult</span></code>
</pre>

  <p>The match result is either a failure to match, or a hit, with
  the node that matched. In the case of path matching, the node may
  currently be unknown. If the pattern has a clause prefixed with
  <code>$</code>, the node matching that clause is captured and
  returned as the result. Otherwise, the last clause is implicitly
  capturing.</p>

  <p>The usage profile for JSONPath expressions in Oboe is to be
  compiled once and then evaluated many times, once for each node
  encountered while parsing the JSON. Because matching is performed
  perhaps hundreds of times per file the most pressing performance
  consideration is for matching to execute quickly, the time
  required to compile is relatively unimportant. Oboe's JSONPath
  design contrasts with JSONPath's reference implementation which,
  because it provides a first order function, freshly reinterprets
  the JSONPath string each time it is invoked.</p>

  <p>The compilation is performed by recursively by examining the
  left-most side of the string for a JSONPath clause. For each kind
  of clause there is a function which matches ascents against that
  clause, for example by checking the name field. By partial
  completion this function is specialised to match against one
  particular name. Once a clause function is generated, compilation
  recurs by passing to itself the remaining unparsed portion of the
  JSONPath string. This continues until it is called with a
  zero-length JSONPath. On each recursive call the clause function
  is wrapped in the result from the next recursive call, resulting
  ultimately in a linked series of clause functions. When evaluated
  against an ascent, each clause functions examines the head of the
  ascent and passes the ascent onto the next function if it passes.
  A special clause functions, <code>skip1</code> is used for the
  <code>.</code> syntax and places no condition on the head of the
  ascent but passes on to the next clause only the tail, thus
  moving evaluation of the ascent one node up the parsed JSON tree.
  Similarly, there is a <code>skipMany</code> which maps onto the
  <code>..</code> syntax and recursively consumes nodes until it
  can find a match in the next clause.</p>

  <p>JsonPath implementation allows the compilation of complex
  expressions into an executable form, but each part implementing
  the executable form is locally simple. By using recursion,
  assembling the simple functions into a more function expressing a
  more complex rule also follows as being locally simple but
  gaining a usefully sophisticated behaviour through composition of
  simple parts. Each recursive call of the parser identifies one
  token for non-empty input and then recursively digests the
  rest.</p>

  <p>As an example, the pattern <code>!.$person..{height
  tShirtSize}</code> once compiled would roughly resemble the
  Javascript functional representation below:</p>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"fu">statementExpr</span>(             <span class=
"co">// wrapper, added when JSONPath is zero-length </span>
   <span class="fu">duckTypeClause</span>(         <span class=
"co">// token 6, {height tShirtSize}</span>
      <span class="fu">skipMany</span>(            <span class=
"co">// token 5, '..'  </span>
         <span class="fu">capture</span>(          <span class=
"co">// token 4, css4-style '$' notation</span>
            <span class="fu">nameClause</span>(    <span class=
"co">// token 3, 'person'</span>
               <span class="fu">skip1</span>(      <span class=
"co">// token 2, '.'  </span>
                  rootExpr <span class=
"co">// token 1, '!' at start of JSONPath expression</span>
               ) 
            <span class="st">'person'</span> )
         )
   ), [<span class="st">'height'</span>, <span class=
"st">'tShirtSize'</span>])
)      </code>
</pre>

  <p>Since I am only using a side-effect free subset of Javascript
  for this segment of Oboe it would be safe to use a functional
  cache. As well as saving time by avoiding repeated execution,
  this could potentially also save memory because where two
  JSONPath strings contain a common start they could share the
  inner parts of their functional expression. Although Javascript
  doesn't come with functional caching, it can be added using the
  language itself.<sup><a href="#fn11" class="footnoteRef" id=
  "fnref11" name="fnref11">11</a></sup> I suspect, however, that
  hashing the parameters might be slower than performing the
  matching. Although the parameters are all immutable and could in
  theory be hashed by object identity, in practice there is no way
  to access an object id from inside the language so any hash of a
  node parsed out of JSON would have to walk the entire subtree
  rooted from that node.</p>

  <p>The JSONPath tokenisation is split out into its own file and
  separately tested. The tokenisation implementation is based on
  regular expressions, they are the simplest form able to express
  the clause patterns. The regular expressions are hidden to the
  outside the tokenizer and only functions are exposed to the main
  body of the compiler. The regular expressions all start with
  <code>^</code> so that they only match at the head of the string.
  A more elegant alternative is the 'y'<sup><a href="#fn12" class=
  "footnoteRef" id="fnref12" name="fnref12">12</a></sup> flag but
  as of now this lacks wide browser support.</p>

  <p>By verifying the tokens through their own unit tests it is
  simpler to thoroughly specify the tokenisation, producing simpler
  failure messages than if it were done through the full JSONPath
  engine. We might consider the unit test layer of the pyramid
  (figure ) is further split into two sub-layers. Arguably, the
  upper of these sub-layer is not a unit test because it is
  verifying two units together. There is some redundancy with the
  tokens being tested both individually and as full expressions. I
  maintain that this is the best approach regardless because
  stubbing out the tokenizer functions would be a considerable
  effort and would not improve the rigor of the JSONPath
  specification.</p>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "Some kind of diagram showing jsonPath expressions and functions partially completed to link back to the previous function. Include the statementExpr pointing to the last clause">

    <p class="caption">Some kind of diagram showing jsonPath
    expressions and functions partially completed to link back to
    the previous function. Include the statementExpr pointing to
    the last clause</p>
  </div>

  <h1 id="conclusion"><a href="#conclusion"><span class=
  "header-section-number">6</span> Conclusion</a></h1><!---
**1 to 5 pages**
=-->

  <p>Doing things faster vs doing things earlier. "Hurry up and
  wait" approach to optimisation.</p>

  <h2 id="weaknesses"><a href="#weaknesses"><span class=
  "header-section-number">6.1</span> weaknesses</a></h2>

  <p>implementation keeps 'unreachable' listeners difficult
  decidability/proof type problem to get completely right but could
  cover most of the easy cases</p>

  <p>Parse time for large files spread out over a long time.
  Reaction to parsed content spread out over a long time, for
  example de-marshalling to domain objects. For UX may be
  preferable to have many small delays rather than one large
  one.</p>

  <p>Doesn't support all of jsonpath. Not a strict subset of the
  language.</p>

  <p>Rest client as a library is passing mutable objects to the
  caller. too inefficient to re-create a new map/array every time
  an item is not as efficient in immutability as list head-tail
  type storage</p>

  <p>An immutability wrapper might be possible with defineProperty.
  Can't casually overwrite via assignment but still possible to do
  defineProperty again.</p>

  <p>Would benefit from a stateless language where everything is
  stateless at all times to avoid having to program
  defensively.</p>

  <p>Aborting http request may not stop processing on the server.
  Why this is perhaps desirable - transactions, leaving resources
  in a half-complete state.</p>

  <h2 id="suitability-for-databases-really-just-an-inline-asside">
  <a href=
  "#suitability-for-databases-really-just-an-inline-asside"><span class="header-section-number">
  6.2</span> Suitability for databases (really just an inline
  asside)</a></h2>

  <p>Databases offer data one row at a time, not as a big lump.</p>

  <h2 id="development-methodology"><a href=
  "#development-methodology"><span class=
  "header-section-number">6.3</span> Development
  methodology</a></h2>

  <p>Did it help?</p>

  <p>Switched several times. Could have started with winning side?
  Tension between choosing latest and greatest (promising much) or
  old established solution alraedy experienced with but with known
  problems. Judging if problems will become too much of a
  hinderence and underestimating the flaws. JSTD was yesterday's
  latest and greatest but Karma genuinely is great. In end, right
  solution was found despite not being found in most direct
  way.</p>

  <p>Packaging was a lot of work but has delivered the most concise
  possible library.</p>

  <h2 id="size"><a href="#size"><span class=
  "header-section-number">6.4</span> Size</a></h2>

  <div class="figure">
    <img src="images/placeholder.png" alt=
    "A pie chart showing the sizes of the various parts of the codebase">

    <p class="caption">A pie chart showing the sizes of the various
    parts of the codebase</p>
  </div>

  <p>Comment on the size of the libraray</p>

  <h2 id="handling-invalid-input"><a href=
  "#handling-invalid-input"><span class=
  "header-section-number">6.5</span> Handling invalid
  input</a></h2>

  <p>Invalid jsonpaths made from otherwise valid clauses (for
  example two roots) perhaps could fail early, at compile time.
  Instead, get a jsonPath that couldn't match anything. Invalid
  syntax is picked up.</p>

  <p>Same pattern could be extended to XML. Or any tree-based
  format. Text is easier but no reason why not binary
  applications.</p>

  <p>Not particularly useful reading from local files.</p>

  <p>Does not save memory over DOM parsing since the same DOM tree
  is built. May slightly increase memory usage by utilising memory
  earlier that would otherwise be dept dormant until the whole
  transmission is received but worst case more often a concern than
  mean.</p>

  <p>Implementation in a purely functional language with lazy
  evaluation: could it mean that only the necessary parts are
  computed? Could I have implemented the same in javascript?</p>

  <p>Would be nice to: * discard patterns that can't match any
  further parts of the tree * discard branches of the tree that
  can't match any patterns * just over the parsing of branches of
  the tree that provably can't match any of the patterns</p>

  <h2 id="comparative-usages"><a href=
  "#comparative-usages"><span class=
  "header-section-number">6.6</span> Comparative usages</a></h2>

  <p>Interesting article from Clarinet: <a href=
  "http://writings.nunojob.com/2011/12/clarinet-sax-based-evented-streaming-json-parser-in-javascript-for-the-browser-and-nodejs.html">
  http://writings.nunojob.com/2011/12/clarinet-sax-based-evented-streaming-json-parser-in-javascript-for-the-browser-and-nodejs.html</a></p>

  <p>In terms of syntax: compare to SAX (clarinet) for getting the
  same job done. Draw examples from github project README. Or from
  reimplementing Clarinet's examples.</p>

  <p>Consider:</p>

  <ul>
    <li>Difficulty to program</li>

    <li>Ease of reading the program / clarity of code</li>

    <li>Resources consumed</li>

    <li>Performance (time) taken</li>

    <li>about the same. Can react equally quickly to io in
    progress, both largely io bound.</li>

    <li>Is earlier really faster?</li>
  </ul>

  <h2 id="community-reaction"><a href=
  "#community-reaction"><span class=
  "header-section-number">6.7</span> Community reaction</a></h2>

  <p>Built into Dojo Followers on Github Being posted in forums
  (hopefully also listed on blogs) No homepage as of yet other than
  the Github page</p>

  <h2 id="possible-future-work"><a href=
  "#possible-future-work"><span class=
  "header-section-number">6.8</span> Possible future work</a></h2>

  <p>Do da XMLs</p>

  <h2 id="benchmarking"><a href="#benchmarking"><span class=
  "header-section-number">6.9</span> Benchmarking</a></h2>

  <p>Complex JSONPAth tested against JSON with approx 2,000 nodes,
  finding 100 matches. Real http, full stack Oboe.</p>

  <table>
    <thead>
      <tr class="header">
        <th align="left">Browser</th>

        <th align="right">Time</th>
      </tr>
    </thead>

    <tbody>
      <tr class="odd">
        <td align="left">Firefox 24.0.0 (Mac OS X 10.7)</td>

        <td align="right">547ms</td>
      </tr>

      <tr class="even">
        <td align="left">Chrome 30.0.1599 (Mac OS X 10.7.5)</td>

        <td align="right">237ms</td>
      </tr>

      <tr class="odd">
        <td align="left">Chrome Mobile iOS 30.0.1599 (iOS
        7.0.2)</td>

        <td align="right">431ms</td>
      </tr>

      <tr class="even">
        <td align="left">Safari 6.0.5 (Mac OS X 10.7.5)</td>

        <td align="right">231ms</td>
      </tr>

      <tr class="odd">
        <td align="left">IE 8.0.0 (Windows XP)</td>

        <td align="right">3048ms</td>
      </tr>
    </tbody>
  </table>

  <h1 id="appendix"><a href="#appendix"><span class=
  "header-section-number">7</span> Appendix</a></h1>

  <h2 id="browserapi.js"><a href="#browserapi.js"><span class=
  "header-section-number">7.1</span> browserApi.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"co">// export public API</span>
<span class="ot">window</span>.<span class=
"fu">oboe</span>          = <span class=
"fu">apiMethod</span>(<span class="st">'GET'</span>);
<span class="ot">window</span>.<span class=
"ot">oboe</span>.<span class="fu">doGet</span>    = <span class=
"ot">window</span>.<span class="fu">oboe</span>;
<span class="ot">window</span>.<span class=
"ot">oboe</span>.<span class="fu">doDelete</span> = <span class=
"fu">apiMethod</span>(<span class="st">'DELETE'</span>);
<span class="ot">window</span>.<span class=
"ot">oboe</span>.<span class="fu">doPost</span>   = <span class=
"fu">apiMethod</span>(<span class="st">'POST'</span>, <span class=
"kw">true</span>);
<span class="ot">window</span>.<span class=
"ot">oboe</span>.<span class="fu">doPut</span>    = <span class=
"fu">apiMethod</span>(<span class="st">'PUT'</span>, <span class=
"kw">true</span>);

<span class="kw">function</span> <span class=
"fu">apiMethod</span>(httpMethodName, mayHaveRequestBody) {
               
   <span class="kw">return</span> <span class=
"kw">function</span>(firstArg){
           
      <span class="kw">if</span> (<span class=
"fu">isString</span>(firstArg)) {
      
         <span class=
"co">// parameters specified as arguments</span>
         <span class="co">//</span>
         <span class=
"co">//  if (mayHaveContext == true) method signature is:</span>
         <span class="co">//     .doMethod( url, content )</span>
         <span class="co">//</span>
         <span class="co">//  else it is:</span>
         <span class=
"co">//     .doMethod( url )            </span>
         <span class="co">//                                </span>
         <span class="kw">return</span> <span class=
"fu">wire</span>(
                  httpMethodName,
                  firstArg,                                  <span class="co">// url</span>
                  mayHaveRequestBody &amp;&amp; arguments[<span class="dv">1</span>]         <span class="co">// body</span>
         );
      } <span class="kw">else</span> {
      
         <span class="co">// method signature is:</span>
         <span class=
"co">//    .doMethod({url:u, body:b, complete:c, headers:{...}})</span>
         
         <span class="kw">return</span> <span class=
"fu">wire</span>(   
                  httpMethodName,
                  <span class="ot">firstArg</span>.<span class=
"fu">url</span>,
                  <span class="ot">firstArg</span>.<span class=
"fu">body</span>,
                  <span class="ot">firstArg</span>.<span class=
"fu">headers</span> 
         );
      }
   };
}   </code>
</pre>

  <h2 id="clarinetlisteneradaptor.js"><a href=
  "#clarinetlisteneradaptor.js"><span class=
  "header-section-number">7.2</span>
  clarinetListenerAdaptor.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript">
<span class="co">/** </span>
<span class=
"co"> * A bridge used to assign stateless functions to listen to clarinet.</span>
<span class="co"> * </span>
<span class=
"co"> * As well as the parameter from clarinet, each callback will also be passed</span>
<span class="co"> * the result of the last callback.</span>
<span class="co"> * </span>
<span class=
"co"> * This may also be used to clear all listeners by assigning zero handlers:</span>
<span class="co"> * </span>
<span class=
"co"> *    clarinetListenerAdaptor( clarinet, {} )</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">clarinetListenerAdaptor</span>(clarinetParser, handlers){
    
   <span class="kw">var</span> state;

   <span class="ot">clarinet</span>.<span class=
"ot">EVENTS</span>.<span class="fu">forEach</span>(<span class=
"kw">function</span>(eventName){
 
      <span class=
"kw">var</span> handlerFunction = handlers[eventName];
      
      clarinetParser[<span class=
"st">'on'</span>+eventName] = handlerFunction &amp;&amp; 
                                       <span class=
"kw">function</span>(param) {
                                          state = <span class=
"fu">handlerFunction</span>( state, param);
                                       };
   });
}</code>
</pre>

  <h2 id="events.js"><a href="#events.js"><span class=
  "header-section-number">7.3</span> events.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * This file declares some constants to use as names for event types.</span>
<span class="co"> */</span>

<span class="kw">var</span> <span class=
"co">// NODE_FOUND, PATH_FOUND and ERROR_EVENT feature </span>
    <span class=
"co">// in the public API via .on('node', ...) or .on('path', ...)</span>
    <span class="co">// so these events are strings</span>
    NODE_FOUND    = <span class="st">'node'</span>,  
    PATH_FOUND    = <span class="st">'path'</span>,   
         
    <span class=
"co">// these events are never exported so are kept as </span>
    <span class=
"co">// the smallest possible representation, numbers:</span>
    _S = <span class="dv">0</span>,
    ERROR_EVENT   = _S++,    
    ROOT_FOUND    = _S++,    
    NEW_CONTENT = _S++,
    END_OF_CONTENT = _S++,
    ABORTING = _S++;</code>
</pre>

  <h2 id="functional.js"><a href="#functional.js"><span class=
  "header-section-number">7.4</span> functional.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * This file declares various pieces of functional programming.</span>
<span class="co"> * </span>
<span class=
"co"> * This isn't a general purpose functional library, to keep things small it</span>
<span class="co"> * has just the parts useful for Oboe.js.</span>
<span class="co"> */</span>


<span class="co">/**</span>
<span class=
"co"> * Call a single function with the given arguments array.</span>
<span class=
"co"> * Basically, a functional-style version of the OO-style Function#apply for </span>
<span class=
"co"> * when we don't care about the context ('this') of the call.</span>
<span class="co"> * </span>
<span class=
"co"> * The order of arguments allows partial completion of the arguments array</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">apply</span>(args, fn) {
   <span class="kw">return</span> <span class=
"ot">fn</span>.<span class="fu">apply</span>(<span class=
"kw">undefined</span>, args);
}

<span class="co">/**</span>
<span class=
"co"> * Define variable argument functions but cut out all that tedious messing about </span>
<span class=
"co"> * with the arguments object. Delivers the variable-length part of the arguments</span>
<span class="co"> * list as an array.</span>
<span class="co"> * </span>
<span class="co"> * Eg:</span>
<span class="co"> * </span>
<span class="co"> * var myFunction = varArgs(</span>
<span class=
"co"> *    function( fixedArgument, otherFixedArgument, variableNumberOfArguments ){</span>
<span class=
"co"> *       console.log( variableNumberOfArguments );</span>
<span class="co"> *    }</span>
<span class="co"> * )</span>
<span class="co"> * </span>
<span class=
"co"> * myFunction('a', 'b', 1, 2, 3); // logs [1,2,3]</span>
<span class="co"> * </span>
<span class=
"co"> * var myOtherFunction = varArgs(function( variableNumberOfArguments ){</span>
<span class=
"co"> *    console.log( variableNumberOfArguments );</span>
<span class="co"> * })</span>
<span class="co"> * </span>
<span class="co"> * myFunction(1, 2, 3); // logs [1,2,3]</span>
<span class="co"> * </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">varArgs</span>(fn){

   <span class=
"kw">var</span> numberOfFixedArguments = <span class="ot">fn</span>.<span class="fu">length</span> -<span class="dv">1</span>;
         
   <span class="kw">return</span> <span class=
"kw">function</span>(){
   
      <span class=
"kw">var</span> numberOfVaraibleArguments = <span class=
"ot">arguments</span>.<span class=
"fu">length</span> - numberOfFixedArguments,
      
          argumentsToFunction = <span class=
"ot">Array</span>.<span class="ot">prototype</span>.<span class=
"ot">slice</span>.<span class="fu">call</span>(arguments);
          
      <span class=
"co">// remove the last n element from the array and append it onto the end of</span>
      <span class="co">// itself as a sub-array</span>
      <span class="ot">argumentsToFunction</span>.<span class=
"fu">push</span>( 
         <span class="ot">argumentsToFunction</span>.<span class=
"fu">splice</span>(numberOfFixedArguments, numberOfVaraibleArguments)
      );   
      
      <span class="kw">return</span> <span class=
"ot">fn</span>.<span class="fu">apply</span>( <span class=
"kw">this</span>, argumentsToFunction );
   }       
}

<span class="co">/** </span>
<span class="co"> * Partially complete a function.</span>
<span class="co"> * </span>
<span class="co"> * Eg: </span>
<span class=
"co"> *    var add3 = partialComplete( function add(a,b){return a+b}, [3] );</span>
<span class="co"> *    </span>
<span class="co"> *    add3(4) // gives 7</span>
<span class="co"> */</span>
<span class="kw">var</span> partialComplete = <span class=
"fu">varArgs</span>(<span class=
"kw">function</span>( fn, boundArgs ) {

      <span class="kw">return</span> <span class=
"fu">varArgs</span>(<span class="kw">function</span>( callArgs ) {
               
         <span class="kw">return</span> <span class=
"ot">fn</span>.<span class="fu">apply</span>(<span class=
"kw">this</span>, <span class="ot">boundArgs</span>.<span class=
"fu">concat</span>(callArgs));
      }); 
   }),

<span class="co">/**</span>
<span class="co"> * Compose zero or more functions:</span>
<span class="co"> * </span>
<span class=
"co"> *    compose(f1, f2, f3)(x) = f1(f2(f3(x))))</span>
<span class="co"> * </span>
<span class=
"co"> * The last (inner-most) function may take more than one parameter:</span>
<span class="co"> * </span>
<span class=
"co"> *    compose(f1, f2, f3)(x,y) = f1(f2(f3(x,y))))</span>
<span class="co"> */</span>
   compose = <span class="fu">varArgs</span>(<span class=
"kw">function</span>(fns) {

      <span class="kw">var</span> fnsList = <span class=
"fu">arrayAsList</span>(fns);
   
      <span class="kw">function</span> <span class=
"fu">next</span>(params, curFn) {  
         <span class="kw">return</span> [<span class=
"fu">apply</span>(params, curFn)];   
      }
      
      <span class="kw">return</span> <span class=
"fu">varArgs</span>(<span class="kw">function</span>(startParams){
        
         <span class="kw">return</span> <span class=
"fu">foldR</span>(next, startParams, fnsList)[<span class=
"dv">0</span>];
      });
   });

<span class="co">/**</span>
<span class=
"co"> * Swap the order of parameters to a binary function</span>
<span class="co"> * </span>
<span class=
"co"> * A bit like this flip: http://zvon.org/other/haskell/Outputprelude/flip_f.html</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">flip</span>(fn){
   <span class="kw">return</span> <span class=
"kw">function</span>(a, b){
      <span class="kw">return</span> <span class=
"fu">fn</span>(b,a);
   }
}

<span class="co">/**</span>
<span class=
"co"> * Call a list of functions with the same args until one returns a </span>
<span class=
"co"> * truthy result. Similar to the || operator.</span>
<span class="co"> * </span>
<span class="co"> * So:</span>
<span class=
"co"> *      lazyUnion([f1,f2,f3 ... fn])( p1, p2 ... pn )</span>
<span class="co"> *      </span>
<span class="co"> * Is equivalent to: </span>
<span class="co"> *      apply([p1, p2 ... pn], f1) || </span>
<span class="co"> *      apply([p1, p2 ... pn], f2) || </span>
<span class=
"co"> *      apply([p1, p2 ... pn], f3) ... apply(fn, [p1, p2 ... pn])  </span>
<span class="co"> *  </span>
<span class="co"> * </span><span class=
"kw">@returns</span><span class=
"co"> the first return value that is given that is truthy.</span>
<span class="co"> */</span>
<span class="kw">var</span> lazyUnion = <span class=
"fu">varArgs</span>(<span class="kw">function</span>(fns) {

   <span class="kw">return</span> <span class=
"fu">varArgs</span>(<span class="kw">function</span>(params){

      <span class="kw">var</span> maybeValue;

      <span class="kw">for</span> (<span class=
"kw">var</span> i = <span class="dv">0</span>; i &lt; <span class=
"fu">len</span>(fns); i++) {

         maybeValue = <span class=
"fu">apply</span>(params, fns[i]);

         <span class="kw">if</span>( maybeValue ) {
            <span class="kw">return</span> maybeValue;
         }
      }
   });
});

<span class="co">/**</span>
<span class=
"co"> * Create a function which is the intersection of two other functions.</span>
<span class="co"> * </span>
<span class=
"co"> * Like the &amp;&amp; operator, if the first is truthy, the second is never called,</span>
<span class=
"co"> * otherwise the return value from the second is returned.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">lazyIntersection</span>(fn1, fn2) {

   <span class="kw">return</span> <span class=
"kw">function</span> (param) {
                                                              
      <span class="kw">return</span> <span class=
"fu">fn1</span>(param) &amp;&amp; <span class=
"fu">fn2</span>(param);
   };   
}
</code>
</pre>

  <h2 id="incrementalcontentbuilder.js"><a href=
  "#incrementalcontentbuilder.js"><span class=
  "header-section-number">7.5</span>
  incrementalContentBuilder.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/** </span>
<span class=
"co"> * This file provides various listeners which can be used to build up</span>
<span class=
"co"> * a changing ascent based on the callbacks provided by Clarinet. It listens</span>
<span class=
"co"> * to the low-level events from Clarinet and fires higher-level ones.</span>
<span class="co"> *  </span>
<span class=
"co"> * The building up is stateless so to track a JSON file</span>
<span class=
"co"> * clarinetListenerAdaptor.js is required to store the ascent state</span>
<span class="co"> * between calls.</span>
<span class="co"> */</span>


<span class="kw">var</span> keyOf = <span class=
"fu">attr</span>(<span class="st">'key'</span>);
<span class="kw">var</span> nodeOf = <span class=
"fu">attr</span>(<span class="st">'node'</span>);


<span class="co">/** </span>
<span class=
"co"> * A special value to use in the path list to represent the path 'to' a root </span>
<span class=
"co"> * object (which doesn't really have any path). This prevents the need for </span>
<span class=
"co"> * special-casing detection of the root object and allows it to be treated </span>
<span class=
"co"> * like any other object. We might think of this as being similar to the </span>
<span class=
"co"> * 'unnamed root' domain ".", eg if I go to </span>
<span class=
"co"> * http://en.wikipedia.org./wiki/En/Main_page the dot after 'org' deliminates </span>
<span class="co"> * the unnamed root of the DNS.</span>
<span class="co"> * </span>
<span class=
"co"> * This is kept as an object to take advantage that in Javascript's OO objects </span>
<span class=
"co"> * are guaranteed to be distinct, therefore no other object can possibly clash </span>
<span class=
"co"> * with this one. Strings, numbers etc provide no such guarantee. </span>
<span class="co"> **/</span>
<span class="kw">var</span> ROOT_PATH = {};


<span class="co">/**</span>
<span class=
"co"> * Create a new set of handlers for clarinet's events, bound to the fire </span>
<span class="co"> * function given.  </span>
<span class="co"> */</span> 
<span class="kw">function</span> <span class=
"fu">incrementalContentBuilder</span>( fire) {


   <span class="kw">function</span> <span class=
"fu">arrayIndicesAreKeys</span>( possiblyInconsistentAscent, newDeepestNode) {
   
      <span class=
"co">/* for values in arrays we aren't pre-warned of the coming paths </span>
<span class=
"co">         (Clarinet gives no call to onkey like it does for values in objects) </span>
<span class=
"co">         so if we are in an array we need to create this path ourselves. The </span>
<span class=
"co">         key will be len(parentNode) because array keys are always sequential </span>
<span class="co">         numbers. */</span>

      <span class="kw">var</span> parentNode = <span class=
"fu">nodeOf</span>( <span class=
"fu">head</span>( possiblyInconsistentAscent));
      
      <span class="kw">return</span>      <span class=
"fu">isOfType</span>( Array, parentNode)
               ?
                  <span class=
"fu">pathFound</span>(  possiblyInconsistentAscent, 
                              <span class=
"fu">len</span>(parentNode), 
                              newDeepestNode
                  )
               :  
                  <span class=
"co">// nothing needed, return unchanged</span>
                  possiblyInconsistentAscent 
               ;
   }
                 
   <span class="kw">function</span> <span class=
"fu">nodeFound</span>( ascent, newDeepestNode ) {
      
      <span class="kw">if</span>( !ascent ) {
         <span class="co">// we discovered the root node,</span>
         <span class="fu">fire</span>( ROOT_FOUND, newDeepestNode);
                    
         <span class="kw">return</span> <span class=
"fu">pathFound</span>( ascent, ROOT_PATH, newDeepestNode);         
      }

      <span class="co">// we discovered a non-root node</span>
                 
      <span class=
"kw">var</span> arrayConsistentAscent  = <span class=
"fu">arrayIndicesAreKeys</span>( ascent, newDeepestNode),      
          ancestorBranches       = <span class=
"fu">tail</span>( arrayConsistentAscent),
          previouslyUnmappedName = <span class=
"fu">keyOf</span>( <span class=
"fu">head</span>( arrayConsistentAscent));
          
      <span class="fu">appendBuiltContent</span>( 
         ancestorBranches, 
         previouslyUnmappedName, 
         newDeepestNode 
      );
                                                                                                         
      <span class="kw">return</span> <span class="fu">cons</span>( 
               <span class=
"fu">namedNode</span>( previouslyUnmappedName, newDeepestNode ), 
               ancestorBranches
      );                                                                          
   }


   <span class="co">/**</span>
<span class=
"co">    * Add a new value to the object we are building up to represent the</span>
<span class="co">    * parsed JSON</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">appendBuiltContent</span>( ancestorBranches, key, node ){
     
      <span class="fu">nodeOf</span>( <span class=
"fu">head</span>( ancestorBranches))[key] = node;
   }

   <span class="co">/**</span>
<span class="co">    * Get a new key-&gt;node mapping</span>
<span class="co">    * </span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String|Number}</span><span class="co"> key</span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Object|Array|String|Number|null}</span><span class=
"co"> node a value found in the json</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">namedNode</span>(key, node) {
      <span class="kw">return</span> {<span class=
"dt">key</span>:key, <span class="dt">node</span>:node};
   }
     
   <span class="co">/**</span>
<span class=
"co">    * For when we find a new key in the json.</span>
<span class="co">    * </span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String|Number|Object}</span><span class=
"co"> newDeepestName the key. If we are in an </span>
<span class=
"co">    *    array will be a number, otherwise a string. May take the special </span>
<span class=
"co">    *    value ROOT_PATH if the root node has just been found</span>
<span class="co">    *    </span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String|Number|Object|Array|Null|undefined}</span><span class=
"co"> [maybeNewDeepestNode] </span>
<span class=
"co">    *    usually this won't be known so can be undefined. Can't use null </span>
<span class=
"co">    *    to represent unknown because null is a valid value in JSON</span>
<span class="co">    **/</span>  
   <span class="kw">function</span> <span class=
"fu">pathFound</span>(ascent, newDeepestName, maybeNewDeepestNode) {

      <span class="kw">if</span>( ascent ) { <span class=
"co">// if not root</span>
      
         <span class=
"co">// If we have the key but (unless adding to an array) no known value</span>
         <span class=
"co">// yet. Put that key in the output but against no defined value:      </span>
         <span class=
"fu">appendBuiltContent</span>( ascent, newDeepestName, maybeNewDeepestNode );
      }
   
      <span class="kw">var</span> ascentWithNewPath = <span class=
"fu">cons</span>( 
                                 <span class=
"fu">namedNode</span>( newDeepestName, 
                                            maybeNewDeepestNode), 
                                 ascent
                              );
     
      <span class="fu">fire</span>( PATH_FOUND, ascentWithNewPath);
 
      <span class="kw">return</span> ascentWithNewPath;
   }


   <span class="co">/**</span>
<span class="co">    * For when the current node ends</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">curNodeFinished</span>( ascent ) {

      <span class="fu">fire</span>( NODE_FOUND, ascent);
                          
      <span class=
"co">// pop the complete node and its path off the list:                                    </span>
      <span class="kw">return</span> <span class=
"fu">tail</span>( ascent);
   }      
                 
   <span class="kw">return</span> { 

      <span class="dt">openobject </span>: <span class=
"kw">function</span> (ascent, firstKey) {

         <span class=
"kw">var</span> ascentAfterNodeFound = <span class=
"fu">nodeFound</span>(ascent, {});         

         <span class=
"co">/* It is a perculiarity of Clarinet that for non-empty objects it</span>
<span class=
"co">            gives the first key with the openobject event instead of</span>
<span class="co">            in a subsequent key event.</span>
<span class="co">                      </span>
<span class=
"co">            firstKey could be the empty string in a JSON object like </span>
<span class=
"co">            {'':'foo'} which is technically valid.</span>
<span class="co">            </span>
<span class=
"co">            So can't check with !firstKey, have to see if has any </span>
<span class="co">            defined value. */</span>
         <span class="kw">return</span> <span class=
"fu">defined</span>(firstKey)
         ?          
            <span class=
"co">/* We know the first key of the newly parsed object. Notify that </span>
<span class=
"co">               path has been found but don't put firstKey permanently onto </span>
<span class=
"co">               pathList yet because we haven't identified what is at that key </span>
<span class=
"co">               yet. Give null as the value because we haven't seen that far </span>
<span class="co">               into the json yet */</span>
            <span class=
"fu">pathFound</span>(ascentAfterNodeFound, firstKey)
         :
            ascentAfterNodeFound
         ;
      },
    
      <span class="dt">openarray</span>: <span class=
"kw">function</span> (ascent) {
         <span class="kw">return</span> <span class=
"fu">nodeFound</span>(ascent, []);
      },

      <span class=
"co">// called by Clarinet when keys are found in objects               </span>
      <span class="dt">key</span>: pathFound,
      
      <span class=
"co">/* Emitted by Clarinet when primitive values are found, ie Strings,</span>
<span class="co">         Numbers, and null.</span>
<span class=
"co">         Because these are always leaves in the JSON, we find and finish the </span>
<span class=
"co">         node in one step, expressed as functional composition: */</span>
      <span class="dt">value</span>: <span class=
"fu">compose</span>( curNodeFinished, nodeFound ),
      
      <span class=
"co">// we make no distinction in how we handle object and arrays closing.</span>
      <span class=
"co">// For both, interpret as the end of the current node.</span>
      <span class="dt">closeobject</span>: curNodeFinished,
      <span class="dt">closearray</span>: curNodeFinished       
   };
}</code>
</pre>

  <h2 id="instancecontroller.js"><a href=
  "#instancecontroller.js"><span class=
  "header-section-number">7.6</span> instanceController.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * This file implements a light-touch central controller for an instance </span>
<span class=
"co"> * of Oboe which provides the methods used for interacting with the instance </span>
<span class="co"> * from the calling app.</span>
<span class="co"> */</span>
 
 
<span class="kw">function</span> <span class=
"fu">instanceController</span>(fire, on, clarinetParser, contentBuilderHandlers) {
  
   <span class="kw">var</span> oboeApi, rootNode;

   <span class=
"co">// when the root node is found grap a reference to it for later      </span>
   <span class="fu">on</span>(ROOT_FOUND, <span class=
"kw">function</span>(root) {
      rootNode = root;   
   });
                              
   <span class="fu">on</span>(NEW_CONTENT,         
      <span class="kw">function</span> (nextDrip) {
         <span class=
"co">// callback for when a bit more data arrives from the streaming XHR         </span>
          
         <span class="kw">try</span> {
            
            <span class="ot">clarinetParser</span>.<span class=
"fu">write</span>(nextDrip);            
         } <span class="kw">catch</span>(e) { 
            <span class=
"co">/* we don't have to do anything here because we always assign</span>
<span class=
"co">               a .onerror to clarinet which will have already been called </span>
<span class=
"co">               by the time this exception is thrown. */</span>                
         }
      }
   );
   
   <span class=
"co">/* At the end of the http content close the clarinet parser.</span>
<span class=
"co">      This will provide an error if the total content provided was not </span>
<span class=
"co">      valid json, ie if not all arrays, objects and Strings closed properly */</span>
   <span class="fu">on</span>(END_OF_CONTENT, <span class=
"ot">clarinetParser</span>.<span class=
"ot">close</span>.<span class="fu">bind</span>(clarinetParser));
   

   <span class=
"co">/* If we abort this Oboe's request stop listening to the clarinet parser. </span>
<span class=
"co">      This prevents more tokens being found after we abort in the case where </span>
<span class=
"co">      we aborted during processing of an already filled buffer. */</span>
   <span class="fu">on</span>( ABORTING, <span class=
"kw">function</span>() {
      <span class=
"fu">clarinetListenerAdaptor</span>(clarinetParser, {});
   });   

   <span class=
"fu">clarinetListenerAdaptor</span>(clarinetParser, contentBuilderHandlers);
  
   <span class=
"co">// react to errors by putting them on the event bus</span>
   <span class="ot">clarinetParser</span>.<span class=
"fu">onerror</span> = <span class=
"kw">function</span>(e) {          
      <span class="fu">fire</span>(ERROR_EVENT, e);
      
      <span class=
"co">// note: don't close clarinet here because if it was not expecting</span>
      <span class=
"co">// end of the json it will throw an error</span>
   };

   <span class="kw">function</span> <span class=
"fu">addPathOrNodeCallback</span>( eventId, pattern, callback ) {
   
      <span class="kw">var</span> matchesJsonPath = <span class=
"fu">jsonPathCompiler</span>( pattern );
   
      <span class=
"co">// Add a new callback adaptor to the eventBus.</span>
      <span class=
"co">// This listener first checks that he pattern matches then if it does, </span>
      <span class="co">// passes it onto the callback. </span>
      <span class="fu">on</span>( eventId, <span class=
"kw">function</span>( ascent ){ 
 
         <span class=
"kw">var</span> maybeMatchingMapping = <span class=
"fu">matchesJsonPath</span>( ascent );
     
         <span class=
"co">/* Possible values for maybeMatchingMapping are now:</span>

<span class="co">            false: </span>
<span class="co">               we did not match </span>
<span class="co">  </span>
<span class=
"co">            an object/array/string/number/null: </span>
<span class=
"co">               we matched and have the node that matched.</span>
<span class=
"co">               Because nulls are valid json values this can be null.</span>
<span class="co">  </span>
<span class="co">            undefined: </span>
<span class=
"co">               we matched but don't have the matching node yet.</span>
<span class=
"co">               ie, we know there is an upcoming node that matches but we </span>
<span class=
"co">               can't say anything else about it. </span>
<span class="co">         */</span>
         <span class=
"kw">if</span>( maybeMatchingMapping !== <span class=
"kw">false</span> ) {                                 

            <span class=
"fu">notifyCallback</span>(callback, maybeMatchingMapping, ascent);                           
         }
      });   
   }   
   
   <span class="kw">function</span> <span class=
"fu">notifyCallback</span>(callback, matchingMapping, ascent) {
      <span class="co">/* </span>
<span class=
"co">         We're now calling back to outside of oboe where the Lisp-style </span>
<span class=
"co">         lists that we are using internally will not be recognised </span>
<span class="co">         so convert to standard arrays. </span>
<span class="co">  </span>
<span class=
"co">         Also, reverse the order because it is more common to list paths </span>
<span class=
"co">         "root to leaf" than "leaf to root" </span>
<span class="co">      */</span>
            
      <span class="kw">var</span> descent     = <span class=
"fu">reverseList</span>(ascent),
      
          <span class=
"co">// To make a path, strip off the last item which is the special</span>
          <span class=
"co">// ROOT_PATH token for the 'path' to the root node</span>
          path       = <span class=
"fu">listAsArray</span>(<span class="fu">tail</span>(<span class=
"fu">map</span>(keyOf,descent))),
          ancestors  = <span class=
"fu">listAsArray</span>(<span class=
"fu">map</span>(nodeOf, descent)); 
      
      <span class="kw">try</span>{
      
         <span class="fu">callback</span>( <span class=
"fu">nodeOf</span>(matchingMapping), path, ancestors );   
      }<span class="kw">catch</span>(e)  {
      
         <span class=
"co">// An error occured during the callback, publish it on the event bus </span>
         <span class="fu">fire</span>(ERROR_EVENT, e);
      }          
   }

   <span class="co">/**</span>
<span class=
"co">    * Add several listeners at a time, from a map</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">addListenersMap</span>(eventId, listenerMap) {
   
      <span class="kw">for</span>( <span class=
"kw">var</span> pattern <span class="kw">in</span> listenerMap ) {
         <span class=
"fu">addPathOrNodeCallback</span>(eventId, pattern, listenerMap[pattern]);
      }
   }    
      
   <span class="co">/**</span>
<span class=
"co">    * implementation behind .onPath() and .onNode()</span>
<span class="co">    */</span>       
   <span class="kw">function</span> <span class=
"fu">addNodeOrPathListenerApi</span>( eventId, jsonPathOrListenerMap,
                                      callback, callbackContext ){
 
      <span class="kw">if</span>( <span class=
"fu">isString</span>(jsonPathOrListenerMap) ) {
         <span class="fu">addPathOrNodeCallback</span>( 
            eventId, 
            jsonPathOrListenerMap, 
            <span class="ot">callback</span>.<span class=
"fu">bind</span>(callbackContext||oboeApi)
         );
      } <span class="kw">else</span> {
         <span class=
"fu">addListenersMap</span>(eventId, jsonPathOrListenerMap);
      }
      
      <span class="kw">return</span> <span class=
"kw">this</span>; <span class="co">// chaining</span>
   }

   <span class="co">/**</span>
<span class=
"co">    * Construct and return the public API of the Oboe instance to be </span>
<span class="co">    * returned to the calling application</span>
<span class="co">    */</span>
   <span class="kw">return</span> oboeApi = { 
      <span class="dt">path  </span>:  <span class=
"fu">partialComplete</span>(addNodeOrPathListenerApi, PATH_FOUND), 
      <span class="dt">node  </span>:  <span class=
"fu">partialComplete</span>(addNodeOrPathListenerApi, NODE_FOUND),
      <span class="dt">on    </span>:  addNodeOrPathListenerApi,
      <span class="dt">fail  </span>:  <span class=
"fu">partialComplete</span>(on, ERROR_EVENT),
      <span class="dt">done  </span>:  <span class=
"fu">partialComplete</span>(addNodeOrPathListenerApi, NODE_FOUND, <span class="st">'!'</span>),
      <span class="dt">abort </span>:  <span class=
"fu">partialComplete</span>(fire, ABORTING),
      <span class="dt">root  </span>:  <span class=
"kw">function</span> <span class="fu">rootNodeFunctor</span>() {
                  <span class="kw">return</span> rootNode;
               }
   };
}</code>
</pre>

  <h2 id="jsonpath.js"><a href="#jsonpath.js"><span class=
  "header-section-number">7.7</span> jsonPath.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * The jsonPath evaluator compiler used for Oboe.js. </span>
<span class="co"> * </span>
<span class=
"co"> * One function is exposed. This function takes a String JSONPath spec and </span>
<span class=
"co"> * returns a function to test candidate ascents for matches.</span>
<span class="co"> * </span>
<span class=
"co"> *  String jsonPath -&gt; (List ascent) -&gt; Boolean|Object</span>
<span class="co"> *</span>
<span class=
"co"> * This file is coded in a pure functional style. That is, no function has </span>
<span class=
"co"> * side effects, every function evaluates to the same value for the same </span>
<span class=
"co"> * arguments and no variables are reassigned.</span>
<span class="co"> */</span>  
<span class=
"co">// the call to jsonPathSyntax injects the token syntaxes that are needed </span>
<span class="co">// inside the compiler</span>
<span class="kw">var</span> jsonPathCompiler = <span class=
"fu">jsonPathSyntax</span>(<span class=
"kw">function</span> (pathNodeSyntax, 
                                                doubleDotSyntax, 
                                                dotSyntax,
                                                bangSyntax,
                                                emptySyntax ) {

   <span class="kw">var</span> CAPTURING_INDEX = <span class=
"dv">1</span>;
   <span class="kw">var</span> NAME_INDEX = <span class=
"dv">2</span>;
   <span class="kw">var</span> FIELD_LIST_INDEX = <span class=
"dv">3</span>;

   <span class="kw">var</span> headKey = <span class=
"fu">compose</span>(keyOf, head);
                   
   <span class="co">/**</span>
<span class=
"co">    * Create an evaluator function for a named path node, expressed in the</span>
<span class="co">    * JSONPath like:</span>
<span class="co">    *    foo</span>
<span class="co">    *    ["bar"]</span>
<span class="co">    *    [2]   </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">nameClause</span>(previousExpr, detection ) {
     
      <span class="kw">var</span> name = detection[NAME_INDEX],
            
          matchesName = ( !name || name == <span class=
"st">'*'</span> ) 
                           ?  always
                           :  <span class=
"kw">function</span>(ascent){<span class=
"kw">return</span> <span class=
"fu">headKey</span>(ascent) == name};
     

      <span class="kw">return</span> <span class=
"fu">lazyIntersection</span>(matchesName, previousExpr);
   }

   <span class="co">/**</span>
<span class=
"co">    * Create an evaluator function for a a duck-typed node, expressed like:</span>
<span class="co">    * </span>
<span class="co">    *    {spin, taste, colour}</span>
<span class="co">    *    .particle{spin, taste, colour}</span>
<span class="co">    *    *{spin, taste, colour}</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">duckTypeClause</span>(previousExpr, detection) {

      <span class=
"kw">var</span> fieldListStr = detection[FIELD_LIST_INDEX];

      <span class="kw">if</span> (!fieldListStr) 
         <span class="kw">return</span> previousExpr; <span class=
"co">// don't wrap at all, return given expr as-is      </span>

      <span class=
"kw">var</span> hasAllrequiredFields = <span class=
"fu">partialComplete</span>(
                                    hasAllProperties, 
                                    <span class=
"fu">arrayAsList</span>(<span class=
"ot">fieldListStr</span>.<span class="fu">split</span>(<span class=
"ot">/</span><span class="bn">\W</span><span class=
"fl">+</span><span class="ot">/</span>))
                                 ),
                                 
          isMatch =  <span class="fu">compose</span>( 
                        hasAllrequiredFields, 
                        nodeOf, 
                        head
                     );

      <span class="kw">return</span> <span class=
"fu">lazyIntersection</span>(isMatch, previousExpr);
   }

   <span class="co">/**</span>
<span class=
"co">    * Expression for $, returns the evaluator function</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">capture</span>( previousExpr, detection ) {

      <span class=
"co">// extract meaning from the detection      </span>
      <span class=
"kw">var</span> capturing = !!detection[CAPTURING_INDEX];

      <span class="kw">if</span> (!capturing)          
         <span class="kw">return</span> previousExpr; <span class=
"co">// don't wrap at all, return given expr as-is      </span>
      
      <span class="kw">return</span> <span class=
"fu">lazyIntersection</span>(previousExpr, head);
            
   }            
      
   <span class="co">/**</span>
<span class=
"co">    * Create an evaluator function that moves onto the next item on the </span>
<span class=
"co">    * lists. This function is the place where the logic to move up a </span>
<span class="co">    * level in the ascent exists. </span>
<span class="co">    * </span>
<span class=
"co">    * Eg, for JSONPath ".foo" we need skip1(nameClause(always, [,'foo']))</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">skip1</span>(previousExpr) {
   
   
      <span class="kw">if</span>( previousExpr == always ) {
         <span class=
"co">/* If there is no previous expression this consume command </span>
<span class=
"co">            is at the start of the jsonPath.</span>
<span class=
"co">            Since JSONPath specifies what we'd like to find but not </span>
<span class=
"co">            necessarily everything leading down to it, when running</span>
<span class=
"co">            out of JSONPath to check against we default to true */</span>
         <span class="kw">return</span> always;
      }

      <span class=
"co">/** return true if the ascent we have contains only the JSON root,</span>
<span class="co">       *  false otherwise</span>
<span class="co">       */</span>
      <span class="kw">function</span> <span class=
"fu">notAtRoot</span>(ascent){
         <span class="kw">return</span> <span class=
"fu">headKey</span>(ascent) != ROOT_PATH;
      }
      
      <span class="kw">return</span> <span class=
"fu">lazyIntersection</span>(
               <span class=
"co">/* If we're already at the root but there are more </span>
<span class=
"co">                  expressions to satisfy, can't consume any more. No match.</span>

<span class=
"co">                  This check is why none of the other exprs have to be able </span>
<span class=
"co">                  to handle empty lists; skip1 is the only evaluator that </span>
<span class=
"co">                  moves onto the next token and it refuses to do so once it </span>
<span class=
"co">                  reaches the last item in the list. */</span>
               notAtRoot,
               
               <span class=
"co">/* We are not at the root of the ascent yet.</span>
<span class=
"co">                  Move to the next level of the ascent by handing only </span>
<span class=
"co">                  the tail to the previous expression */</span> 
               <span class="fu">compose</span>(previousExpr, tail) 
      );
                                                                                                               
   }   
   
   <span class="co">/**</span>
<span class=
"co">    * Create an evaluator function for the .. (double dot) token. Consumes</span>
<span class=
"co">    * zero or more levels of the ascent, the fewest that are required to find</span>
<span class="co">    * a match when given to previousExpr.</span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class=
"fu">skipMany</span>(previousExpr) {

      <span class="kw">if</span>( previousExpr == always ) {
         <span class=
"co">/* If there is no previous expression this consume command </span>
<span class=
"co">            is at the start of the jsonPath.</span>
<span class=
"co">            Since JSONPath specifies what we'd like to find but not </span>
<span class=
"co">            necessarily everything leading down to it, when running</span>
<span class=
"co">            out of JSONPath to check against we default to true */</span>            
         <span class="kw">return</span> always;
      }
          
      <span class="kw">var</span> 
          <span class=
"co">// In JSONPath .. is equivalent to !.. so if .. reaches the root</span>
          <span class=
"co">// the match has succeeded. Ie, we might write ..foo or !..foo</span>
          <span class=
"co">// and both should match identically.</span>
          terminalCaseWhenArrivingAtRoot = <span class=
"fu">rootExpr</span>(),
          terminalCaseWhenPreviousExpressionIsSatisfied = previousExpr, 
          recursiveCase = <span class=
"fu">skip1</span>(skipManyInner),
          
          cases = <span class="fu">lazyUnion</span>(
                     terminalCaseWhenArrivingAtRoot
                  ,  terminalCaseWhenPreviousExpressionIsSatisfied
                  ,  recursiveCase
                  );                        
            
      <span class="kw">function</span> <span class=
"fu">skipManyInner</span>(ascent) {
      
         <span class="kw">if</span>( !ascent ) {
            <span class=
"co">// have gone past the start, not a match:         </span>
            <span class="kw">return</span> <span class=
"kw">false</span>;
         }      
                                                        
         <span class="kw">return</span> <span class=
"fu">cases</span>(ascent);
      }
      
      <span class="kw">return</span> skipManyInner;
   }      
   
   <span class="co">/**</span>
<span class=
"co">    * Generate an evaluator for ! - matches only the root element of the json</span>
<span class=
"co">    * and ignores any previous expressions since nothing may precede !. </span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class=
"fu">rootExpr</span>() {
      
      <span class="kw">return</span> <span class=
"kw">function</span>(ascent){
         <span class="kw">return</span> <span class=
"fu">headKey</span>(ascent) == ROOT_PATH;
      };
   }   
         
   <span class="co">/**</span>
<span class=
"co">    * Generate a statement wrapper to sit around the outermost </span>
<span class="co">    * clause evaluator.</span>
<span class="co">    * </span>
<span class=
"co">    * Handles the case where the capturing is implicit because the JSONPath</span>
<span class=
"co">    * did not contain a '$' by returning the last node.</span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class=
"fu">statementExpr</span>(lastClause) {
      
      <span class="kw">return</span> <span class=
"kw">function</span>(ascent) {
   
         <span class=
"co">// kick off the evaluation by passing through to the last clause</span>
         <span class="kw">var</span> exprMatch = <span class=
"fu">lastClause</span>(ascent);
                                                     
         <span class="kw">return</span> exprMatch === <span class=
"kw">true</span> ? <span class=
"fu">head</span>(ascent) : exprMatch;
      };
   }      
                          
   <span class="co">/**</span>
<span class=
"co">    * For when a token has been found in the JSONPath input.</span>
<span class=
"co">    * Compiles the parser for that token and returns in combination with the</span>
<span class="co">    * parser already generated.</span>
<span class="co">    * </span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Function}</span><span class=
"co"> exprs  a list of the clause evaluator generators for</span>
<span class=
"co">    *                          the token that was found</span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Function}</span><span class=
"co"> parserGeneratedSoFar the parser already found</span>
<span class="co">    * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Array}</span><span class=
"co"> detection the match given by the regex engine when </span>
<span class=
"co">    *                          the feature was found</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">expressionsReader</span>( exprs, parserGeneratedSoFar, detection ) {
                     
      <span class=
"co">// if exprs is zero-length foldR will pass back the </span>
      <span class=
"co">// parserGeneratedSoFar as-is so we don't need to treat </span>
      <span class="co">// this as a special case</span>
      
      <span class="kw">return</span>   <span class=
"fu">foldR</span>( 
                  <span class=
"kw">function</span>( parserGeneratedSoFar, expr ){
         
                     <span class="kw">return</span> <span class=
"fu">expr</span>(parserGeneratedSoFar, detection);
                  }, 
                  parserGeneratedSoFar, 
                  exprs
               );                     

   }

   <span class="co">/** </span>
<span class=
"co">    *  If jsonPath matches the given detector function, creates a function which</span>
<span class=
"co">    *  evaluates against every clause in the clauseEvaluatorGenerators. The</span>
<span class=
"co">    *  created function is propagated to the onSuccess function, along with</span>
<span class=
"co">    *  the remaining unparsed JSONPath substring.</span>
<span class="co">    *  </span>
<span class=
"co">    *  The intended use is to create a clauseMatcher by filling in</span>
<span class=
"co">    *  the first two arguments, thus providing a function that knows</span>
<span class=
"co">    *  some syntax to match and what kind of generator to create if it</span>
<span class=
"co">    *  finds it. The parameter list once completed is:</span>
<span class="co">    *  </span>
<span class=
"co">    *    (jsonPath, parserGeneratedSoFar, onSuccess)</span>
<span class="co">    *  </span>
<span class=
"co">    *  onSuccess may be compileJsonPathToFunction, to recursively continue </span>
<span class=
"co">    *  parsing after finding a match or returnFoundParser to stop here.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">generateClauseReaderIfTokenFound</span> (
     
                        tokenDetector, clauseEvaluatorGenerators,
                         
                        jsonPath, parserGeneratedSoFar, onSuccess) {
                        
      <span class="kw">var</span> detected = <span class=
"fu">tokenDetector</span>(jsonPath);

      <span class="kw">if</span>(detected) {
         <span class="kw">var</span> compiledParser = <span class=
"fu">expressionsReader</span>(
                                 clauseEvaluatorGenerators, 
                                 parserGeneratedSoFar, 
                                 detected
                              ),
         
             remainingUnparsedJsonPath = <span class=
"ot">jsonPath</span>.<span class="fu">substr</span>(<span class=
"fu">len</span>(detected[<span class=
"dv">0</span>]));                
                               
         <span class="kw">return</span> <span class=
"fu">onSuccess</span>(remainingUnparsedJsonPath, compiledParser);
      }         
   }
                 
   <span class="co">/**</span>
<span class=
"co">    * Partially completes generateClauseReaderIfTokenFound above. </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">clauseMatcher</span>(tokenDetector, exprs) {
        
      <span class="kw">return</span>   <span class=
"fu">partialComplete</span>( 
                  generateClauseReaderIfTokenFound, 
                  tokenDetector, 
                  exprs 
               );
   }

   <span class="co">/**</span>
<span class=
"co">    * clauseForJsonPath is a function which attempts to match against </span>
<span class=
"co">    * several clause matchers in order until one matches. If non match the</span>
<span class=
"co">    * jsonPath expression is invalid and an error is thrown.</span>
<span class="co">    * </span>
<span class=
"co">    * The parameter list is the same as a single clauseMatcher:</span>
<span class="co">    * </span>
<span class=
"co">    *    (jsonPath, parserGeneratedSoFar, onSuccess)</span>
<span class="co">    */</span>     
   <span class="kw">var</span> clauseForJsonPath = <span class=
"fu">lazyUnion</span>(

      <span class=
"fu">clauseMatcher</span>(pathNodeSyntax   , <span class=
"fu">list</span>( capture, 
                                             duckTypeClause, 
                                             nameClause, 
                                             skip1 ))
                                                     
   ,  <span class=
"fu">clauseMatcher</span>(doubleDotSyntax  , <span class=
"fu">list</span>( skipMany))
       
       <span class=
"co">// dot is a separator only (like whitespace in other languages) but </span>
       <span class=
"co">// rather than make it a special case, use an empty list of </span>
       <span class=
"co">// expressions when this token is found</span>
   ,  <span class=
"fu">clauseMatcher</span>(dotSyntax        , <span class=
"fu">list</span>() )  
                                                                                      
   ,  <span class=
"fu">clauseMatcher</span>(bangSyntax       , <span class=
"fu">list</span>( capture,
                                             rootExpr))
                                                          
   ,  <span class=
"fu">clauseMatcher</span>(emptySyntax      , <span class=
"fu">list</span>( statementExpr))
   
   ,  <span class="kw">function</span> (jsonPath) {
         <span class="kw">throw</span> <span class=
"fu">Error</span>(<span class=
"st">'"'</span> + jsonPath + <span class=
"st">'" could not be tokenised'</span>)      
      }
   );


   <span class="co">/**</span>
<span class=
"co">    * One of two possible values for the onSuccess argument of </span>
<span class="co">    * generateClauseReaderIfTokenFound.</span>
<span class="co">    * </span>
<span class=
"co">    * When this function is used, generateClauseReaderIfTokenFound simply </span>
<span class=
"co">    * returns the compiledParser that it made, regardless of if there is </span>
<span class=
"co">    * any remaining jsonPath to be compiled.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">returnFoundParser</span>(_remainingJsonPath, compiledParser){ 
      <span class="kw">return</span> compiledParser 
   }     
              
   <span class="co">/**</span>
<span class=
"co">    * Recursively compile a JSONPath expression.</span>
<span class="co">    * </span>
<span class=
"co">    * This function serves as one of two possible values for the onSuccess </span>
<span class=
"co">    * argument of generateClauseReaderIfTokenFound, meaning continue to</span>
<span class=
"co">    * recursively compile. Otherwise, returnFoundParser is given and</span>
<span class="co">    * compilation terminates.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">compileJsonPathToFunction</span>( uncompiledJsonPath, 
                                       parserGeneratedSoFar ) {

      <span class="co">/**</span>
<span class=
"co">       * On finding a match, if there is remaining text to be compiled</span>
<span class=
"co">       * we want to either continue parsing using a recursive call to </span>
<span class=
"co">       * compileJsonPathToFunction. Otherwise, we want to stop and return </span>
<span class=
"co">       * the parser that we have found so far.</span>
<span class="co">       */</span>
      <span class="kw">var</span> onFind =      uncompiledJsonPath
                     ?  compileJsonPathToFunction 
                     :  returnFoundParser;
                   
      <span class="kw">return</span>   <span class=
"fu">clauseForJsonPath</span>( 
                  uncompiledJsonPath, 
                  parserGeneratedSoFar, 
                  onFind
               );                              
   }

   <span class="co">/**</span>
<span class=
"co">    * This is the function that we expose to the rest of the library.</span>
<span class="co">    */</span>
   <span class="kw">return</span> <span class=
"kw">function</span>(jsonPath){
        
      <span class="kw">try</span> {
         <span class=
"co">// Kick off the recursive parsing of the jsonPath </span>
         <span class="kw">return</span> <span class=
"fu">compileJsonPathToFunction</span>(jsonPath, always);
         
      } <span class="kw">catch</span>( e ) {
         <span class="kw">throw</span> <span class=
"fu">Error</span>( <span class=
"st">'Could not compile "'</span> + jsonPath + 
                      <span class=
"st">'" because '</span> + <span class="ot">e</span>.<span class=
"fu">message</span>
         );
      }
   }

});</code>
</pre>

  <h2 id="jsonpathsyntax.js"><a href=
  "#jsonpathsyntax.js"><span class=
  "header-section-number">7.8</span> jsonPathSyntax.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class=
"kw">var</span> jsonPathSyntax = (<span class=
"kw">function</span>() {
 
   <span class="kw">var</span>
   
   <span class="co">/** </span>
<span class=
"co">    * Export a regular expression as a simple function by exposing just </span>
<span class=
"co">    * the Regex#exec. This allows regex tests to be used under the same </span>
<span class=
"co">    * interface as differently implemented tests, or for a user of the</span>
<span class=
"co">    * tests to not concern themselves with their implementation as regular</span>
<span class="co">    * expressions.</span>
<span class="co">    * </span>
<span class=
"co">    * This could also be expressed point-free as:</span>
<span class=
"co">    *   Function.prototype.bind.bind(RegExp.prototype.exec),</span>
<span class="co">    *   </span>
<span class=
"co">    * But that's far too confusing! (and not even smaller once minified </span>
<span class="co">    * and gzipped)</span>
<span class="co">    */</span>
       regexDescriptor = <span class=
"kw">function</span> <span class=
"fu">regexDescriptor</span>(regex) {
            <span class="kw">return</span> <span class=
"ot">regex</span>.<span class="ot">exec</span>.<span class=
"fu">bind</span>(regex);
       }
       
   <span class="co">/**</span>
<span class=
"co">    * Join several regular expressions and express as a function.</span>
<span class=
"co">    * This allows the token patterns to reuse component regular expressions</span>
<span class=
"co">    * instead of being expressed in full using huge and confusing regular</span>
<span class="co">    * expressions.</span>
<span class="co">    */</span>       
   ,   jsonPathClause = <span class=
"fu">varArgs</span>(<span class="kw">function</span>( componentRegexes ) {

            <span class=
"co">// The regular expressions all start with ^ because we </span>
            <span class=
"co">// only want to find matches at the start of the </span>
            <span class=
"co">// JSONPath fragment we are inspecting           </span>
            <span class="ot">componentRegexes</span>.<span class=
"fu">unshift</span>(<span class="ot">/</span><span class=
"fl">^</span><span class="ot">/</span>);
            
            <span class="kw">return</span>   <span class=
"fu">regexDescriptor</span>(
                        <span class="fu">RegExp</span>(
                           <span class=
"ot">componentRegexes</span>.<span class=
"fu">map</span>(<span class="fu">attr</span>(<span class=
"st">'source'</span>)).<span class="fu">join</span>(<span class=
"st">''</span>)
                        )
                     );
       })
       
   ,   possiblyCapturing =           <span class=
"ot">/</span><span class="fl">(\$?)</span><span class="ot">/</span>
   ,   namedNode =                   <span class=
"ot">/</span><span class="fl">(</span><span class=
"bn">[</span><span class="fl">\w</span><span class=
"bn">-_]</span><span class="fl">+|\*)</span><span class=
"ot">/</span>
   ,   namePlaceholder =             <span class=
"ot">/</span><span class="fl">()</span><span class="ot">/</span>
   ,   nodeInArrayNotation =         <span class=
"ot">/</span><span class="fl">\[</span><span class=
"ot">"</span><span class="fl">(</span><span class=
"bn">[</span><span class="fl">^</span><span class=
"bn">"]</span><span class="fl">+)</span><span class=
"ot">"</span><span class="fl">\]</span><span class="ot">/</span>
   ,   numberedNodeInArrayNotation = <span class=
"ot">/</span><span class="fl">\[(</span><span class=
"bn">\d</span><span class="fl">+|\*)\]</span><span class=
"ot">/</span>
   ,   fieldList =                      <span class=
"ot">/{</span><span class="fl">(</span><span class=
"bn">[</span><span class="fl">\w</span><span class=
"bn"> ]</span><span class="fl">*?)</span><span class="ot">}/</span>
   ,   optionalFieldList =           <span class=
"ot">/</span><span class="fl">(?</span><span class=
"ot">:{</span><span class="fl">(</span><span class=
"bn">[</span><span class="fl">\w</span><span class=
"bn"> ]</span><span class="fl">*?)</span><span class=
"ot">}</span><span class="fl">)?</span><span class="ot">/</span>
    

       <span class="co">//   foo or *                  </span>
   ,   jsonPathNamedNodeInObjectNotation   = <span class=
"fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                namedNode, 
                                                optionalFieldList
                                             )
                                             
       <span class="co">//   ["foo"]   </span>
   ,   jsonPathNamedNodeInArrayNotation    = <span class=
"fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                nodeInArrayNotation, 
                                                optionalFieldList
                                             )  

       <span class="co">//   [2] or [*]       </span>
   ,   jsonPathNumberedNodeInArrayNotation = <span class=
"fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                numberedNodeInArrayNotation, 
                                                optionalFieldList
                                             )

       <span class="co">//   {a b c}      </span>
   ,   jsonPathPureDuckTyping              = <span class=
"fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                namePlaceholder, 
                                                fieldList
                                             )
   
       <span class="co">//   ..</span>
   ,   jsonPathDoubleDot                   = <span class=
"fu">jsonPathClause</span>(<span class="ot">/</span><span class=
"fl">\.\.</span><span class="ot">/</span>)                  
   
       <span class="co">//   .</span>
   ,   jsonPathDot                         = <span class=
"fu">jsonPathClause</span>(<span class="ot">/</span><span class=
"fl">\.</span><span class="ot">/</span>)                    
   
       <span class="co">//   !</span>
   ,   jsonPathBang                        = <span class=
"fu">jsonPathClause</span>(
                                                possiblyCapturing, 
                                                <span class=
"ot">/!/</span>
                                             )  
   
       <span class="co">//   nada!</span>
   ,   emptyString                         = <span class=
"fu">jsonPathClause</span>(<span class="ot">/</span><span class=
"fl">$</span><span class="ot">/</span>)                     
   
   ;
   
  
   <span class=
"co">/* We export only a single function. When called, this function injects </span>
<span class=
"co">      into another function the descriptors from above.             </span>
<span class="co">    */</span>
   <span class="kw">return</span> <span class=
"kw">function</span> (fn){      
      <span class="kw">return</span> <span class=
"fu">fn</span>(      
         <span class="fu">lazyUnion</span>(
            jsonPathNamedNodeInObjectNotation
         ,  jsonPathNamedNodeInArrayNotation
         ,  jsonPathNumberedNodeInArrayNotation
         ,  jsonPathPureDuckTyping 
         )
      ,  jsonPathDoubleDot
      ,  jsonPathDot
      ,  jsonPathBang
      ,  emptyString 
      );
   }; 

}());</code>
</pre>

  <h2 id="lists.js"><a href="#lists.js"><span class=
  "header-section-number">7.9</span> lists.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * Like cons in Lisp</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">cons</span>(x, xs) {
   
   <span class=
"co">/* Internally lists are linked 2-element Javascript arrays.</span>
<span class="co">    </span>
<span class=
"co">      So that lists are all immutable we Object.freeze in newer </span>
<span class="co">      Javascript runtimes.</span>
<span class="co">      </span>
<span class=
"co">      In older engines freeze should have been polyfilled as the </span>
<span class="co">      identity function. */</span>
   <span class="kw">return</span> <span class=
"ot">Object</span>.<span class="fu">freeze</span>([x,xs]);
}

<span class="co">/**</span>
<span class="co"> * The empty list</span>
<span class="co"> */</span>
<span class="kw">var</span> emptyList = <span class=
"kw">null</span>,

<span class="co">/**</span>
<span class="co"> * Get the head of a list.</span>
<span class="co"> * </span>
<span class="co"> * Ie, head(cons(a,b)) = a</span>
<span class="co"> */</span>
    head = <span class="fu">attr</span>(<span class="dv">0</span>),

<span class="co">/**</span>
<span class="co"> * Get the tail of a list.</span>
<span class="co"> * </span>
<span class="co"> * Ie, head(cons(a,b)) = a</span>
<span class="co"> */</span>
    tail = <span class="fu">attr</span>(<span class="dv">1</span>);


<span class="co">/** </span>
<span class="co"> * Converts an array to a list </span>
<span class="co"> * </span>
<span class="co"> *    asList([a,b,c])</span>
<span class="co"> * </span>
<span class="co"> * is equivalent to:</span>
<span class="co"> *    </span>
<span class="co"> *    cons(a, cons(b, cons(c, emptyList))) </span>
<span class="co"> **/</span>
<span class="kw">function</span> <span class=
"fu">arrayAsList</span>(inputArray){

   <span class="kw">return</span> <span class=
"fu">reverseList</span>( 
      <span class="ot">inputArray</span>.<span class=
"fu">reduce</span>(
         <span class="fu">flip</span>(cons),
         emptyList 
      )
   );
}

<span class="co">/**</span>
<span class=
"co"> * A varargs version of arrayAsList. Works a bit like list</span>
<span class="co"> * in LISP.</span>
<span class="co"> * </span>
<span class="co"> *    list(a,b,c) </span>
<span class="co"> *    </span>
<span class="co"> * is equivalent to:</span>
<span class="co"> * </span>
<span class="co"> *    cons(a, cons(b, cons(c, emptyList)))</span>
<span class="co"> */</span>
<span class="kw">var</span> list = <span class=
"fu">varArgs</span>(arrayAsList);

<span class="co">/**</span>
<span class="co"> * Convert a list back to a js native array</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">listAsArray</span>(list){

   <span class="kw">return</span> <span class=
"fu">foldR</span>( <span class=
"kw">function</span>(arraySoFar, listItem){
      
      <span class="ot">arraySoFar</span>.<span class=
"fu">unshift</span>(listItem);
      <span class="kw">return</span> arraySoFar;
           
   }, [], list );
   
}

<span class="co">/**</span>
<span class="co"> * Map a function over a list </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">map</span>(fn, list) {

   <span class="kw">return</span> list
            ? <span class="fu">cons</span>(<span class=
"fu">fn</span>(<span class="fu">head</span>(list)), <span class=
"fu">map</span>(fn,<span class="fu">tail</span>(list)))
            : emptyList
            ;
}

<span class="co">/**</span>
<span class=
"co"> * foldR implementation. Reduce a list down to a single value.</span>
<span class="co"> * </span>
<span class="co"> * </span>@pram<span class=
"co"> {Function} fn     (rightEval, curVal) -&gt; result </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">foldR</span>(fn, startValue, list) {
      
   <span class="kw">return</span> list 
            ? <span class="fu">fn</span>(<span class=
"fu">foldR</span>(fn, startValue, <span class=
"fu">tail</span>(list)), <span class="fu">head</span>(list))
            : startValue
            ;
}

<span class="co">/** </span>
<span class=
"co"> * Returns true if the given function holds for every item in </span>
<span class="co"> * the list, false otherwise </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">all</span>(fn, list) {
   
   <span class="kw">return</span> !list || 
          <span class="fu">fn</span>(<span class=
"fu">head</span>(list)) &amp;&amp; <span class=
"fu">all</span>(fn, <span class="fu">tail</span>(list));
}

<span class="co">/**</span>
<span class="co"> * Apply a function to every item in a list</span>
<span class="co"> * </span>
<span class=
"co"> * This doesn't make any sense if we're doing pure functional because </span>
<span class=
"co"> * it doesn't return anything. Hence, this is only really useful if fn </span>
<span class="co"> * has side-effects. </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">each</span>(fn, list) {

   <span class="kw">if</span>( list ){  
      <span class="fu">fn</span>(<span class=
"fu">head</span>(list));
      <span class="fu">all</span>(fn, <span class=
"fu">tail</span>(list));
   }
}

<span class="co">/**</span>
<span class="co"> * Reverse the order of a list</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">reverseList</span>(list){ 

   <span class=
"co">// js re-implementation of 3rd solution from:</span>
   <span class=
"co">//    http://www.haskell.org/haskellwiki/99_questions/Solutions/5</span>
   <span class="kw">function</span> <span class=
"fu">reverseInner</span>( list, reversedAlready ) {
      <span class="kw">if</span>( !list ) {
         <span class="kw">return</span> reversedAlready;
      }
      
      <span class="kw">return</span> <span class=
"fu">reverseInner</span>(<span class=
"fu">tail</span>(list), <span class="fu">cons</span>(<span class=
"fu">head</span>(list), reversedAlready))
   }

   <span class="kw">return</span> <span class=
"fu">reverseInner</span>(list, emptyList);
}</code>
</pre>

  <h2 id="pubsub.js"><a href="#pubsub.js"><span class=
  "header-section-number">7.10</span> pubSub.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * Isn't this the cutest little pub-sub you've ever seen?</span>
<span class="co"> * </span>
<span class=
"co"> * Does not allow unsubscription because is never needed inside Oboe.</span>
<span class=
"co"> * Instead, when an Oboe instance is finished the whole of it should be</span>
<span class="co"> * available for GC'ing.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">pubSub</span>(){

   <span class="kw">var</span> listeners = {};
                             
   <span class="kw">return</span> {

      <span class="dt">on</span>:<span class=
"kw">function</span>( eventId, fn ) {
         
         listeners[eventId] = <span class=
"fu">cons</span>(fn, listeners[eventId]);

         <span class="kw">return</span> <span class=
"kw">this</span>; <span class="co">// chaining</span>
      }, 
    
      <span class="dt">fire</span>:<span class=
"kw">function</span> ( eventId, event ) {
               
         <span class="fu">each</span>(
            <span class=
"fu">partialComplete</span>( apply, [event || <span class=
"kw">undefined</span>] ), 
            listeners[eventId]
         );
      }           
   };
}</code>
</pre>

  <h2 id="streaminghttp.js"><a href=
  "#streaminghttp.js"><span class="header-section-number">7.11</span>
  streamingHttp.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * An wrapper around the browser XmlHttpRequest object that raises an </span>
<span class=
"co"> * event whenever a new part of the response is available.</span>
<span class="co"> * </span>
<span class=
"co"> * In older browsers progressive reading is impossible so all the </span>
<span class=
"co"> * content is given in a single call. For newer ones several events</span>
<span class=
"co"> * should be raised, allowing progressive interpretation of the response.</span>
<span class="co"> *      </span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Function}</span><span class=
"co"> fire a function to pass events to when something happens</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Function}</span><span class=
"co"> on a function to use to subscribe to events</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{XMLHttpRequest}</span><span class=
"co"> xhr the xhr to use as the transport</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String}</span><span class=
"co"> method one of 'GET' 'POST' 'PUT' 'DELETE'</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String}</span><span class="co"> url</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{String|Object}</span><span class=
"co"> data some content to be sent with the request.</span>
<span class=
"co"> *                        Only valid if method is POST or PUT.</span>
<span class="co"> * </span><span class=
"kw">@param</span><span class="co"> </span><span class=
"kw">{Object}</span><span class=
"co"> [headers] the http request headers to send                       </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">streamingHttp</span>(fire, on, xhr, method, url, data, headers) {
        
   <span class=
"kw">var</span> numberOfCharsAlreadyGivenToCallback = <span class=
"dv">0</span>;

   <span class=
"co">// When an ABORTING message is put on the event bus abort </span>
   <span class="co">// the ajax request         </span>
   <span class="fu">on</span>( ABORTING, <span class=
"kw">function</span>(){
  
      <span class=
"co">// if we keep the onreadystatechange while aborting the XHR gives </span>
      <span class=
"co">// a callback like a successful call so first remove this listener</span>
      <span class="co">// by assigning null:</span>
      <span class="ot">xhr</span>.<span class=
"fu">onreadystatechange</span> = <span class="kw">null</span>;
            
      <span class="ot">xhr</span>.<span class="fu">abort</span>();
   });

   <span class=
"co">/** Given a value from the user to send as the request body, return in</span>
<span class=
"co">    *  a form that is suitable to sending over the wire. Returns either a </span>
<span class="co">    *  string, or null.        </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">validatedRequestBody</span>( body ) {
      <span class="kw">if</span>( !body )
         <span class="kw">return</span> <span class=
"kw">null</span>;
   
      <span class="kw">return</span> <span class=
"fu">isString</span>(body)? body: <span class=
"ot">JSON</span>.<span class="fu">stringify</span>(body);
   }      

   <span class="co">/** </span>
<span class=
"co">    * Handle input from the underlying xhr: either a state change,</span>
<span class=
"co">    * the progress event or the request being complete.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class=
"fu">handleProgress</span>() {
                        
      <span class="kw">var</span> textSoFar = <span class=
"ot">xhr</span>.<span class="fu">responseText</span>,
          newText = <span class="ot">textSoFar</span>.<span class=
"fu">substr</span>(numberOfCharsAlreadyGivenToCallback);
      
      
      <span class="co">/* Raise the event for new text.</span>
<span class="co">      </span>
<span class=
"co">         On older browsers, the new text is the whole response. </span>
<span class=
"co">         On newer/better ones, the fragment part that we got since </span>
<span class="co">         last progress. */</span>
         
      <span class="kw">if</span>( newText ) {
         <span class="fu">fire</span>( NEW_CONTENT, newText );
      } 

      numberOfCharsAlreadyGivenToCallback = <span class=
"fu">len</span>(textSoFar);
   }
   
   
   <span class="kw">if</span>(<span class=
"st">'onprogress'</span> <span class=
"kw">in</span> xhr){  <span class=
"co">// detect browser support for progressive delivery</span>
      <span class="ot">xhr</span>.<span class=
"fu">onprogress</span> = handleProgress;
   }
   
   <span class="ot">xhr</span>.<span class=
"fu">onreadystatechange</span> = <span class=
"kw">function</span>() {
            
      <span class="kw">if</span>(<span class=
"ot">xhr</span>.<span class="fu">readyState</span> == <span class=
"dv">4</span> ) {

         <span class="co">// is this a 2xx http code?</span>
         <span class="kw">var</span> sucessful = <span class=
"fu">String</span>(<span class="ot">xhr</span>.<span class=
"fu">status</span>)[<span class="dv">0</span>] == <span class=
"dv">2</span>;
         
         <span class="kw">if</span>( sucessful ) {
            <span class=
"co">// In Chrome 29 (not 28) no onprogress is fired when a response</span>
            <span class=
"co">// is complete before the onload. We need to always do handleInput</span>
            <span class=
"co">// in case we get the load but have not had a final progress event.</span>
            <span class=
"co">// This looks like a bug and may change in future but let's take</span>
            <span class=
"co">// the safest approach and assume we might not have received a </span>
            <span class=
"co">// progress event for each part of the response</span>
            <span class="fu">handleProgress</span>();
            
            <span class="fu">fire</span>( END_OF_CONTENT );
         } <span class="kw">else</span> {
         
            <span class="fu">fire</span>( ERROR_EVENT );
         }
      }
   };

   <span class="ot">xhr</span>.<span class=
"fu">open</span>(method, url, <span class="kw">true</span>);
   
   <span class="kw">for</span>( <span class=
"kw">var</span> headerName <span class="kw">in</span> headers ){
      <span class="ot">xhr</span>.<span class=
"fu">setRequestHeader</span>(headerName, headers[headerName]);
   }
   
   <span class="ot">xhr</span>.<span class=
"fu">send</span>(<span class=
"fu">validatedRequestBody</span>(data));
}</code>
</pre>

  <h2 id="util.js"><a href="#util.js"><span class=
  "header-section-number">7.12</span> util.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * This file defines some loosely associated syntactic sugar for </span>
<span class="co"> * Javascript programming </span>
<span class="co"> */</span>


<span class="co">/**</span>
<span class=
"co"> * Returns true if the given candidate is of type T</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">isOfType</span>(T, maybeSomething){
   <span class=
"kw">return</span> maybeSomething &amp;&amp; <span class=
"ot">maybeSomething</span>.<span class=
"fu">constructor</span> === T;
}
<span class="kw">function</span> <span class=
"fu">pluck</span>(key, object){
   <span class="kw">return</span> object[key];
}

<span class="kw">var</span> attr = <span class=
"fu">partialComplete</span>(partialComplete, pluck),
    len = <span class="fu">attr</span>(<span class=
"st">'length'</span>),    
    isString = <span class=
"fu">partialComplete</span>(isOfType, String);

<span class="co">/** </span>
<span class="co"> * I don't like saying this:</span>
<span class="co"> * </span>
<span class="co"> *    foo !=== undefined</span>
<span class="co"> *    </span>
<span class=
"co"> * because of the double-negative. I find this:</span>
<span class="co"> * </span>
<span class="co"> *    defined(foo)</span>
<span class="co"> *    </span>
<span class="co"> * easier to read.</span>
<span class="co"> */</span> 
<span class="kw">function</span> <span class=
"fu">defined</span>( value ) {
   <span class="kw">return</span> value !== <span class=
"kw">undefined</span>;
}

<span class="kw">function</span> <span class=
"fu">always</span>(){<span class="kw">return</span> <span class=
"kw">true</span>}

<span class="co">/**</span>
<span class=
"co"> * Returns true if object o has a key named like every property in </span>
<span class=
"co"> * the properties array. Will give false if any are missing, or if o </span>
<span class="co"> * is not an object.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class=
"fu">hasAllProperties</span>(fieldList, o) {

   <span class="kw">return</span>      (o <span class=
"kw">instanceof</span> Object) 
            &amp;&amp;
               <span class="fu">all</span>(<span class=
"kw">function</span> (field) {         
                  <span class=
"kw">return</span> (field <span class="kw">in</span> o);         
               }, fieldList);
}</code>
</pre>

  <h2 id="wire.js"><a href="#wire.js"><span class=
  "header-section-number">7.13</span> wire.js</a></h2>
  <pre class="sourceCode javascript">
<code class="sourceCode javascript"><span class="co">/**</span>
<span class=
"co"> * This file sits just behind the API which is used to attain a new</span>
<span class=
"co"> * Oboe instance. It creates the new components that are required</span>
<span class="co"> * and introduces them to each other.</span>
<span class="co"> */</span>

<span class="kw">function</span> <span class=
"fu">wire</span> (httpMethodName, url, body, headers){

   <span class="kw">var</span> eventBus = <span class=
"fu">pubSub</span>();
               
   <span class="fu">streamingHttp</span>(  <span class=
"ot">eventBus</span>.<span class="fu">fire</span>, <span class=
"ot">eventBus</span>.<span class="fu">on</span>,
                  <span class="kw">new</span> <span class=
"fu">XMLHttpRequest</span>(), 
                  httpMethodName, url, body, headers );                              
     
   <span class="kw">return</span> <span class=
"fu">instanceController</span>( 
               <span class="ot">eventBus</span>.<span class=
"fu">fire</span>, <span class="ot">eventBus</span>.<span class=
"fu">on</span>, 
               <span class="ot">clarinet</span>.<span class=
"fu">parser</span>(), 
               <span class=
"fu">incrementalContentBuilder</span>(<span class=
"ot">eventBus</span>.<span class="fu">fire</span>) 
   );
}</code>
</pre>

  <h1 id="bibliography"><a href="#bibliography"><span class=
  "header-section-number">8</span> Bibliography</a></h1>

  <p>Ahuvia, Yogev. 2013. &acirc;&euro;&oelig;Design Patterns:
  Infinite Scrolling: Let&acirc;&euro;&trade;s Get To The Bottom Of
  This
  http://uxdesign.smashingmagazine.com/2013/05/03/infinite-scrolling-get-bottom/.&acirc;&euro;
  Smashing Magazine.</p>

  <p>Anon. 2011. &acirc;&euro;&oelig;3G mobile data network
  crowd-sourcing survey.&acirc;&euro; BBC News.</p>

  <p>Conway, Mel. 2004. <em>Humanizing Application Building: An
  Anthropological Perspective</em>. <a href=
  "http://melconway.com/Home/pdf/humanize.pdf" title=
  "http://melconway.com/Home/pdf/humanize.pdf">http://melconway.com/Home/pdf/humanize.pdf</a>.</p>

  <p>Douglas, Crockford. 2009. &acirc;&euro;&oelig;JSON: The
  fat-free alternative to XML.&acirc;&euro; <a href=
  "http://json.org" title=
  "http://json.org">http://json.org</a>.</p>

  <p>Etemad, Elika J, and Tab Atkins. 2013.
  &acirc;&euro;&oelig;Selectors Level 4.&acirc;&euro; <a href=
  "http://dev.w3.org/csswg/selectors4/" title=
  "http://dev.w3.org/csswg/selectors4/">http://dev.w3.org/csswg/selectors4/</a>.</p>

  <p>Fielding, R. T. 2000. &acirc;&euro;&oelig;Principled design of
  the modern Web architecture.&acirc;&euro;</p>

  <p>Geelhoed, Erik, Peter Toft, Suzanne Roberts, and Patrick
  Hyland. 1995. &acirc;&euro;&oelig;To influence Time
  Perception.&acirc;&euro; Hewlett Packard Labs. <a href=
  "http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm"
  title=
  "http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm">http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm</a>.</p>

  <p>Graham, Paul. 2004. <em>The Other Road Ahead</em>.
  O&acirc;&euro;&trade;Reilly and Associates.</p>

  <p>Guo, shu-yu. 2013. &acirc;&euro;&oelig;Two Reasons Functional
  Style Is Slow in SpiderMonkey.&acirc;&euro; <a href=
  "http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html"
  title=
  "http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html">
  http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html</a>.</p>

  <p>Hopkins, Don. 1994. <em>The X-Windows Disaster</em>. Hungry
  Minds.</p>

  <p>Lea, Tom. 2012. &acirc;&euro;&oelig;Improving performance on
  twitter.com.&acirc;&euro; <a href=
  "[https://blog.twitter.com/2012/improving-performance-twittercom]"
  title=
  "[https://blog.twitter.com/2012/improving-performance-twittercom]">
  [https://blog.twitter.com/2012/improving-performance-twittercom]</a>.</p>

  <p>Martin, Robert &acirc;&euro;&oelig;Uncle Bob.&acirc;&euro;
  2008. <em>Clean Code: A Handbook of Agile Software
  Craftsmanship</em>.</p>

  <p>McLuhan, Marshall. 1964. <em>Understanding Media: The
  Extensions of Man</em>.</p>

  <p>Mullany, Michael. 2013. &acirc;&euro;&oelig;5 Myths About
  Mobile Web Performance.&acirc;&euro; <a href=
  "http://www.sencha.com/blog/5-myths-about-mobile-web-performance"
  title=
  "http://www.sencha.com/blog/5-myths-about-mobile-web-performance">
  http://www.sencha.com/blog/5-myths-about-mobile-web-performance</a>.</p>

  <p>Ralston, Anthony. 2000. &acirc;&euro;&oelig;Encyclopedia of
  Computer Science.&acirc;&euro; Nature Pub. Group.</p>

  <p>Reis, Eric. 2011. <em>The Lean Startup: How
  Today&acirc;&euro;&trade;s Entrepreneurs Use Continuous
  Innovation to Create Radically Successful Businesses.</em> Crown
  Business Publishing.</p>

  <p>Sapir, E. 1958. &acirc;&euro;&oelig;Culture, Language and
  Personality (ed. D. G. Mandelbaum).&acirc;&euro; Berkeley, CA:
  University of California Press.</p>

  <p>Stefanov, Stoyan. 2009. &acirc;&euro;&oelig;Progressive
  rendering via multiple flushes.&acirc;&euro; <a href=
  "http://www.phpied.com/progressive-rendering-via-multiple-flushes/"
  title=
  "http://www.phpied.com/progressive-rendering-via-multiple-flushes/">
  http://www.phpied.com/progressive-rendering-via-multiple-flushes/</a>.</p>

  <p>Whorf, B. L. 1956. &acirc;&euro;&oelig;Language, Thought and
  Reality (ed. J. B. Carroll).&acirc;&euro; Cambridge, MA: MIT
  Press.</p>

  <p>van Kesteren, Anne. 2012. &acirc;&euro;&oelig;XMLHttpRequest
  Level 2 Working Draft.&acirc;&euro; <a href=
  "http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications"
  title=
  "http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications">
  http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications</a>.</p>

  <p>van Kesteren, Anne, and Dean Jackson. 2006.
  &acirc;&euro;&oelig;The XMLHttpRequest Object.&acirc;&euro;
  <a href="http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/"
  title=
  "http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/">http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/</a>.</p>

  <div class="footnotes">
    <hr>

    <ol>
      <li id="fn1">
        <p><a href=
        "https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js">
        Https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js</a>
        I can't claim superior programming ability, this version is
        shorter because it is not a generic solution.<a href=
        "#fnref1">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn2">
        <p><a href=
        "https://github.com/substack/http-browserify">Https://github.com/substack/http-browserify</a>.<a href="#fnref2">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn3">
        <p><a href=
        "https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js">
        Https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js</a>
        I can't claim superior programming ability, this version is
        shorter because it is not a generic solution.<a href=
        "#fnref3">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn4">
        <p><a href=
        "https://github.com/substack/http-browserify">Https://github.com/substack/http-browserify</a>.<a href="#fnref4">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn5">
        <p><a href=
        "https://github.com/substack/http-browserify">Https://github.com/substack/http-browserify</a>.<a href="#fnref5">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn6">
        <p><a href=
        "https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js">
        Https://github.com/jimhigson/oboe.js/blob/master/src/streamingHttp.js</a>
        I can't claim superior programming ability, this version is
        shorter because it is not a generic solution.<a href=
        "#fnref6">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn7">
        <p>See <a href=
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global/_Objects/Object/freeze">
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Object/freeze</a>.
        Although older engines don't provide any ability to create
        immutable objects at run-time, we can be fairly certain
        that the code does not mutate these objects or the tests
        would fail when run in environments which are able to
        enforce this.<a href=
        "#fnref7">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn8">
        <p>JSONPath compiler from the first commit can be found at
        line 159 here: <a href=
        "https://github.com/jimhigson/oboe.js/blob/a17db7accc3a371853a2a0fd755153b10994c91e/src/main/progressive.js">
        https://github.com/jimhigson/oboe.js/blob/a17db7accc3a371853a2a0fd755153b10994c91e/src/main/progressive.js</a>#L159.<a href="#fnref8">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn9">
        <p>For contrast, the current source can be found at
        <a href="https://github.com/jimhigson/oboe.js/blob/master/src/jsonPath.js">
        https://github.com/jimhigson/oboe.js/blob/master/src/jsonPath.js</a>.<a href="#fnref9">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn10">
        <p>The current tests are viewable at <a href=
        "https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPath.unit.spec.js">
        https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPath.unit.spec.js</a>
        and <a href=
        "https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPathTokens.unit.spec.js">
        https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPathTokens.unit.spec.js</a>.<a href="#fnref10">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn11">
        <p>Probably the best known example being
        <code>memoize</code> from Underscore.js: <a href=
        "http://underscorejs.org/">http://underscorejs.org/</a>#memoize.<a href="#fnref11">&acirc;&dagger;&copy;</a></p>
      </li>

      <li id="fn12">
        <p><a href=
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular/_Expressions">
        Https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular\_Expressions</a>.<a href="#fnref12">&acirc;&dagger;&copy;</a></p>
      </li>
    </ol>
  </div>
</body>
</html>
