<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jim Higson" />
  <title>Oboe.js: An approach to i/o for rest clients which is neither batch nor stream; nor SAX nor DOM</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="buttondown.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Oboe.js: An approach to i/o for rest clients which is neither batch nor stream; nor SAX nor DOM</h1>
<h2 class="author">Jim Higson</h2>
<h3 class="date">2013</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#abstract"><span class="toc-section-number">1</span> Abstract</a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction</a><ul>
<li><a href="#how-rest-aggregation-could-be-faster"><span class="toc-section-number">2.1</span> How REST aggregation could be faster</a></li>
<li><a href="#stepping-outside-the-big-small-tradeoff"><span class="toc-section-number">2.2</span> Stepping outside the big-small tradeoff</a></li>
<li><a href="#staying-fast-on-a-fallible-network"><span class="toc-section-number">2.3</span> Staying fast on a fallible network</a></li>
<li><a href="#agile-methodologies-frequent-deployments-and-compatibility-today-with-versions-tomorrow"><span class="toc-section-number">2.4</span> Agile methodologies, frequent deployments, and compatibility today with versions tomorrow</a></li>
<li><a href="#deliverables"><span class="toc-section-number">2.5</span> Deliverables</a></li>
<li><a href="#criteria-for-success"><span class="toc-section-number">2.6</span> Criteria for success</a></li>
</ul></li>
<li><a href="#background"><span class="toc-section-number">3</span> Background</a><ul>
<li><a href="#the-web-as-an-application-platform"><span class="toc-section-number">3.1</span> The web as an application platform</a></li>
<li><a href="#node.js"><span class="toc-section-number">3.2</span> Node.js</a></li>
<li><a href="#state-of-web-browsers-as-rest-client-hosts"><span class="toc-section-number">3.3</span> State of web browsers as REST client hosts</a></li>
<li><a href="#streaming-to-the-browser"><span class="toc-section-number">3.4</span> Streaming to the browser</a></li>
<li><a href="#json-and-xml"><span class="toc-section-number">3.5</span> Json and XML</a></li>
<li><a href="#parsing-sax-and-dom"><span class="toc-section-number">3.6</span> Parsing: SAX and Dom</a></li>
<li><a href="#common-patterns-when-connecting-to-rest-services"><span class="toc-section-number">3.7</span> Common patterns when connecting to REST services</a></li>
<li><a href="#jsonpath-and-xpath"><span class="toc-section-number">3.8</span> JsonPath and XPath</a></li>
<li><a href="#testing"><span class="toc-section-number">3.9</span> Testing</a></li>
</ul></li>
<li><a href="#design-and-reflection"><span class="toc-section-number">4</span> Design and Reflection:</a><ul>
<li><a href="#jsonpath-and-types"><span class="toc-section-number">4.1</span> JSONPath and types</a></li>
<li><a href="#jsonpath-improving-stability-over-upgrades"><span class="toc-section-number">4.2</span> JSONPath improving stability over upgrades</a></li>
<li><a href="#importing-css4-selector-capturing-to-oboe-jsonpath"><span class="toc-section-number">4.3</span> Importing CSS4 selector capturing to Oboe JSONPath</a></li>
<li><a href="#parsing-the-json-response"><span class="toc-section-number">4.4</span> Parsing the JSON Response</a></li>
<li><a href="#api-design"><span class="toc-section-number">4.5</span> API design</a></li>
<li><a href="#earlier-callbacks-when-paths-are-matched"><span class="toc-section-number">4.6</span> Earlier callbacks when paths are matched</a></li>
<li><a href="#oboe.js-as-a-micro-library"><span class="toc-section-number">4.7</span> Oboe.js as a Micro-Library</a></li>
<li><a href="#handling-transport-failures"><span class="toc-section-number">4.8</span> Handling transport failures</a></li>
<li><a href="#fallback-support-on-less-capable-platforms"><span class="toc-section-number">4.9</span> Fallback support on less-capable platforms</a></li>
</ul></li>
<li><a href="#implementation"><span class="toc-section-number">5</span> Implementation</a><ul>
<li><a href="#components-of-the-project"><span class="toc-section-number">5.1</span> Components of the project</a></li>
<li><a href="#automated-testing"><span class="toc-section-number">5.2</span> Automated testing</a></li>
<li><a href="#running-the-tests"><span class="toc-section-number">5.3</span> Running the tests</a></li>
<li><a href="#packaging-as-a-single-distributable-file"><span class="toc-section-number">5.4</span> Packaging as a single, distributable file</a></li>
<li><a href="#styles-of-programming"><span class="toc-section-number">5.5</span> Styles of Programming</a></li>
<li><a href="#incrementally-building-up-the-content"><span class="toc-section-number">5.6</span> Incrementally building up the content</a></li>
<li><a href="#oboe-jsonpath-implementation"><span class="toc-section-number">5.7</span> Oboe JSONPath Implementation</a></li>
</ul></li>
<li><a href="#conclusion"><span class="toc-section-number">6</span> Conclusion</a><ul>
<li><a href="#benchmarking-vs-non-progressive-rest"><span class="toc-section-number">6.1</span> Benchmarking vs non-progressive REST</a></li>
<li><a href="#comparative-programmer-ergonomics"><span class="toc-section-number">6.2</span> Comparative Programmer Ergonomics</a></li>
<li><a href="#performance-of-code-styles-under-various-engines"><span class="toc-section-number">6.3</span> Performance of code styles under various engines</a></li>
<li><a href="#status-as-a-micro-library"><span class="toc-section-number">6.4</span> Status as a micro-library</a></li>
<li><a href="#potential-future-work"><span class="toc-section-number">6.5</span> potential future work</a></li>
</ul></li>
<li><a href="#appendix_http_limits"><span class="toc-section-number">7</span> Appendix i: Limits to number of simultaneous connections under various http clients</a></li>
<li><a href="#appendix-ii-oboe.js-source-code-listing"><span class="toc-section-number">8</span> Appendix ii: Oboe.js source code listing</a><ul>
<li><a href="#clarinetlisteneradaptor.js"><span class="toc-section-number">8.1</span> clarinetListenerAdaptor.js</a></li>
<li><a href="#events.js"><span class="toc-section-number">8.2</span> events.js</a></li>
<li><a href="#functional.js"><span class="toc-section-number">8.3</span> functional.js</a></li>
<li><a href="#incrementalcontentbuilder.js"><span class="toc-section-number">8.4</span> incrementalContentBuilder.js</a></li>
<li><a href="#instancecontroller.js"><span class="toc-section-number">8.5</span> instanceController.js</a></li>
<li><a href="#jsonpath.js"><span class="toc-section-number">8.6</span> jsonPath.js</a></li>
<li><a href="#jsonpathsyntax.js"><span class="toc-section-number">8.7</span> jsonPathSyntax.js</a></li>
<li><a href="#lists.js"><span class="toc-section-number">8.8</span> lists.js</a></li>
<li><a href="#pubsub.js"><span class="toc-section-number">8.9</span> pubSub.js</a></li>
<li><a href="#publicapi.js"><span class="toc-section-number">8.10</span> publicApi.js</a></li>
<li><a href="#streaminghttp-browser.js"><span class="toc-section-number">8.11</span> streamingHttp-browser.js</a></li>
<li><a href="#streaminghttp-node.js"><span class="toc-section-number">8.12</span> streamingHttp-node.js</a></li>
<li><a href="#util.js"><span class="toc-section-number">8.13</span> util.js</a></li>
<li><a href="#wire.js"><span class="toc-section-number">8.14</span> wire.js</a></li>
</ul></li>
<li><a href="#appendix-iii-benchmarking"><span class="toc-section-number">9</span> Appendix iii: Benchmarking</a><ul>
<li><a href="#benchmarkclient.js"><span class="toc-section-number">9.1</span> benchmarkClient.js</a></li>
<li><a href="#benchmarkserver.js"><span class="toc-section-number">9.2</span> benchmarkServer.js</a></li>
</ul></li>
<li><a href="#bibliography"><span class="toc-section-number">10</span> Bibliography</a></li>
</ul>
</div>
<div id="abstract" class="section level1">
<h1><a href="#abstract"><span class="header-section-number">1</span> Abstract</a></h1>
<p>A new design for http client libraries incorporating http streaming, pattern matching, and incremental parsing, with the aim of improving performance, fault tolerance, and encouraging a greater degree of loose coupling between programs. A Javascript client capable of progressively parsing JSON resources is presented targeting both Node.js and web browsers. Loose coupling is particularly considered in light of the application of Agile methodologies to REST and SOA, providing a framework in which it is acceptable to partially restructure the JSON format in which a resource is expressed whilst maintaining compatibility with dependent systems.</p>
<p>A critique is made of current practice under which resources are entirely retrieved before items of interest are extracted programmatically. An alternative model is presented allowing the specification of items of interest using a declarative syntax similar to JSONPath. The identified items are then provided incrementally while the resource is still downloading.</p>
<p>In addition to a consideration of performance in absolute terms, the usability implications of an incremental model are also evaluated with regards to developer ergonomics and end user perception of performance.</p>
</div>
<div id="introduction" class="section level1">
<h1><a href="#introduction"><span class="header-section-number">2</span> Introduction</a></h1>
<p>This purpose of this dissertation is to encourage the REST paradigm to be viewed through a novel lens which in application this may be used to deliver tangible benefits to many common REST use cases. Although I express my thesis through programming, the contribution I hope to make is felt more strongly as a modification in how we <em>think</em> about http than as the delivery of new software.</p>
<p>In the interest of developer ergonomics, REST clients have tended to style the calling of remote resources similar to the call style of the host programming language. Depending on the language, one of two schemas are followed: a synchronous style in which a some invocation halts execution for the duration of the request before evaluating to the fetched resource; or asynchronous in which the logic is specified to be applied to a response once it is available. Languages encourage our thinking to follow the terms that they easily support<span class="citation">(Whorf 1956)</span>. While there is some overlap, languages which promote concurrency though threading consider blocking in a single thread to be acceptable and will generally prefer the former mode whereas languages with first class functions are naturally conversant in callbacks and will prefer the latter. We should remember in programming that languages limit the patterns that we readily see <span class="citation">(Yukihiro 2003)</span> and that better mappings may be possible. This observation extends to graphical notations such as UML whose constructs strongly reflect the programming languages of the day. For any multi-packet message sent via a network some parts will arrive before others, at least approximately in-order, but viewed from inside a language whose statements invariably yield single, discrete values it comfortable to conceptualise the REST response as a discrete event. UML sequence diagrams contain the syntax for instantaneously delivered return values, with no corresponding notation for a resource whose data is progressively revealed.</p>
<p>In most practical cases where we wish to be fast in performing a task there is no reasonable distinction between acting <em>earlier</em> and being <em>quicker</em>. To create efficient software we should be using data at the first possible opportunity: examining content <em>while it streams</em> rather than holding it unexamined until it is wholly available.</p>
<p>While the coining of the term REST represented a shift in how we think about http, away from the transfer of hypertext documents to that of arbitrary data <span class="citation">(Fielding 2000, 407–416)</span>, it introduced no fundamentally new methods. Similarly building on previous ideas, no new computing techniques need be invented to realise my thesis. As a minimum it requires an http client which reveals the response whilst it is in progress and a parser which can begin to interpret that response before it sees all of it. Nor is it novel to use these preexisting parts in composition. Every current web browser already implements such a schema; load any complex webpage -- essentially an aggregation of hypertext and other resources -- the HTML will be parsed and displayed incrementally while it is downloading and resources such as images are requested in parallel as soon as they are referenced. The images may themselves be presented incrementally in the case of progressive JPEGs or SVGs<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. This incremental display is achieved through highly optimised software created for a single task, that of displaying web pages. The new contribution of this dissertation is to provide a generic analog applicable to any problem domain.</p>
<div id="how-rest-aggregation-could-be-faster" class="section level2">
<h2><a href="#how-rest-aggregation-could-be-faster"><span class="header-section-number">2.1</span> How REST aggregation could be faster</a></h2>
<div class="figure">
<img src="images/rest_timeline_1.png" alt="Sequence diagram showing the aggregation of low-level REST resources. A client fetches an author&#39;s publication list and then their first three articles. This sequence represents the most commonly used technique in which the client does not react to the response until it is complete. In this example the second wave of requests cannot be made until the original response is complete, at which time they are issued in quick succession. " /><p class="caption"><strong>Sequence diagram showing the aggregation of low-level REST resources.</strong> A client fetches an author's publication list and then their first three articles. This sequence represents the most commonly used technique in which the client does not react to the response until it is complete. In this example the second wave of requests cannot be made until the original response is complete, at which time they are issued in quick succession. </p>
</div>
<div class="figure">
<img src="images/rest_timeline_2.png" alt="Revised aggregation sequence for a client capable of progressively interpreting the resources. Because arrows in UML sequence diagrams draw returned values as a one-off happening rather than a continuous process, I have introduced a lighter arrow notation representing fragments of an incremental response. Each request for an individual publication is made as soon as the its URL can be extracted from the publications list and once all required data has been read from the original response it is aborted rather than continue to download unnecessary data. " /><p class="caption"><strong>Revised aggregation sequence for a client capable of progressively interpreting the resources.</strong> Because arrows in UML sequence diagrams draw returned values as a one-off happening rather than a continuous process, I have introduced a lighter arrow notation representing fragments of an incremental response. Each request for an individual publication is made as soon as the its URL can be extracted from the publications list and once all required data has been read from the original response it is aborted rather than continue to download unnecessary data. </p>
</div>
<p>Figures  and  comparatively illustrate how a progressive client may, without adjustments to the server, be used to produce an aggregated resource sooner. This results in a moderate improvement in the time taken to show the complete aggregation but a dramatic improvement in the time to show the first content. The ability to present the first content as early as possible is a desirable trait for system usability because it allows the user to start reading earlier and a progressively rendered display in itself increases the human perception of speed <span class="citation">(Geelhoed et al. 1995)</span>. Note also how the cadence of requests is more steady in Figure  with four connections opened at roughly equal intervals rather than a single request followed by a rapid burst of three. Both clients and servers routinely limit the number of simultaneous connections per peer so avoiding bursts of requests is further to our advantage. <a href="#appendix_http_limits">Appendix i</a> lists some actual limits.</p>
<p>Nodes in an n-tier architecture defy categorisation as 'client' or 'server' in a way which is appropriate from all frames of reference. A node might be labeled as the 'server' from the layer below and 'client' from the layer above. Although the &quot;client software&quot; labels in the figures above hint at something running directly on a user's own device, the same benefits apply if this layer is running remotely. If this layer were generating a web page on the server-side to be displayed by the client's browser, the perceptual speed improvements apply because of http chunked encoding <span class="citation">(Stefanov 2009)</span>. If this layer were a remote aggregation service, starting to write out the aggregated response early provides much the same benefits so long as the client is also able to interpret it progressively and, even if it were not, the overall delivery remains faster.</p>
</div>
<div id="stepping-outside-the-big-small-tradeoff" class="section level2">
<h2><a href="#stepping-outside-the-big-small-tradeoff"><span class="header-section-number">2.2</span> Stepping outside the big-small tradeoff</a></h2>
<p>Where a domain model contains data in a series with continuous ranges requestable via REST, I have often noticed a tradeoff in the client's design with regards to how much should be requested in each call. Because at any time it shows only a small window into a much larger model, the social networking site Twitter might be a good example. The Twitter interface designers adopted a popular interface pattern, Infinite Scrolling <span class="citation">(Ahuvia 2013)</span>. Starting from an initial page showing some finite number of tweets, once the user scrolls and reaches the end of the list the next batch is automatically requested. When loaded, this new batch is converted to HTML and added to the bottom of the page. Applied repeatedly the illusion of an infinitely long page in maintained, albeit punctuated with pauses whenever new content is loaded. For the programmers working on this presentation layer there is a tradeoff between sporadically requesting many tweets, yielding long, infrequent delays and frequently requesting a little, giving an interface which stutters momentarily but often.</p>
<p>I propose that progressive loading could render this tradeoff unnecessary by simultaneously delivering the best of both strategies. In the Twitter example this could be achieved by making large requests but instead of deferring all rendering until the request completes, add the individual tweets to the page as they are incrementally parsed out of the ongoing response. With a streaming transport, the time taken to receive the first tweet should not vary depending on the total number that are also being sent so there is no relationship between the size of the request made and the time taken to first update the interface.</p>
</div>
<div id="staying-fast-on-a-fallible-network" class="section level2">
<h2><a href="#staying-fast-on-a-fallible-network"><span class="header-section-number">2.3</span> Staying fast on a fallible network</a></h2>
<p>REST operates over networks whose reliability varies widely. On unreliable networks connections are abruptly dropped and in my opinion existing http clients handle unexpected terminations suboptimally. Consider the everyday situation of a person using a smartphone browser to check their email. Mobile data coverage is often weak outside of major cities <span class="citation">(Gill 2013)</span> so while travelling the signal will be lost and reestablished many times. The web developer's standard AJAX toolkit is structured in a way that encourages early terminated connections to be considered as wholly unsuccessful rather than as partially successful. For example, the popular AJAX library jQuery automatically parses JSON or XML responses before passing back to the application but given an early disconnection there is no attempt to hand over the partial response. To the programmer who knows where to look the partial responses are extractable as raw text but handling them involves writing a special case and is difficult because standard parsers are not amenable to incomplete markup. Because of this difficulty I can only find examples of partial messages being dropped without inspection. For the user checking her email, even if 90% of her inbox had been retrieved before her phone signal was lost, the web application will behave as if it received none and show her nothing. Later, when the network is available again the inbox will be downloaded from scratch, including the 90% which previously delivered. I see much potential for improvement here.</p>
<p>I propose moving away from this polarised view of successful/unsuccessful requests to one in which identifiable parts of a message are recognised as interesting in themselves, regardless of what follows, and these parts are handed back to the application as streaming occurs. This follows naturally from a conceptualisation of the http response as a progressive stream of many small parts; as each part arrives it should be possible to use it without knowing if the next will be delivered successfully. Should an early disconnection occur, the content delivered up to that point will have already been handled so no special case is required to salvage it. In most cases the only recovery necessary will be to make a new request for just the part that was missed. This approach is not incompatible with a problem domain where the usefulness of an earlier part is dependent on the correct delivery of the whole providing optimistic locking is used. In this case earlier parts may be used immediately but their effect rolled back should a notification of failure be received.</p>
</div>
<div id="agile-methodologies-frequent-deployments-and-compatibility-today-with-versions-tomorrow" class="section level2">
<h2><a href="#agile-methodologies-frequent-deployments-and-compatibility-today-with-versions-tomorrow"><span class="header-section-number">2.4</span> Agile methodologies, frequent deployments, and compatibility today with versions tomorrow</a></h2>
<p>In most respects a SOA architecture fits well with the fast release cycle encouraged by Agile methodologies. Because in SOA we may consider that all data is local rather than global and that the components are loosely coupled and autonomous, frequent releases of any particular sub-system shouldn't pose a problem to the correct operation of the whole. In allowing a design to emerge organically it should be possible for the structure of resource formats to be realised slowly and iteratively while a greater understanding of the problem is gained. Unfortunately in practice the ability to change is hampered by tools which encourage programming against rigidly specified formats. If a program is allowed to be tightly coupled to a data format it will resist changes in the programs which produce data to that format. Working in enterprise I have often seen the release of dozens of components cancelled because of a single unit that failed to meet acceptance criteria. By insisting on exact data formats, subsystems become tightly coupled and the perfect environment is created for contagion whereby the updating of any single unit may only be done as part of the updating of the whole.</p>
<p>An effective response to this problem would be to integrate into a REST clients the ability to use a response whilst being only loosely coupled to the <em>shape</em> of the message.</p>
</div>
<div id="deliverables" class="section level2">
<h2><a href="#deliverables"><span class="header-section-number">2.5</span> Deliverables</a></h2>
<p>To avoid feature creep I am paring down the software deliverables to the smallest work which can we said to realise my thesis, the guiding principle being that it is preferable to produce a little well than more badly. Amongst commentators on start-up companies this is known as a <em>zoom-in pivot</em> <span class="citation">(Reis 2011 p172)</span> and the work it produces should be the <em>Minimum Viable Product</em> or MVP <span class="citation">(Reis 2011 p106-110)</span>. With a focus on quality I could not deliver a full stack so I am obliged to implement only solutions which interoperate with existing deployments. This is advantageous; to somebody looking to improve their system small enhancements are more inviting than wholesale change.</p>
<p>To reify the vision above, a streaming client is the MVP. Because all network transmissions may be viewed though a streaming lens an explicitly streaming server is not required. Additionally, whilst http servers capable of streaming are quite common even if they are not always programmed as such, I have been unable to find any example of a streaming-receptive REST client.</p>
</div>
<div id="criteria-for-success" class="section level2">
<h2><a href="#criteria-for-success"><span class="header-section-number">2.6</span> Criteria for success</a></h2>
<p>In evaluating this project, we may say it has been a success if non-trivial improvements in speed can be made without a corresponding increase in the difficulty of programming the client. This improvement may be in terms of the absolute total time required to complete a representative task or in a user's perception of the speed in completing the task. Because applications in the target domain are much more io-bound than CPU-bound, optimisation in terms of the execution time of a algorithms will be de-emphasised unless especially egregious. The measuring of speed will include a consideration of performance degradation due to connections which are terminated early.</p>
<p>Additionally, I shall be considering how the semantics of a message are expanded as a system's design emerges and commenting on the value of loose coupling between data formats and the programs which act on them in avoiding disruption given unanticipated format changes.</p>
</div>
</div>
<div id="background" class="section level1">
<h1><a href="#background"><span class="header-section-number">3</span> Background</a></h1>
<div class="figure">
<img src="images/architecture.png" alt="Labelling nodes in an n-tier architecture. Regardless of where a node is located, REST may be used as the means of communication. By focusing on REST clients, nodes in the middleware and presentation layer fall in our scope. Although network topology is often split about client and server side, for our purposes categorisation as tiers is a more meaningful distinction. According to this split the client-side presentation layer and server-side presentation layer serve the same purpose, generating mark-up based on aggregated data created in the middle tier " /><p class="caption"><strong>Labelling nodes in an n-tier architecture</strong>. Regardless of where a node is located, REST may be used as the means of communication. By focusing on REST clients, nodes in the middleware and presentation layer fall in our scope. Although network topology is often split about client and server side, for our purposes categorisation as tiers is a more meaningful distinction. According to this split the client-side presentation layer and server-side presentation layer serve the same purpose, generating mark-up based on aggregated data created in the middle tier </p>
</div>
<div id="the-web-as-an-application-platform" class="section level2">
<h2><a href="#the-web-as-an-application-platform"><span class="header-section-number">3.1</span> The web as an application platform</a></h2>
<p>Application design has historically charted an undulating path pulled by competing approaches of thick and thin clients. Having evolved from a document viewing system to an application platform for all but the most specialised tasks, the web perpetuates this narrative by resisting categorisation as either mode.</p>
<p>While the trend is generally for more client scripting and for some sites Javascript is now requisite, there are also counter-trends. In 2012 twitter reduced load times to one fifth of their previous design by moving much of their rendering back to the server-side, commenting that &quot;The future is coming and it looks just like the past&quot; <span class="citation">(Lea 2012)</span>. Under this architecture short, fast-loading pages are generated on the server-side but Javascript is also provides progressively enhancement. Although it does not generate the page anew, the Javascript must know how to create most of the interface elements so one weakness of this architecture is that much of the presentation layer logic must be expressed twice.</p>
<p>Despite client devices taking on responsibilities which would previously have been performed on a server, there is a limit to how much of the stack may safely be offloaded in this direction. The client-side ultimately falls under the control of the user so no important business decisions should be taken here. A banking site should not allow loan approval to take place in the browser because for the knowledgeable user any decision would be possible. Separated from data stores by the public internet, the client is also a poor place to perform data aggregation or examine large data sets. For non-trivial applications these restrictions encourage a middle tier to execute business logic and produce aggregate data.</p>
<p>While REST may not be the only communications technology employed by an application architecture, for this project we should examine where the REST clients fit into the picture. REST is used to pull data from middleware for the sake of presentation regardless of where the presentation resides. Likewise, rather than connect to databases directly, for portability middlewares often communicate with a thin REST layer which wraps data stores. This suggests three uses:</p>
<ul>
<li>From web browser to middleware</li>
<li>From server-side presentation layer to middleware</li>
<li>From middleware to one or more nodes in a data tier</li>
</ul>
<p>Fortunately, each of these contexts require a similar performance profile. The node is essentially acting as a router dealing with small messages containing only the information they requested rather than dealing with a whole model. As a part of an interactive system low latency is important whereas throughput can be increased relatively cheaply by adding more hardware. As demand for the system increases the total work required grows but the complexity of any one of these tasks does remains constant. Although serving any particular request might be done in series, the workload as a whole at these tiers consists of many independent tasks and as such is embarrassingly parallelisable.</p>
</div>
<div id="node.js" class="section level2">
<h2><a href="#node.js"><span class="header-section-number">3.2</span> Node.js</a></h2>
<p>Node.js is a general purpose tool for executing Javascript outside of a browser. I has the aim of low-latency i/o and is used predominantly for server applications and command line tools. It is difficult to judge to what degree Javascript is a distraction from Node's principled design and to what degree the language defines the platform.</p>
<p>In most imperative languages the thread is the basic unit of concurrency. whereas Node presents the programmer with a single-threaded abstraction. Threads are an effective means to share parallel computation over multiple cores but are less well suited to scheduling concurrent tasks which are mostly i/o dependent. Programming threads safely with shared access to mutable objects requires great care and experience, otherwise the programmer is liable to create race conditions. Considering for example a Java http aggregator; because we wish to fetch in parallel each http request is assigned to a thread. These 'requester' tasks are computationally simple: make a request, wait for a complete response, and then participate in a Barrier to wait for the others. Each thread consumes considerable resources but during its multi-second lifespan requires only a fraction of a millisecond on the CPU. It is unlikely any two requests return at exactly the same moment so usually the threads will process in series rather than parallel anyway. Even if they do, the actual CPU time required in making an http request is so short that any concurrent processing is a pyrrhic victory. Following Node's lead, traditionally thread-based environments are beginning to embrace asynchronous, single-threaded servers. The Netty project can be though of as roughly the Java equivalent of Node.</p>
<div class="figure">
<img src="images/placeholder.png" alt="Single-threaded vs multi-threaded scheduling for a http aggregator" /><p class="caption"><em>Single-threaded vs multi-threaded scheduling for a http aggregator</em></p>
</div>
<p>Node builds on a model of event-based, asynchronous i/o that was established by Javascript execution in web browsers. Although Javascript in a browser may be performing multiple tasks simultaneously, for example requesting several resources from the server side, it does so from within a single-threaded virtual machine. Node similarly facilitates concurrency by managing an event loop of queued tasks and providing exclusively non-blocking i/o. Unlike Erlang, Node does not swap tasks out preemptively, it always waits for tasks to complete before moving onto the next. This means that each task must complete quickly to avoid holding up others. <em>Prima facie</em> this might seem like an onerous requirement to put on the programmer but in practice with only non-blocking i/o each task naturally exits quickly without any special effort. Accidental non-terminating loops or heavy number-crunching aside, with no reason for a task to wait it is difficult to write a node program where the tasks do not complete quickly.</p>
<p>Each task in node is simply a Javascript function. Node is able to swap its single Javascript thread between these tasks efficiently while providing the programmer with an intuitive interface because of closures. Utilising closures, the responsibility of maintaining state between issuing an asynchronous call and receiving the callback is removed from the programmer by folding it invisibly into the language. This implicit data store requires no syntax and feels so natural and inevitable that it is often not obvious that the responsibility exists at all.</p>
<p>Consider the example below. The code schedules three tasks, each of which are very short and exit quickly allowing Node to finely interlace them between other concurrent concerns. The <code>on</code> method is used to attach functions as listeners to streams. However sophisticated and performant this style of programming, to the developer it is hardly more difficult an expression than if a blocking io model were followed. It is certainly easier to get right than synchronising mutable objects for sharing between threads.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">printResourceToConsole</span>(url) {

   <span class="ot">http</span>.<span class="fu">get</span>(url)
      .<span class="fu">on</span>(<span class="st">&#39;response&#39;</span>, <span class="kw">function</span>(response){
      
         <span class="co">// This function will be called when the response starts.</span>
         <span class="co">// It logs to the console, adds a listener and quickly exits.</span>
         
         <span class="co">// Because it is captured by a closure we are able to reference </span>
         <span class="co">// the url parameter after the scope that declared it has finished.            </span>
         <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;The response has started for &quot;</span> + path);
      
         <span class="ot">response</span>.<span class="fu">on</span>(<span class="st">&#39;data&#39;</span>, <span class="kw">function</span>(chunk) {      
            <span class="co">// This function is called each time some data is received from the </span>
            <span class="co">// http request. In this example we write the response to the console</span>
            <span class="co">// and quickly exit.</span>
            <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;Got some response &#39;</span> + chunk);
                   
         }).<span class="fu">on</span>(<span class="st">&#39;end&#39;</span>, <span class="kw">function</span>(){
            <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;The response is complete&#39;</span>);
         })
         
      }).<span class="fu">on</span>(<span class="st">&quot;error&quot;</span>, <span class="kw">function</span>(e){
         
         <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;There was an error: &quot;</span> + <span class="ot">e</span>.<span class="fu">message</span>);
      });      
   <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;The request has been made&quot;</span>);
}   </code></pre>
<blockquote>
<p>&quot;Node Stream API, which is the core I/O abstraction in Node.js (which is a tool for I/O) is essentially an abstract in/out interface that can handle any protocol/stream that also happens to be written in JavaScript.&quot; <span class="citation">(Ogden 2012)</span></p>
</blockquote>
<p>In Node i/o is performed through a unified streaming interface regardless of the source. The streams follow a publisher-subscriber pattern fitting comfortably with the wider event-driven model. Although the abstraction provided by streams is quite a thin layer on top of the host system's socket, it forms a powerful and intuitive interface. For many tasks it is preferable to program in a 'plumbing' style by joining one stream's output to another's input. In the example below a resource from the internet is written to the local filesystem.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">http</span>.<span class="fu">get</span>(url)
   .<span class="fu">on</span>(<span class="st">&#39;response&#39;</span>, <span class="kw">function</span>(response){
      <span class="ot">response</span>.<span class="fu">pipe</span>(<span class="ot">fs</span>.<span class="fu">createWriteStream</span>(pathToFile));
   });</code></pre>
</div>
<div id="state-of-web-browsers-as-rest-client-hosts" class="section level2">
<h2><a href="#state-of-web-browsers-as-rest-client-hosts"><span class="header-section-number">3.3</span> State of web browsers as REST client hosts</a></h2>
<p>Making http requests from Javascript, commonly termed AJAX, was so significant in establishing the modern web architecture that it is sometimes used synonymously with Javascript-rich web applications. Although AJAX is an acronym for <strong>A</strong>synchronous <strong>J</strong>avascript (<strong>a</strong>nd) <strong>X</strong>ML, this reflects the early millennial enthusiasm for XML as the one true data format and in practice any textual format may be transferred. Today JSON is generally preferred, especially for delivery to client-side web applications. During the 'browser war' years web browsers competed by adding non-standard features; Internet Explorer made AJAX possible in 2000 by exposing Microsoft's Active X <em>Xml Http Request</em> (XHR) class to the Javascript sandbox. This was widely copied and near equivalents were added to all major browsers. In 2006 the interface was eventually formalised by the W3C <span class="citation">(van Kesteren and Jackson 2006)</span>. XHR's slow progresss to standardisation reflected a period of general stagnation for web standards. HTML4 reached Recommendation status in 2001 but having subsequently found several evolutionary dead ends such as XHTML, there would be no major updates until HTML5 started to gather pace some ten years later.</p>
<p>Despite a reputation for being poorly standardised, as a language Javascript is very consistently implemented. More accurately we would say that the libraries exposed to Javascript by the browsers lack compatibility. Given this backdrop of vendor extensions and lagging standardisation, abstraction layers predictably rose in popularity. Various abstractions competed primarily on developer ergonomics with the popular jQuery and Prototype.js libraries promoting themselves as <em>&quot;do more, write less&quot;</em> and <em>&quot;elegant APIs around the clumsy interfaces of Ajax&quot;</em> respectively. Written for an unadorned browser, Javascript applications read as a maze of platform-detection and special cases. Once applications were built using Javascript abstractions over underlying browser differences, they could be written purposefully and comprehensibly express more complex ideas.</p>
<p>JSON, itself a subset of Javascript, emerged as the main format for REST end points when requested via AJAX. Javascript programmers occupied a privileged position whereby their serialisation format mapped exactly onto the inbuilt types of the programming language. As such there was never any confusion regarding which object structure to de-serialise to. Should this advantage seem insubstantial, contrast with the plethora of confusing and incompatible representations of JSON given by the various Java parsers: JSON's Object better resembles Java's Map interface than Java Objects and the confusion between JSON null, Java null, and Jackson's NullNode<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> is a common cause of errors. Emboldened by certainty regarding deserialisation, AJAX libraries directly integrated JSON parsers, providing a call style for working with remote resources so streamlined as to require hardly any additional effort.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">jQuery</span>.<span class="fu">ajax</span>(<span class="st">&#39;http://example.com/people.json&#39;</span>, <span class="kw">function</span>( people ) {

   <span class="co">// The parsing of the people json into a javascript object</span>
   <span class="co">// feels so natural that it is easy to forget from looking </span>
   <span class="co">// at the code that parsing happens at all. </span>
   
   <span class="fu">alert</span>(<span class="st">&#39;the first person is called &#39;</span> + people[<span class="dv">0</span>].<span class="fu">name</span>);
});</code></pre>
<p>Whilst simple, the above call style is built on the assumption that a response is a one-time event and no accommodation is made for a continuously delivered response. Meanwhile, the XHR2 standardisation process had started and was busy observing and specifying proprietary extensions to the original XHR1. Given an interest in streaming, the most interesting of these is the progress event:</p>
<blockquote>
<p>While the download is progressing, queue a task to fire a progress event named progress about every 50ms or for every byte received, whichever is least frequent. <span class="citation">(van Kesteren 2012)</span></p>
</blockquote>
<p>Prior to this addition there had been no mechanism, at least so far as the published specs to an XHR instance in a streaming fashion. However, while all major browsers currently support progress events in their most recently versions, the installed userbase of supporting browsers is unlikely to grow fast enough that this technique may be relied upon without a fallback for several years.</p>
<p>In fact, this is exactly how web browsers are implemented. However, this progressive use of http is hardwired into the browser engines rather than exposing an API suitable for general use and as such is treated as something of a special case specific to web browsers and has not so far seen a more general application. I wish to argue that a general application of this technique is viable and offers a worthwhile improvement over current common methods.</p>
<p>While until recently browsers have provided no mechanism to stream into AJAX, almost every other instance of downloading has taken advantage of streaming and progressive interpretation. This includes image formats, as the progressive PNG and JPEG; markup as progressive display of html and svg; video; and Javascript itself -- script interpretation starts before the script is wholly fetched. Each of these progressive considerations is implemented as a specific-purpose mechanism internal to the browser which is not exported to Javascript and as such is not possible to repurpose.</p>
<p><em>Client side deals with user input interactively whereas the server as a batch of data. Like most interactive programming, client-side scripts usually suffer greater delays waiting for io than because javascript execution times present a bottleneck. Because Javascript is used for user interfaces, frame-rates are important. Single threaded so js holds up rendering. Important to return control to the browser quickly. However, once execution of each js frame of execution is no more than the monitor refresh rate, further optimisation is without practical benefit. Hence, writing extremely optimised Javascript, especially focusing on micro-optimisations that hurt code readability is a futile endeavour.</em></p>
<blockquote>
<p>The user does something, then the app responds visually with immediacy at 30 frames per second or more, and completes a task in a few hundred milliseconds. As long as an app meets this user goal, it doesn’t matter how big an abstraction layer it has to go through to get to silicon. <span class="citation">(Mullany 2013)</span></p>
</blockquote>
</div>
<div id="streaming-to-the-browser" class="section level2">
<h2><a href="#streaming-to-the-browser"><span class="header-section-number">3.4</span> Streaming to the browser</a></h2>
<p>As the web's remit spread to include more applications which would previously have been native apps, to be truly 'live' many applications found the need to be able to receive real-time push events. Dozens of streaming transports have been developed sidestepping the browser's apparent limitations.</p>
<p>The earliest and most basic attempt was to poll by making many requests, I won't consider this approach other than to say it came with all the usually associated downsides. Despite the inadequacy of this approach, from here the improved technique of <em>long polling</em> was invented. A client makes a request to the server side. Once the connection is open the server waits, writing nothing until a push is required. To push the server writes the message and closes the http connection; since the http response is now complete the content may be handled by the Javascript client which then immediately makes a new request, reiterating the cycle of wait and response. This approach works well where messages are infrequently pushed but where the frequency is high the limitation of one http transmission per connections requires imposes a high overhead.</p>
<p>Observing that while browsers lack progressive ajax, progressive html rendering is available, <em>push tables</em> achieve progressive data transfer by serialising streaming data to a HTML format. Most commonly messages are written to a table, one row per message. On the client side this table is hidden in an off-screen frame and the Javascript streaming client watches the table and reacts whenever a new row is found. In many ways an improvement over long-polling, this approach nevertheless suffers from an unnatural data format. Whilst html is a textual format so provides a degree of human-readability, html was not designed with the goal of an elegent or compact transfer of asynchronous data. Contrasted with a SOA ideal of <em>'plumbing on the outside'</em>, peeking inside the system is difficult whilst bloated and confusing formats are tasked with conveying meaning.</p>
<p>Both long polling and push tables are better throught of as a means to circumvent restrictions than indigene technology. A purose-built stack, <em>Websockets</em> is poised to take over, building a standardised duplex transport and API on top of http's chunked mode. While the newest browsers support websockets, most of the wild use base does not. Nor do older browsers provide a fine-grained enough interface into http in order to allow a Javascript implementation. In practice, real-world streaming libraries such as socket.io [CITE] are capable of several streaming techniques and can select the best for a given context. To the programmer debugging an application the assortment of transports only enhances the black-box mentality with regards to the underlying transports.</p>
<p><em>some or all of the below could move to A&amp;R, it is wondering into analysis</em></p>
<p>Whilst there is some overlap, each of the approaches above addresses a problem only tangentially related to this project's aims. Firstly, requiring a server that can write to an esoteric format feels quite anti-REST, especially given that the server is sending in a format which requires a specific, known, specialised client rather than a generic tool. In REST I have always valued how prominently the plumbing of a system is visible, so that to sample a resource all that is required is to type a URL and be presented with it in a human-comprehensible format.</p>
<p>Secondly, as adaptations to the context in which they were created, these frameworks realise a view of network usage in which downloading and streaming are dichotomously split, whereas I aim to realise a schema without dichotomy in which <em>streaming is adapted as the most effective means of downloading</em>. In existing common practice a wholly distinct mechanism is provided vs for data which is ongoing vs data which is finite. For example, the display of real-time stock data might start by AJAXing in historical and then separately use a websocket to maintain up-to-the-second updates. This requires the server to support two distinct modes. However, I see no reason why a single transport could not be used for both. Such a server might start answering a request by write historic events from a database, then switch to writing out live data in the same format in response to messages from a MOM. By closing the dichotomy we would have the advantage that a single implementation is able to handle all cases.</p>
<p>It shouldn't be a surprise that a dichotomous implementation of streaming, where a streaming transport is used only for live events is incompatible with http caching. If an event is streamed when it is new, but then when it is old made available for download, http caching between the two requests is impossible. However, where a single mode is used for both live and historic events the transport is wholly compatible with http caching.</p>
<p>If we take streaming as a technique to achieve efficient downloading, not only for the transfer of forever-ongoing data, none of these approaches are particularly satisfactory.</p>
</div>
<div id="json-and-xml" class="section level2">
<h2><a href="#json-and-xml"><span class="header-section-number">3.5</span> Json and XML</a></h2>
<p><em>later mention JSON 'nodes'/'paths' a lot. Good place to intro here</em></p>
<p>Although AJAX started as a means to transfer XML, today JSON &quot;The fat-free alternative to XML<span class="citation">(Douglas 2009)</span>&quot; is the more popular serialisation format. The goals of XML were to simplify SGML to the point that a graduate student would be able to implement a parser in a week [@javaxml p ???]. For the student tackling JSON a few hours with a parser generator should surfice, being expressable in 15 CFGs. Indeed, because JSON is a strict subset of Javascript, in many cases the Javascript programmer requires no parser at all. Unimpeeded by SGML's roots as a document format, JSON provides a much more direct analogue to the metamodel of a canonical modern programming language with entities such as <em>string</em>, <em>number</em>, <em>object</em> and <em>array</em>. By closely mirroring a programmer's metamodel, visualising a mapping between a domain model and it's serialised objects becomes trivial.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{
   <span class="dt">people</span>: [
      {<span class="dt">name</span>: <span class="st">&#39;John&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;Oxford&#39;</span>},
      {<span class="dt">name</span>: <span class="st">&#39;Jack&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;Bristol&#39;</span>}
   ]
}</code></pre>
<p>This close resemblance to the model of the programming in some cases causes fast-changing formats.</p>
<p>Like XML attributes, as a serialised text format, JSON objects have an order but are almost always parsed to and from orderless maps meaning that the order of the keys/value pairings as seen in the stream usually follows no defined order. No rule in the format would forbid representing of an ordered map in an ordered way but most tools on receiving such a message would ignore the ordering.</p>
<p>(MINE SOA assignment). Also the diagram.</p>
</div>
<div id="parsing-sax-and-dom" class="section level2">
<h2><a href="#parsing-sax-and-dom"><span class="header-section-number">3.6</span> Parsing: SAX and Dom</a></h2>
<p>In the XML world two standard parser models exist, SAX and DOM, with DOM far the more popular. DOM performs a parse as a single evaluation, on the request of the programmer, returning an object model representing the whole of the document. At this level of abstraction the details of the markup are only distant concern. Conversely, SAX parsers are probably better considered as tokenisers, providing a very low-level event driven interface in line with the Observer pattern to notify the programmer of syntax as it is seen. Each element's opening and closing tag is noted</p>
<p>This presents poor developer ergonomics by requiring that the programmer implement the recording of state with regard to the nodes that they have seen. For programmers using SAX, a conversion to their domain objects is usually implemented imperatively. This programming tends to be difficult to read and programmed once per usage rather than assembled as the combination of reusable parts. For this reason SAX is usually reserved for fringe cases where messages are very large or memory unusually scarce.</p>
<p>DOM isn't just a parser, it is also a cross-language defined interface for manipulating the XML in real time, for example to change the contents of a web page in order to provide some interactivity. In JSON world, DOM-style parser not referring to the DOM spec, or what browser makers would mean. Rather, borrowing from the XML world to mean a parser which requires the whole file to be loaded.</p>
<p>Suppose we want to extract the name of the first person. Given a DOM parser this is very easy:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">nameOfFirstPerson</span>( myJsonString ) {

   <span class="co">// Extracting an interesting part from JSON-serialised data is</span>
   <span class="co">// relatively easy given a DOM-style parser. Unfortunately this</span>
   <span class="co">// forbids any kind of progressive consideration of the data.</span>
   <span class="co">// All recent browsers provide a JSON parser as standard. </span>

   <span class="kw">var</span> document = <span class="ot">JSON</span>.<span class="fu">parse</span>( myJsonString );
   <span class="kw">return</span> <span class="ot">document</span>.<span class="fu">people</span>[<span class="dv">0</span>].<span class="fu">name</span>; <span class="co">// that was easy!</span>
}</code></pre>
<p>Contrast with the programming below which uses the clarinet JSON SAX parser. To prove that I'm not exaggerating the case, see published usages at [Clarinet demos].</p>
<p></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">nameOfFirstPerson</span>( myJsonString, callbackFunction ){

   <span class="co">// The equivalent logic, expressed in the most natural way</span>
   <span class="co">// fora s JSON SAX parser is longer and much more </span>
   <span class="co">// difficult to read. The developer pays a high price for </span>
   <span class="co">// progressive parsing. </span>

   <span class="kw">var</span> clarinet = <span class="ot">clarinet</span>.<span class="fu">parser</span>(),
   
       <span class="co">// with a SAX parser it is the developer&#39;s responsibility </span>
       <span class="co">// to track where in the document the cursor currently is,</span>
       <span class="co">// requiring several variables to maintain.        </span>
       inPeopleArray = <span class="kw">false</span>,   
       inPersonObject = <span class="kw">false</span>,
       inNameAttribute = <span class="kw">false</span>,
       found = <span class="kw">false</span>;
   
   <span class="ot">clarinet</span>.<span class="fu">onopenarray</span> = <span class="kw">function</span>(){
      <span class="co">// for brevity we&#39;ll cheat by assuming there is only one</span>
      <span class="co">// array in the document. In practice this would be overly</span>
      <span class="co">// brittle.</span>
      
      inPeopleArray = <span class="kw">true</span>; 
   };
   
   <span class="ot">clarinet</span>.<span class="fu">onclosearray</span> = <span class="kw">function</span>(){
      inPeopleArray = <span class="kw">false</span>;
   };   
   
   <span class="ot">clarinet</span>.<span class="fu">onopenobject</span> = <span class="kw">function</span>(){
      inPersonObject = inPeopleArray; 
   };
   
   <span class="ot">clarinet</span>.<span class="fu">oncloseobject</span> = <span class="kw">function</span>(){
      inPersonObject = <span class="kw">false</span>;
   };   
      
   <span class="ot">clarinet</span>.<span class="fu">onkey</span> = <span class="kw">function</span>(key){
      inNameAttribute = ( inPeopleObject &amp;&amp; key == <span class="st">&#39;name&#39;</span>);
   };

   <span class="ot">clarinet</span>.<span class="fu">onvalue</span> = <span class="kw">function</span>(value){
      <span class="kw">if</span>( !found &amp;&amp; inNameAttribute ) {
         <span class="co">// finally!</span>
         <span class="fu">callbackFunction</span>( value );
         found = <span class="kw">true</span>;
      }
   };      
   
   <span class="ot">clarinet</span>.<span class="fu">write</span>(myJsonString);   
}</code></pre>
<p>As we can see above, SAX's low-level semantics require a lengthy expression and for the programmer to maintain state regarding the position in the document -- usually recording the ancestors seen on the descent from the root to the current node -- in order to identify the interesting parts. This order of the code is also quite unintuitive; generally event handlers will cover multiple unrelated concerns and each concern will span multiple event handlers. This lends to programming in which separate concerns are not separately expressed in the code.</p>
</div>
<div id="common-patterns-when-connecting-to-rest-services" class="section level2">
<h2><a href="#common-patterns-when-connecting-to-rest-services"><span class="header-section-number">3.7</span> Common patterns when connecting to REST services</a></h2>
<p>Marshaling provides two-way mapping between a domain model and a serialisation as JSON or XML, either completely automatically or based on a declarative specification. To handle a fetched rest response it is common to automatically demarshal it so that the application may make use of the response from inside its own model, no differently from objects assembled in any other way. From the perspective of the programmer it is as if the domain objects themselves had been fetched. Another common design pattern, intended to give a degree of isolation between concerns, is to demarshal automatically only so far as Data Transfer Objects (DTOs), instances of classes which implement no logic other than storage, and from there programmatically instantiate the domain model objects. Going one step further, for JSON resources sent to loosely-typed languages with a native representation of objects as generic key-value pairs such as Javascript or Clojure, the marshaling step is often skipped: the output from the parser so closely resembles the language's built-in types that it is simplest to use it directly. Depending on the programming style adopted we might say that the JSON parser's output <em>is</em> the DTO and create domain model objects based on it, or that no further instantiation is necessary.</p>
<div class="figure">
<img src="images/placeholder.png" alt="Degrees of automatic marshaling. From marshaling directly to domain objects, DTOs, using parser output as a DTO, or using objects directly. Distinguish work done by library vs application programmer&#39;s domain" /><p class="caption"><em>Degrees of automatic marshaling</em>. From marshaling directly to domain objects, DTOs, using parser output as a DTO, or using objects directly. Distinguish work done by library vs application programmer's domain</p>
</div>
<p>Ultimately the degree of marshaling that is used changes only the level of abstraction of the resource that the REST client library hands over to the application developer. Regardless of the exact form of the response model, the developer will usually programmatically extract one or more parts from it via calls in the programming language itself. For example, on receiving a resource de-marshaled to domain objects, a Java developer will inspect it by calling a series of getters in order to narrow down to the interesting parts. This is not to say that the whole of the message might not in some way be interesting, only that by using it certain parts will need to be identified as distinct areas of concern.</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="co">// An example programmatic approach to a domain model interrogation </span>
<span class="co">// under Java; upon receiving a list of people, each person&#39;s name</span>
<span class="co">// is added to a database. The methods used to drill down to the</span>
<span class="co">// pertinent components of the response are all getters: getPeople, </span>
<span class="co">// getGivenName, and getSurname. </span>
<span class="dt">void</span> <span class="fu">handleResponse</span>( RestResponse response ) {

   <span class="kw">for</span>( Person p : response.<span class="fu">getPeople</span>() ) {
      <span class="fu">addNameToDb</span>( p.<span class="fu">getGivenName</span>(), p.<span class="fu">getSurname</span>() );
   }   
}</code></pre>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Although in this Javascript example the objects passed to the handler </span>
<span class="co">// remain in the form given by the JSON parser, containing no domain-specific</span>
<span class="co">// getters, the programming represents a different expression of the same </span>
<span class="co">// basic process.</span>
<span class="kw">function</span> <span class="fu">handleResponse</span>( response ){

   <span class="ot">response</span>.<span class="ot">people</span>.<span class="fu">forEach</span>( <span class="kw">function</span>( person ){
      <span class="fu">addNameToDb</span>( <span class="ot">p</span>.<span class="fu">givenName</span>, <span class="ot">p</span>.<span class="fu">surname</span> );
   });
}</code></pre>
<p>Because it is applied directly to the metamodel of the language[^ It could be argued that getters aren't a part of the metamodel of Java itself, but they form such a common pattern that it is a part ], this extraction has become such a natural component of a workflow that it maye be used while thinking of it as wholly unremarkable. In the examples above we are interacting with the model in the way that the language makes the most easy to conceptualise. However se should consider that, however subtly embedded, the technique is an invented construct and only one of the possible formulations which might have been drawn.</p>
<p>One weakness of this inspection model is that, once much code is written to interrogate models in this way, the interface of the model becomes increasingly expensive to change as the code making the inspections becomes more tightly coupled with the thing that it is inspecting. Taking the above example, if the model were later refactored such that the concepts of firstName and surName were pulled from the Person class into an extracted Name class, because the inspection relies on a sequence of calls made directly into domain objects, the code making the query would also have to change. Whilst following the object oriented principle of encapsulation of data, such that the caller does not have to concern themselves with the data structures hidden behind the getter, there is no such abstraction for when the structure itself changes. Given an Agile environment where the shape of data is refactored regularly, this would be a problem when programming against any kind of resource; for example, if change of objects formats propagates knock-on changes where ever the object is used it is very difficult to commit small diffs to the VCS which make incremental changes to a tightly focused area of the system. A method of programming which truly embraced extreme programming would allow constant change without disparate, barely related parts having to be modified in parallel when structural refactoring occurs. The coupling is all the more acute where the format of the item being inspected is defined by an independently maintained service.</p>
<p><em>contagion problem</em></p>
<p>Extraneous changes dilute the changelog, making it less easily defined by code changes which are intrinsically linked to the actual change in the logic being expressed by the program, and therefore to the thinking behind the change and the reason for the change.</p>
</div>
<div id="jsonpath-and-xpath" class="section level2">
<h2><a href="#jsonpath-and-xpath"><span class="header-section-number">3.8</span> JsonPath and XPath</a></h2>
<p>Both the above difficulty in identifying the interesting parts of a message whilst using a streaming parser and the problem with tight coupling of programmatic drilling down to REST formats leads me to search for areas where this problem has already been solved.</p>
<p>In the domain of markup languages there are associated query languages such as XPATH whose coupling is loose enough that their expressions may continue to function after the exact shape of a message is refactored. While observing this is nothing more radical than using the query languages in more-or-less they were intended, their employment is not the most natural coming from a programming context in which the application developer's responsibilities usually start where the demarshaler's end. Consider the following XML:</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;givenName&gt;</span>...<span class="kw">&lt;/givenName&gt;</span>   
      <span class="kw">&lt;familyName&gt;</span>Bond<span class="kw">&lt;/familyName&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code></pre>
<p>The XPath //person[0]//surname//text() would continue to identify the correct part of the resource without being updated after the xml analogue of the above Java Name refactor:</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;name&gt;</span>
         <span class="kw">&lt;givenName&gt;</span>...<span class="kw">&lt;/givenName&gt;</span>
         <span class="kw">&lt;familyName&gt;</span>Bond<span class="kw">&lt;/familyName&gt;</span>
      <span class="kw">&lt;/name&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code></pre>
<p>Luckily in JSON there exists already an attempt at an equivalent named Jsonpath. JsonPath closely resembles the javascript code which would select the same nodes. Not a real spec.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="co">// an in-memory person with a multi-line address:</span>
<span class="kw">let</span> person = {
   <span class="dt">name</span>: {<span class="dt">givenName</span>:<span class="st">&#39;&#39;</span>, <span class="dt">familyName</span>:<span class="st">&#39;&#39;</span>},
   <span class="dt">address</span>: [
      <span class="st">&quot;line1&quot;</span>,
      <span class="st">&quot;line2&quot;</span>,
      <span class="st">&quot;line3&quot;</span>
   ]
}


<span class="co">// in javascript we can get line two of the address as such:</span>
<span class="kw">let</span> address = <span class="ot">person</span>.<span class="fu">address</span>[<span class="dv">2</span>]

<span class="co">// the equivalent jsonpath expression is identical:</span>
<span class="kw">let</span> jsonPath = <span class="st">&quot;person.address[2]&quot;</span>

<span class="co">// although jsonpath also allows ancestor relationships which are not</span>
<span class="co">// expressible quite so neatly as basic Javascript:</span>
<span class="kw">let</span> jsonPath2 = <span class="st">&quot;person..given&quot;</span></code></pre>
<p>Xpath is able to express identifiers which often survive refactoring because XML represents a tree, hence we can consider relationships between entities to be that of contains/contained in (also siblings?). In application of XML, in the languages that we build on top of XML, it is very natural to consider all elements to belong to their ancestors. Examples are myriad, for example consider a word count in a book written in DOCBook format - it should be calculable without knowing if the book is split into chapters or not since this is a concept internal to the organisation of the book itself nd not something that a querier is likely to find interesting - if this must be considered the structure acts as barrier to information rather than enabling the information's delivery. Therefore, in many cases the exact location of a piece of information is not as important as a more general location of x being in some way under y.</p>
<p>This may not always hold. A slightly contrived example might be if we were representing a model of partial knowledge:</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;people&gt;</span>
   <span class="kw">&lt;person&gt;</span>
      <span class="kw">&lt;name&gt;</span>
         <span class="kw">&lt;isNot&gt;&lt;surname&gt;</span>Bond<span class="kw">&lt;/surname&gt;&lt;/isNot&gt;</span>
      <span class="kw">&lt;/name&gt;</span>
   <span class="kw">&lt;/person&gt;</span>
<span class="kw">&lt;/people&gt;</span></code></pre>
<p>The typical use pattern of XPath or JSONPath is to search for nodes once the whole serialisation has been parsed into a DOM-style model. JSONPath implementation only allows for search-type usage: <a href="https://code.google.com/p/jsonpath/To">https://code.google.com/p/jsonpath/To</a> examine a whole document for the list of nodes that match a jsonpath expression the whole of the tree is required. But to evaluate if a single node matches an expression, only the <em>path of the descent from the root to that node</em> is required -- the same state as a programmer usually maintains whilst employing a SAX parser. This is possible because JSONPath does not have a way to express the relationship with sibling nodes, only ancestors and decedents.</p>
<p>One limitation of the JSONPath language is that it is not possible to construct an 'containing' expression. CSS4 allows this in a way that is likely to become familiar to web developers over the next five years or so.</p>
</div>
<div id="testing" class="section level2">
<h2><a href="#testing"><span class="header-section-number">3.9</span> Testing</a></h2>
<div class="figure">
<img src="images/placeholder.png" alt="Relationship between the main players in the JS testing landscape. JSTD, Karma, Jasmine, NodeUnit, jasmine-node, Browsers" /><p class="caption">Relationship between the main players in the JS testing landscape. JSTD, Karma, Jasmine, NodeUnit, jasmine-node, Browsers</p>
</div>
<p>By the commonjs spec, test directory should be called 'test' (<a href="http://wiki.commonjs.org/wiki/Packages/1.0">http://wiki.commonjs.org/wiki/Packages/1.0</a>#Package_Directory_Layout) doesn't matter for my project since not using commonjs, but might as well stick to the convention.</p>
<p>How TDD helps How can fit into methodology</p>
<ul>
<li>JSTD</li>
<li>NodeUnit</li>
<li>Karma</li>
<li>Jasmine</li>
</ul>
<p>Initially started with jstestdriver but found it difficult. Karma started because engineers working on the Angular project in Google were &quot;struggling a lot with jstd&quot;: <a href="http://www.youtube.com/watch?v=MVw8N3hTfCI">http://www.youtube.com/watch?v=MVw8N3hTfCI</a> - jstd is a google project Even Jstd's authors seems to be disowning it slightly. Describe what was once its main mode of operation as now being for stress testing of jstd itself only. Problems: browsers become unresponsive. Generally unreliable, has to be restarted frequently.</p>
<p>JSTD, as a Java program, is difficult to start via Grunt. Also an issue that Grunt post-dates Karma by enough that JSTD doesn't have the attention of the Grunt community.</p>
<!---
Chapter 4+5 40 to 60 pages

@333w/p, 13,000 to 19,000
--->

</div>
</div>
<div id="design-and-reflection" class="section level1">
<h1><a href="#design-and-reflection"><span class="header-section-number">4</span> Design and Reflection:</a></h1>
<p>Using a combination of the techniques investigated in the previous chapter, I propose that a simple design is possible which makes REST clients more efficient whilst being no more difficult to program. Although simple, this model fits poorly with established vocabulary, requiring a transport that sits <em>somewhere between 'stream' and 'download'</em> and a parsing strategy which <em>takes elements from SAX and DOM</em> but follows neither model.</p>
<p>Implementation in Javascript gives me the widest deployment options, covering client-side browser programming, server programming, use in command line tools, or any other usage. This context dictates a design which is non-blocking, asynchronous and callback based. While influenced by the language, the model of REST client proposed here is not limited to Javascript or web usage and I intent to comment briefly also on the applicability to other platforms. Likewise, I have also chosen to focus on JSON although I will also be commenting on the parallel applicability of these ideas to XML.</p>
<p>From DOM we may observe that as a programmer, using a resource is simpler when a parsed entity is passed whole to a single callback, rather than the SAX model which requires the programmer to infer the entity from a lengthy series of callbacks. From observing SAX parsers or progressive HTML rendering, we can say that http is more efficient if we no not wait until we have everything before we start using the parts that we do have. DOM parsers pass a fully parsed node to registered callbacks, whole and ready to use, invariably at the root of the parsed document. From the vantage of the library's user, my thesis duplicates this convenience but removes one restriction; that the node which is passed must be the root. Because the mark-up formats we are dealing with are hierarchical and serialised depth-first it is possible to fully parse any sub-tree without fully knowing the parent node. From these observations we may program a new kind of REST client which is as performant as SAX but as easy to program as DOM.</p>
<p>To follow this progressive-but-complete model, identifying the interesting parts of a document involves turning the traditional model for drilling down inside-out. Traditionally the programmer's callback receives the document then inside that callback drills down to locate the parts that they are interested in. Instead I propose taking the drilling-down logic out from inside the callback and instead wrap the callback in it. This means that the callback receives selected parts of the response which the library has already drilled down to on behalf of the programmer.</p>
<p>Whilst JSONPath's existing implementation is only implemented for searching over already gathered objects, this kind of searching is just one application for the query language. I find that this is a very suitable declarative language to use to specify the parts of a response that a developer would like to drill-down to given the context of a document whose parse is in progress. JSONPath is especially applicable because it specifies only 'contained-in/contains' type relationships. On encountering any node in a serialised JSON stream, because of the depth-first serialisation order I will always have previously seen its ancestors. Hence, having written a suitably flexible JSONPath expression compiler such that it does not require a complete document, I will have enough information to evaluate any expression against any node at the time when it is first identified in the document. Because XML is also written depth-first, the same logic would apply to an XPath/XML variant of this project.</p>
<p>The definition of 'interesting' will be generic and accommodating enough so as to apply to any data domain and allow any granularity of interest, from large object to individual datums. With just a few lines of programming</p>
<div id="jsonpath-and-types" class="section level2">
<h2><a href="#jsonpath-and-types"><span class="header-section-number">4.1</span> JSONPath and types</a></h2>
<p>Given its use to identify interesting parts of a document, not all of the published JSONPath spec is useful. Parts of a document will be considered interesting because of their type, position, or both. This contrasts with filter-type queries such as 'books costing less than X'. Examining REST responses it is likely we will not be explicitly searching through a full model but rather selecting from a resource subset that the programmer requested, assembled on their behalf using their parameters so we can expect the developer to be interested in most of the content. In creating a new JSONPath implementation, I have chosen to follow the published spec only loosely, thereby avoiding writing unnecessary code. This is especially the case, as in the books example above whereby a user of the library could easily add the filter in the callback itself. Following the principle of writing less, better I feel it is better to deliver only the features I am reasonably certain will be well used but keep open the ability to add more later should it be required.</p>
<p>JSON markup describes only a few basic types. On a certain level this is also true for XML -- most nodes are of either type Elements or Text. However, the XML metamodel provides tagnames, essentially a built-in Element sub-typing mechanism. Floating above this distinction, a reader abstracting over the details of the markup may forget that a node is an Element instance and describe it as an instance of its tagname, without considering that the tagname is a sub-type of Element. JSON comes with no such built-in type description language. On top of JSON's largely typeless model we often place a concept of type. Drawing parallels with the physical world, this imposition of type is the responsibility of the observer, rather than of the observed. A document reader has a free choice of the taxonomy they will use to impose type on the parts of the document, and this decision will vary depending on the purpose of the reader. The specificity required of a taxonomy differs by the level of involvement in a field, whereas 'watch' may be a reasonable type to most data consumers, to a horologist it is unlikely to be satisfactory without further sub-types. In the scope of this dissertation, since selecting on type is desirable, my JSONPath variant must be able to distinguish types at various levels of specificity; whilst my selection language will have no inbuilt concept of type, the aim is to support programmers in creating their own.</p>
<p><em>integrate with above or discard, maybe move to compatibility with future versions</em> Relationship between type of a node and its purpose in the document (or, perhaps, the purpose the reader wishes to put it to). Purpose is often obvious from a combination of URL and type so can disregard the place in the document. This structure may be carefully designed but ultimately a looser interpretation of the structure can be safer.</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="co">&lt;!--  XML leaves no doubt as to the labels we give to the types</span>
<span class="co">      of the nodes. This is a &#39;person&#39; --&gt;</span>
<span class="kw">&lt;person</span><span class="ot">  name=</span><span class="st">&#39;...&#39;</span><span class="ot"> gender=</span><span class="st">&quot;male&quot;</span>
<span class="ot">         age=</span><span class="st">&quot;45&quot;</span><span class="ot"> height=</span><span class="st">&quot;175cm&quot;</span><span class="ot"> profession=</span><span class="st">&quot;architect&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/person&gt;</span></code></pre>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/*    JSON meanwhile provides no such concrete concept. This node&#39;s</span>
<span class="co">      type might be &#39;thing&#39;, &#39;animal&#39;, &#39;human&#39;, &#39;man&#39;, &#39;architect&#39;,</span>
<span class="co">      &#39;artist&#39; or any other of many overlapping impositions depending </span>
<span class="co">      on what purpose the document it is read for */</span>
{  <span class="st">&quot;name&quot;</span>:<span class="st">&quot;...&quot;</span>, <span class="st">&quot;gender&quot;</span>:<span class="st">&quot;male&quot;</span>, <span class="st">&quot;age&quot;</span>:<span class="st">&quot;45&quot;</span> 
   <span class="st">&quot;height&quot;</span>:<span class="st">&quot;175cm&quot;</span> <span class="st">&quot;profession&quot;</span>:<span class="st">&quot;architect&quot;</span>&gt;
}         </code></pre>
<p>In the absence of node typing beyond the categorisation as objects, arrays and various primitive types, the key immediately mapping to the object is often taken as a lose concept of the type of the object. Quite fortunately, rather than because of a well considered object design, this tends to play well with automatically marshaling of domain objects expressed in a Java-style OO language because there is a strong tendency for field names -- and by extension, 'get' methods -- to be named after the <em>type</em> of the field, the name of the type also serving as a rough summary of the relationship between two objects. See figure  below.</p>
<p>In the below example, we impose the the type 'address' because of the parent node's field name. Other than this, these are standard arrays of strings:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{
   <span class="dt">name</span>: <span class="st">&#39;...&#39;</span>
,  <span class="dt">residence</span>: {
      <span class="dt">address</span>: [
         <span class="st">&#39;...&#39;</span>, <span class="st">&#39;...&#39;</span>, <span class="st">&#39;...&#39;</span>
      ]
   }
,  <span class="dt">employer</span>: {
      <span class="dt">name</span>: <span class="st">&#39;...&#39;</span>
   ,  <span class="dt">address </span>:[
         <span class="st">&#39;...&#39;</span>, <span class="st">&#39;...&#39;</span>, <span class="st">&#39;...&#39;</span>      
      ]
   }   
}</code></pre>
<p>Although, being loosely typed, in Javascript there is no protection against using arrays to contain disparate object, by sensible convention the items will usually be of some common type. Likewise in JSON, although type is a loose concept, on some level the elements of an array will generally be of the same type. This allows a sister convention seen in the below example, whereby each of a list of items are typed according to the key in the grandparent node which maps to the array.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{
   <span class="dt">residences</span>: {
      <span class="dt">addresses</span>: [
         [<span class="st">&#39;Townhouse&#39;</span>, <span class="st">&#39;Underground street&#39;</span>, <span class="st">&#39;Far away town&#39;</span>]      
      ,  [<span class="st">&#39;Beach Hut&#39;</span>, <span class="st">&#39;Secret Island&#39;</span>, <span class="st">&#39;Bahamas&#39;</span>]
      ]
   }
}</code></pre>
<p>The pluralisation of 'address' to 'addresses' above may be a problem to a reader wishing to detect address nodes. I considered introducing an 'or' syntax for this situation, resembling <code>address|addresses.*</code> but instead decided this problem, while related to type, is simpler to solve outside of the JSONPath language. A programmer may simply use two JSONPaths mapping to the same callback function.</p>
<p>In the below example typing is trickier still.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{
   <span class="dt">name</span>: <span class="st">&#39;...&#39;</span>
,  <span class="dt">residence</span>: {
      <span class="dt">number</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">street</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;...&#39;</span> 
   }
,  <span class="dt">employer</span>:{
      <span class="dt">name</span>: <span class="st">&#39;...&#39;</span>
   ,  <span class="dt">premises</span>:[
         { <span class="dt">number</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">street</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;...&#39;</span> }
      ,  { <span class="dt">number</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">street</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;...&#39;</span> }
      ,  { <span class="dt">number</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">street</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;...&#39;</span> }
      ]
   ,  <span class="dt">registeredOffice</span>:{
         <span class="dt">number</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">street</span>:<span class="st">&#39;...&#39;</span>, <span class="dt">town</span>:<span class="st">&#39;...&#39;</span>
      }
   }
}  </code></pre>
<p>The properties holding addresses are named by the relationship between the parent and child nodes rather than the type of the child. There are two ways we may be able to select objects out as addresses. Firstly, because of an ontology which subtypes 'residence', 'premises', and 'office' as places with addresses. More simply, we may import the idea of duck typing from Python programing.</p>
<blockquote>
<p>In other words, don't check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what subset of duck-like behaviour you need to play your language-games with.</p>
</blockquote>
<p>Discussion of typing in Python language, 2000. <a href="https://groups.google.com/forum/?hl=en">https://groups.google.com/forum/?hl=en</a>#!msg/comp.lang.python/CCs2oJdyuzc/NYjla5HKMOIJ</p>
<p>A 'duck-definition' of address might be any object which has a number, street and town. That is to say, type is individualistically communicated by the object itself rather than by examining the relationships described by its containing ancestors. JSONPath comes with no such expressivity but I find this idea so simple and useful that I have decided to create one. The JSONPath language is designed to resemble programmatic Javascript access but Javascript has no syntax for a list of value-free properties. The closest available is the object literal format; my duck-type syntax is a simplification with values and commas omitted. In the case of the addresses a duck-type expression would be written as <code>{number street town}</code>. Generally, when identifying items of a type from a document it makes sense if the type expression is contravariant so that sub-types are also selected. If we consider that we create a sub-duck-type when we add to a list of required fields and super-duck-types when we remove them, we have a non-tree shaped type space with root type <code>{}</code> which matches any object. Therefore, the fields specified need not be an exhaustive list of the object's properties.</p>
<p>The various means of discerning type which are constructable need not be used exclusively. For example, <code>aaa{bbb ccc}</code> is a valid construction combining duck typing and the relationship with the parent object.</p>
</div>
<div id="jsonpath-improving-stability-over-upgrades" class="section level2">
<h2><a href="#jsonpath-improving-stability-over-upgrades"><span class="header-section-number">4.2</span> JSONPath improving stability over upgrades</a></h2>
<p><em>need to look at this an check doesn't duplicate rest of diss</em>.</p>
<ul>
<li>Use of <code>..</code> over <code>.</code></li>
<li>Keep this short. Might not need diagram if time presses.</li>
</ul>
<div class="figure">
<img src="images/placeholder.png" alt="extended json rest service that still works - maybe do a table instead " /><p class="caption">extended json rest service that still works - maybe do a table instead </p>
</div>
<p>Programming to identify a certain interesting part of a resource today should with a high probability still work when applied to future releases.</p>
<p>Requires some discipline on behalf of the service provider: Upgrade by adding of semantics only most of the time rather than changing existing semantics.</p>
<p>Adding of semantics should could include adding new fields to objects (which could themselves contain large sub-trees) or a &quot;push-down&quot; refactor in which what was a root node is pushed down a level by being suspended from a new parent.</p>
<p>why JSONPath-like syntax allows upgrading message semantics without causing problems [SOA] how to guarantee non-breakages? could publish 'supported queries' that are guaranteed to work</p>
</div>
<div id="importing-css4-selector-capturing-to-oboe-jsonpath" class="section level2">
<h2><a href="#importing-css4-selector-capturing-to-oboe-jsonpath"><span class="header-section-number">4.3</span> Importing CSS4 selector capturing to Oboe JSONPath</a></h2>
<p>Sometimes when downloading a collection of items it is less useful to be given each element individually than being kept up to date as the collection is expanded. Certain Javascript libraries such as d3.js and Angular interface more naturally with arrays of items than individual entities. To allow integration with these libraries, on receiving an array of items it is useful to be repeatedly passed the same containing array whenever a new element is concatenated onto it.</p>
<p>Expressing a 'contained in' relationship comes naturally to JSONPath, but no provision is made for a 'containing' relationship. Cascading Style Sheets, or CSS, the web's styling language has long shared this restriction but a recent proposal, currently at Editor's Draft stage <span class="citation">(Etemad and Atkins 2013)</span> provides an elegant means to cover this gap. Rather than add an explicit 'containing' relationship, the css4 proposal observes that css selectors have previously only allowed selection of the right-most of the terms given, allowing only the deepest element mentioned to be selected. This restriction is removed by allowing terms may be prefixed with <code>$</code> in order to make them capturing: in the absence of an explicitly capturing term the right-most continues to capture. Whereas <code>form.important input.mandatory</code> selects for styling mandatory inputs inside important forms, <code>$form.important input.mandatory</code> selects important forms with mandatory fields.</p>
<p>Importing the CSS4 dollar into Oboe's JSONPath should make it much easier to integrate with libraries which treat arrays as their basic unit of operation and uses a syntax which the majority of web developers are likely to be familiar with over the next few years.</p>
</div>
<div id="parsing-the-json-response" class="section level2">
<h2><a href="#parsing-the-json-response"><span class="header-section-number">4.4</span> Parsing the JSON Response</a></h2>
<p>While SAX parsers provide an unfriendly interface to application developers, as a starting point for higher-level parsers they work very well (in fact, most XML DOM parsers are made in this way). The pre-existing project Clarinet is well tested, liberally licenced and compact, meeting the goals of this project perfectly. In fact, the name of this project, Oboe.js, was chosen in tribute to the value delivered by Clarinet.</p>
</div>
<div id="api-design" class="section level2">
<h2><a href="#api-design"><span class="header-section-number">4.5</span> API design</a></h2>
<p><em>API allows body to be given as Object and converts into JSON because it is anticipated that REST services which emmit JSON will also accept it</em></p>
<p>In designing the API developer ergonomics are the top priority. This is especially pertinent given that the library does nothing that can't be done with existing tools such as JSON SAX parsers but that those tools are not used because they require too much effort to form a part of most developers' everyday toolkit.</p>
<p><em>Expose single global.</em></p>
<p>To pursue good ergonomics, I will study successful libraries and, where appropriate, copy their APIs. We may assume that the existing libraries have already over time come to refined solutions to similar problems. Working in a style similar to existing libraries also makes the library easier to learn. Lastly, if we create a library which functions similarly enough to existing tools it should be easy to modify an existing project to adopt it. In the most common use cases, it should be possible to create a library with a close functional equivalence that can be used as a direct drop-in replacement. Used in this way, no progressive loading would be done but it opens the door for the project taking up the library to be refactored towards a progressive model over time. By imitating existing APIs we allow adoption as a series of small, easily manageable steps rather than a single leap. This is especially helpful for teams wishing to adopt this project working under Scrum because all tasks must be self-contained and fit within a fairly short timeframe.</p>
<p>jQuery's basic call style for making an AJAX GET request follows:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">jQuery</span>.<span class="fu">ajax</span>(<span class="st">&quot;resources/shortMessage.txt&quot;</span>)
   .<span class="fu">done</span>(<span class="kw">function</span>( text ) {
      <span class="ot">console</span>.<span class="fu">log</span>( <span class="st">&#39;Got the text: &#39;</span> + text ); 
   }).
   .<span class="fu">fail</span>(<span class="kw">function</span>(data) {
      <span class="ot">console</span>.<span class="fu">log</span>( <span class="st">&#39;the request failed&#39;</span> );      
   });</code></pre>
<p>While for simple web applications usage is much as above,<br />In real world usage on more complex apps jQuery.ajax is often injected into the scope of the code which wants to use it. Easier stubbing so that tests don't have to make actual AJAX calls.</p>
<p>While certainly callback-based, the jQuery is somewhat implicit in being event-based. There are no event names separate from the methods which add the listeners and there are no event objects, preferring to pass the content directly. The names used to add the events (done, fail) are also generic, used for all asynchronous requests. The methods are chainable which allows several listeners to be added in one statement.</p>
<p>By method overloading, if the request requires more information than the parameter to <code>jQuery.ajax</code> may be an object. This pattern of accepting function parameters as an object is a common in Javascript for functions that take a large number of optional arguments because it makes understanding the purpose of each argument easier to understand from the callsite than if the meaning depended on the position in a linear arguments list and the gaps filled in with nulls.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">jQuery</span>.<span class="fu">ajax</span>({ <span class="dt">url</span>:<span class="st">&quot;resources/shortMessage.txt&quot;</span>,
              <span class="dt">accepts</span>: <span class="st">&quot;text/plain&quot;</span>,
              <span class="dt">headers</span>: { <span class="st">&#39;X-MY-COOKIE&#39;</span>: <span class="st">&#39;123ABC&#39;</span> }
           });</code></pre>
<p>Taking on this style,</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">oboe</span>(<span class="st">&#39;resources/someJson.json&#39;</span>)
   .<span class="fu">node</span>( <span class="st">&#39;person.name&#39;</span>, <span class="kw">function</span>(name, path, ancestors) {
      <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;got a name &quot;</span> + name);   
   })
   .<span class="fu">done</span>( <span class="kw">function</span>( wholeJson ) {
      <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;got everything&#39;</span>);
   })
   .<span class="fu">fail</span>( <span class="kw">function</span>() {
      <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;actually, the download failed. Forget the&#39;</span> + 
                  <span class="st">&#39; people I just told you about&#39;</span>);
   });</code></pre>
<p>Because I foresee several patterns being added for most types of JSON documents, a shortcut format is also available for adding multiple patterns in a single call by using the patterns as the keys and the callbacks as the values in a key/value mapping:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">oboe</span>(<span class="st">&#39;resources/someJson.json&#39;</span>)
   .<span class="fu">node</span>({  
      <span class="st">&#39;person.name&#39;</span>: <span class="kw">function</span>(personName, path, ancestors) {
         <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;let me tell you about &quot;</span> + name);
      },
      <span class="st">&#39;person.address.town&#39;</span>: <span class="kw">function</span>(townName, path, ancestors) {
         <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;they live in &quot;</span> + townName);
      }
   });</code></pre>
<p>Note the path and ancestors parameters in the examples above. Most of the time giving the callback the matching content is enough to be able to act but it is easy to imagine cases where a wider context matters. Consider this JSON:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{ 
   <span class="st">&quot;event&quot;</span>: <span class="st">&quot;mens 100m&quot;</span>,
   <span class="st">&quot;date&quot;</span>: <span class="st">&quot;5 Aug 2012&quot;</span>,
   <span class="st">&quot;medalWinners&quot;</span>: {
      <span class="st">&quot;gold&quot;</span>:     {<span class="st">&quot;name&quot;</span>: <span class="st">&#39;Bolt&#39;</span>,    <span class="st">&quot;time&quot;</span>: <span class="st">&quot;9.63s&quot;</span>},
      <span class="st">&quot;silver&quot;</span>:   {<span class="st">&quot;name&quot;</span>: <span class="st">&#39;Blake&#39;</span>,   <span class="st">&quot;time&quot;</span>: <span class="st">&quot;9.75s&quot;</span>},
      <span class="st">&quot;bronze&quot;</span>:   {<span class="st">&quot;name&quot;</span>: <span class="st">&#39;Gatlin&#39;</span>,  <span class="st">&quot;time&quot;</span>: <span class="st">&quot;9.79s&quot;</span>}
   }
}  </code></pre>
<p>Here we can extract the runners by the patterns such as <code>{name time}</code> or <code>medalWinners.*</code> but clearly the location of the node in the document is interesting as well as the context. The <code>path</code> parameter provides this information by way of an array of strings plotting the descent from the JSON root to the match, for example <code>['medalWinners', 'gold']</code>. Similarly, the <code>ancestors</code> array is a list of the ancestors starting at the immediate parent of the found node and ending with the JSON root node. For all but the root node (which has no ancestors anyway) the nodes in this list will be only partially parsed. Being untyped, Javascript does not enforce the arity of the callback. Because much of the time only the content itself is needed, the API design orders the callback parameters to take advantage of the loose typing so that a unary function taking only the content may be given.</p>
<p>For the widest context currently available, the whole document as it has been parsed so far may be accessed using the <code>.root</code> method. Since <code>.root</code> relates to the oboe instance itself rather than the callback per-say, it can be accessed from any code with a reference to the oboe object.</p>
<p><code>http://nodejs.org/docs/latest/api/events.html#events_emitter_on_event_listener</code></p>
<p>In node.js the code style is more obviously event-based. Listeners are added via a <code>.on</code> method with a string event name given as the first argument. Adopting this style, my API design for oboe.js also allows events to be added as:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">oboe</span>(<span class="st">&#39;resources/someJson.json&#39;</span>)
   .<span class="fu">on</span>( <span class="st">&#39;node&#39;</span>, <span class="st">&#39;medalWinners.*&#39;</span>, <span class="kw">function</span>(person, path, ancestors) {
      <span class="ot">console</span>.<span class="fu">log</span>( <span class="ot">person</span>.<span class="fu">name</span> + <span class="st">&#39; won the &#39;</span> + <span class="fu">lastOf</span>(path) + <span class="st">&#39; medal&#39;</span> );
   });</code></pre>
<p>While allowing both styles uncountably creates an API which is larger than it needs to be, creating a library which is targeted at both the client and server side, I hope this will help adoption by either camp. The Two styles are similar enough that a person familiar with one should be able to pick up the other without difficulty. In implementation a duplicative API should require only a minimal degree of extra coding because these parts may be expressed in common and their scope reduced using partial completion. Because <code>'!'</code> is the JSONPath for the root of the document, for some callback c, <code>.done(c)</code> is a synonym for <code>.node('!', c)</code> and therefore below a thin interface layer may share an implementation. Likewise, <code>.node</code> is easily expressible as a partial completion of <code>.on</code> with <code>'node'</code>.</p>
</div>
<div id="earlier-callbacks-when-paths-are-matched" class="section level2">
<h2><a href="#earlier-callbacks-when-paths-are-matched"><span class="header-section-number">4.6</span> Earlier callbacks when paths are matched</a></h2>
<p>Following with the project's aim of giving callbacks as early as possible, sometimes useful work can be done when a node is known to exist but before we have the contents of the node. This means that each node found in a JSON document has the potential to trigger notifications at two points: when it is first discovered and when it is complete. The API facilitates this by providing a <code>path</code> callback following much the same pattern as the <code>node</code> callback.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">oboe</span>(<span class="st">&#39;events.json&#39;</span>)
   .<span class="fu">path</span>( <span class="st">&#39;medalWinners&#39;</span>, <span class="kw">function</span>() {
      <span class="co">// We don&#39;t know the winners yet but we know we have some so let&#39;s</span>
      <span class="co">// start drawing the table already:    </span>
      <span class="kw">interface</span>.<span class="fu">showMedalTable</span>();
   })
   .<span class="fu">node</span>( <span class="st">&#39;medalWinners.*&#39;</span>, <span class="kw">function</span>(person, path) {    
      <span class="kw">interface</span>.<span class="fu">addPersonToMedalTable</span>(person, <span class="fu">lastOf</span>(path));
   })
   .<span class="fu">fail</span>( <span class="kw">function</span>(){
      <span class="co">// That didn&#39;t work. Revert!</span>
      <span class="kw">interface</span>.<span class="fu">hideMedalTable</span>();
   });</code></pre>
<p>In implementation providing path notifications is a simple matter of allowing the evaluation of the json path expressions when items are pushed to the stack of current nodes in addition to when they are popped.</p>
</div>
<div id="oboe.js-as-a-micro-library" class="section level2">
<h2><a href="#oboe.js-as-a-micro-library"><span class="header-section-number">4.7</span> Oboe.js as a Micro-Library</a></h2>
<p>Http traffic, especially sending entropy-sparse text formats is often gzipped at point of sending in order to deliver it more quickly, so in measuring a download footprint it usually makes more sense to compare post-gzipping. A Javascript library qualifies as being <em>micro</em> if it is delivered in 5k or less, 5120 bytes. Micro-libraries also tend to follow the ethos that it is better for a developer to gather together several tiny libraries than one that uses a one-size-fits-all approach, perhaps echoing the unix command line tradition of small programs which each do do exactly one thing. Javascript Micro-libraries are listed at,<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> which includes this project. Oboe.js feels on the edge of what is possible to elegantly do as a micro-library so while the limit is somewhat arbitrary, for the sake of adoption smaller is better and keeping below this limit whilst writing readable code is an interesting challenge. As well as being a small library, in the spirit of a micro-library a project should impose as few restrictions as possible on its use and be designed to be completely agnostic as to which other libraries or programming styles that it is used with.</p>
</div>
<div id="handling-transport-failures" class="section level2">
<h2><a href="#handling-transport-failures"><span class="header-section-number">4.8</span> Handling transport failures</a></h2>
<p>Oboe should allow requests to fail while the response is being received without necessarily losing the part that was successfully received.</p>
<p>Researching error handing, I considered the option of automatically resuming failed requests without intervention from the containing application. Http 1.1 provides a mechanism for Byte Serving via the <code>Accepts-Ranges</code> header [<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>#sec14.5] which is used to request any contiguous fragment of a resource -- in our case, the part that we missed when the download failed. Having examined this option I came to the conclusion that it would encourage brittle systems because it assumes two requests to the same URL will give byte-wise equal responses.</p>
<p>A deeper problem is that Oboe cannot know the correct behaviour when a request fails so this is better left to the containing applications. Generally on request failure, two behaviours may be anticipated. If the actions performed in response to data received up to time of failure remain valid in the absence of a full transmission, their effects may be kept and a URL may be constructed to request just the lost part. Alternatively, under optimistic locking, the application developer may choose to perform rollback. In either case, responding to errors beyond informing the calling application is outside of Oboe's scope.</p>
<p>IO errors in a non-blocking system cannot be handled via exception throwing because the call which will later cause an error will no longer be on the stack at the time that the error occurs. Error-events will be used instead.</p>
</div>
<div id="fallback-support-on-less-capable-platforms" class="section level2">
<h2><a href="#fallback-support-on-less-capable-platforms"><span class="header-section-number">4.9</span> Fallback support on less-capable platforms</a></h2>
<p><em>something about market share and link to figures in an appendix?</em></p>
<p>Because of differences in the capabilities in browsers, providing a streaming REST client is not possible on all browsers. If this were possible, it would not have been necessary to invent push pages or long polling. Specifically, none but the most recent versions of Internet Explorer provide any way to access an AJAX response before it is complete. I have taken the design decision that it is ok to degrade on these platforms so long as the programmer developing with Oboe.js does not have to make special cases for these platforms. Likewise, nor should the REST service need be aware of the client, disallowing detecting client capabilities and switching transport strategy. Requiring branching on either side places extra responsibilities on the programmer which they would not otherwise be required to consider whilst viewing REST through a non-streaming lens.</p>
<p>Given that streaming is not possible on older platforms, I must considering the best experience that is possible. We may imagine a situation in which the whole download completes followed by all listeners being notified from a single Javascript frame of execution. While not progressive in any way, this situation is essentially standard REST plus JSONPath routing and no less performant than if more traditional libraries were used. I find this satisfactory: for the majority of users the experience is improved and for the others it is made no worse, resulting in a net overall benefit.</p>
<p>In the Javascript language itself interoperability is very rarely an issue. Javascript's model of prototypical inheritance allows changes to be made to the browser's libraries on the fly; as soon as a prototype is changed all instances of the type reflect the change even if they has already been created (source). Because the base types that come with the browser are essentially global, changing them for the use of a single codebase is generally deprecated because of the possibility of collisions. However, this technique is often used to retrofit new standards onto older platforms. For example, the Functional-style Array iteration methods remove the need to write C-style for loops and are defined in the ECMAScript 5 specification <a href="http://www.jimmycuadra.com/posts/ecmascript-5-array-methods">http://www.jimmycuadra.com/posts/ecmascript-5-array-methods</a> - all of these methods are implementable in pure Javascript. There exist several mature pure Javascript projects for browsers which lack native support, licenced to allow inclusion in this project (CITE ONE). While I am constrained in the ability to accept streaming AJAX in older browsers, there is no such restriction on my ability to express my thesis in a more modern, functional style of Javascript.</p>
<p>Node is highly capable, with no shortcomings that will make Oboe.js difficult to implement. It does, however use its own stream API rather than emulate the browser API so will require platform-specific programming inside the library. This abstraction will be hidden from the library user so will not require any special programming on their part.</p>
</div>
</div>
<div id="implementation" class="section level1">
<h1><a href="#implementation"><span class="header-section-number">5</span> Implementation</a></h1>
<div id="components-of-the-project" class="section level2">
<h2><a href="#components-of-the-project"><span class="header-section-number">5.1</span> Components of the project</a></h2>
<div class="figure">
<img src="images/overallDesign.png" alt="Major components that make up Oboe.js illustrating program flow from http transport to registered callbacks. Every component is not shown here. Particularly, components whose responsibility it is to initialise the oboe instance but have no role once it is running are omitted. UML facet/receptacle notation is used to show the flow of events with event names in capitals. " /><p class="caption"><strong>Major components that make up Oboe.js</strong> illustrating program flow from http transport to registered callbacks. Every component is not shown here. Particularly, components whose responsibility it is to initialise the oboe instance but have no role once it is running are omitted. UML facet/receptacle notation is used to show the flow of events with event names in capitals. </p>
</div>
<p>Oboe's architecture has been designed to so that I may have as much confidence as possible regarding the correct working of the library through automated testing. Designing a system to be amenable to testing in this case meant splitting into many co-operating parts each with an easily specified remit.</p>
<p>Internally, communication between components is facilitated by an event bus which is local to to Oboe instance. Most components interact solely by picking up events, processing them and publishing further events in response. Essentially, Oboe's architecture resembles a fairly linear pipeline visiting a series of units, starting with http data and sometimes ending with callbacks being notified. This use of an event bus is a variation on the Observer pattern which removes the need for each unit to obtain a reference to the previous one so that it may observe it, giving a highly decoupled shape to the library. Once everything is wired into the bus very little central control is required and the larger behaviours emerge as the consequence of this interaction between finer ones. One downside is perhaps that a central event bus does not lend itself to a UML class diagram, giving a diagram shape with an event bus as a central hub and everything else hanging off it as spokes.</p>
</div>
<div id="automated-testing" class="section level2">
<h2><a href="#automated-testing"><span class="header-section-number">5.2</span> Automated testing</a></h2>
<p>Automated testing improves what can be written, not just making what is written more reliable. Tests deal with the problem of &quot;irreducible complexity&quot; - when a program is made out of parts whose correct behaviour cannot be observed without all of the program. Allows smaller units to be verified before verifying the whole.</p>
<div class="figure">
<img src="images/testPyramid.png" alt="The test pyramid. Relying on the assumption that verification of small parts provides a solid base from which to compose system-level behaviours. A Lot of testing is done on the low-level components of the system, less on the component level and less still on a whole-system level where only smoke tests are provided. " /><p class="caption"><strong>The test pyramid</strong>. Relying on the assumption that verification of small parts provides a solid base from which to compose system-level behaviours. A Lot of testing is done on the low-level components of the system, less on the component level and less still on a whole-system level where only smoke tests are provided. </p>
</div>
<p>The testing itself is a non-trivial undertaking with 80% of code written for this project being test specifications. Based on the idea that a correct system must be built from individually correct units, the majority of the specifications are unit tests, putting each unit under the microscope and describing the correct behaviour as completely as possible. Component tests zoom out from examining individual components to focus on their correct composition, falsifying only the http traffic. To avoid testing implementation details the component tests do not look at the means of coupling between the code units but rather check for the behaviours which should emerge as a consequence of their composition. At the apex of the test pyramid are a small number of integration tests. These verify Oboe as a black box without any knowledge of, or access to the internals, using only the APIs which are exposed to application programmers. When running the integration tests a REST service is first spun up so that correctness of the whole library may be examined against an actual server.</p>
<p>The desire to be amenable to testing influences the boundaries on which the application splits into components. Confidently black box testing a stateful unit as is difficult; because of side-effects it may later react differently to the same calls. For this reason where state is required it is stored in very simple state-storing units with intricate program logic removed. The logic may then be separately expressed as functions which map from one state to the next. Although comprehensive coverage is of course impossible and tests are inevitably incomplete, for whatever results the functions give while under test, uninfluenced by state I can be sure that they will continue to give in any future situation. The separate unit holding the state is trivial to test, having exactly one responsibility: to store the result of a function call and later pass that result to the next function. This approach clearly breaks with object oriented style encapsulation by not hiding data behind the logic which acts on them but I feel the departure is worthwhile for the greater certainty it allows over the correct functioning of the program.</p>
<p>Dual-implementation of same interface for streamingHttp might be considered polymorphism, but a function not a class and both are never loaded at run time.</p>
<p>Largely for the sake of testing Oboe has also embraced dependency injection. This means that components do not create the further components that they require but rather rely on them being provided by an external wiring. The file <code>wire.js</code> performs the actual injection. One such example is the streamingHttp component which hides various incompatible http implementations by publishing their downloaded content progressively via the event bus. This unit does not know how to create the underlying browser XHR which it hides. Undoubtedly, by not instantiating its own dependencies a it presents a less friendly interface, although this is mitigated somewhat by the interface being purely internal, the objects it depends on are no longer a hidden implementation detail but exposed as a part of the component's API. The advantage of dependency injection here is that unit testing is much simpler. Unit tests should test exactly one behaviour of one unit. Were the streaming http object to create its own transport, that part would also be under test, plus whichever external service that it connects to. Because Javascript allows redefinition of built in types, this could be avoided by overwriting the XHR constructor to return a mock but modifying the built in types for tests opens up the possibilities of changes leaking between cases. Dependency injection allows a much simpler test style because it is trivial to inject a stub in place of the XHR.</p>
<p>Integration tests run against a node service which returns known content according to known timings, somewhat emulating downloading via a slow internet connection. For example, the url <code>/tenSlowNumbers</code> writes out a JSON array of the first ten natural numbers at a rate of one per second, while <code>/echoBackHeaders</code> writes back the http headers that it received as a JSON object. The test specifications which use these services interact with Oboe through the public API alone as an application author would and try some tricky cases. For example, requesting ten numbers but registering a listener against the fifth and aborting the request on seeing it. The correct behaviour is to get no callback for the sixth, even when running on platforms where the http is buffered so that all ten will have already been downloaded. <em>ref apx for streamsource</em></p>
</div>
<div id="running-the-tests" class="section level2">
<h2><a href="#running-the-tests"><span class="header-section-number">5.3</span> Running the tests</a></h2>
<div class="figure">
<img src="images/placeholder.png" alt="Relationship between various files and test libraries other half of sketch from notebook" /><p class="caption"><strong>Relationship between various files and test libraries</strong> <em>other half of sketch from notebook</em></p>
</div>
<p>The Grunt task runner was used to automate routine tasks such as executing the tests and building. Unit and component tests run automatically whenever a source file changes. As well as being correct execution, the project is required to not surpass a certain size so the built size is also checked. As a small, tightly focused project the majority of programming is refactoring already working code. Running tests on save provides quick feedback so that mistakes are found as soon as they are made. Agile practitioners emphasise the importance of tests that execute quickly <span class="citation">(Martin 2008, T9)</span>, the 220 unit and component tests run in less than a second so discovering mistakes is near instant. If the &quot;content of any medium is always another medium” <span class="citation">(McLuhan 1964 p8)</span>, we might say that the content of programming is the program that is realised by its execution. A person working in arts and crafts sees the thing as they work but a programmer will usually not see the execution simultaneously as they program. Conway observed that an artisan works by transform-in-place &quot;start with the working material in place and you step by step transform it into its final form&quot; whereas software is created through intermediate proxies, and attempts to close this gap by merging programming with the results of programming <span class="citation">(Conway 2004 side8-9)</span>. When we bring together the medium and the message the cost of small experimentation is very low and I feel that programming becomes more explorative and expressive.</p>
<p>The integration tests are not run on save because they intentionally simulate slow transfers and take some time to run. The integration tests are used as a final check against built code before a branch in git can be merged into the master. Once the code has been packaged for distribution the internals are no longer visible the integration tests which are coded against the public API are the only runnable tests. While these tests don't individually test every component, they are designed to exercise the whole codebase so that a mistake in any component will be visible through them. Grunt executes the build, including starting up the test REST services that give the integration tests something to fetch.</p>
</div>
<div id="packaging-as-a-single-distributable-file" class="section level2">
<h2><a href="#packaging-as-a-single-distributable-file"><span class="header-section-number">5.4</span> Packaging as a single, distributable file</a></h2>
<div class="figure">
<img src="images/placeholder.png" alt="Packaging of many javascript files into multiple single-file packages. The packages are individually targeted at different execution contexts, either browsers or node get from notebook, split sketch diagram in half" /><p class="caption"><strong>Packaging of many javascript files into multiple single-file packages.</strong> The packages are individually targeted at different execution contexts, either browsers or node <em>get from notebook, split sketch diagram in half</em></p>
</div>
<p>As an interpreted language, Javascript may of course be ran directly without any prior compilation. While running the same code as I see in the editor is convenient while programming, it is much less so for distribution. Although the languages imposes no compulsory build phase, in practice one is necessary. Dependency managers have not yet become standard for client-side web development (although Bower is looking good) so most files are manually downloaded. For a developer wishing to include my library in their own project a single file is much more convenient. Should they not have a build process of their own, a single file is also much faster to transfer to their users, mostly because of the cost of establishing connections and the http overhead.</p>
<p>Javascript files are interpreted in series by the browser so load-time dependencies must precede dependants. Unsurprisingly, separate files once concatenated following the same order as delivered to the browser will load more quickly but are functionally equivalent, at least barring syntax errors. Several tools exist to automate this stage of the build process, incorporating a topological sort of the dependency digraph in order to find a working concatenation order.</p>
<p>Early in this project I chose <em>Require.js</em> although I later moved on because it was too heavyweight. Javascript as a language doesn't have an import statement. Require contributes the importing ability to Javascript from inside the language sandbox as the <code>require</code> function, a standard asynchronous call. Calls to <code>require</code> AJAX in and execute the imported source, returning any exported symbols by a callback. For non-trivial applications this mode is intended mostly for debugging; because a network hop is involved the protocol is chatty and slowed by highly latent calls between modules. For efficient delivery Require also has the <code>optimise</code> command which concatenates into a single file by using static analysis to deduce a workable source order. Because <code>require</code> may appear anywhere in the source, this in the general case is of course undecidable so Require falls back to lazy loading. In practice undecidability isn't a problem because imports are generally not subject to branching. In larger webapps lazy loading speeding up the initial page load and is actually an advantage. The technique of <em>Asynchronous Module Definition</em> (AMD) intentionally imports rarely-loaded modules in response to events. By resisting the static analysis the units will not be downloaded until they are needed.</p>
<p>AMD is mostly of interest to web applications with a central hub but also some rarely used parts. Oboe does not fit this profile: everybody who uses it will use all of the library. Regardless, I hoped to use <code>optimise</code> to generate my combined Javascript file. Even after optimisation, Require's design necessitates that calls to <code>require</code> stay in the code and that the require.js run-time component is available to handle these calls. For a micro-library a ???k overhead was too large to accommodate. Overall, Require seems more suited to developing stand-alone applications than programming libraries.</p>
<p>Having abandoned Require, I decided to pick up the simplest tool which could possibly work. With only 15 source files and a fairly sparse dependency graph finding a working order on paper wasn't a daunting task. Combined with a Grunt analogue to the unix <code>cat</code> command I quickly had a working build process. I adjusted each Javascript file to, when loaded directly, place its API in the global namespace, then post-concatenation wrapped the combined in a single function, converting the APIs inside the function from global to the scope of that function, thereby hiding the implementation for code outside of Oboe.</p>
<p>For future consideration there is Browserify. This library reverses the 'browser first' image of Javascript by converting applications targeted at Node into a single file efficiently packaged for delivery to a web browser, conceptually making Node the primary environment for Javascript and adapting browser execution to match. Significantly, require leaves no trace of itself in the concatenated Javascript other than Adaptors presenting browser APIs as the Node equivalents. Browserify's http adaptor<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup> is complete but more verbose compared to Oboe's version<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup>.</p>
<p>As well as combining into a single file, Javascript source can made significantly smaller by removing comments and reducing inaccessible tokens to a single character. For Oboe the popular library <em>Uglify</em> is used for minification. Uglify performs only surface optimisations, operating on the AST level but concentrating mostly on compact syntax. I also considered Google's Closure compiler. Closure resembles a traditional compiler optimiser by leveraging a deeper understanding to search for smaller representations, unfortunately at the cost of safety. Decidability in highly dynamic languages is often impossible and Closure operates on a well-advised subset of Javascript, delivering no reasonable guarantee of equivalence when code is not written as the Closure authors expected. Integration tests should catch any such failures but for the time being I have a limited appetite for a workflow which forces me to be suspicious of the project's build process.</p>
</div>
<div id="styles-of-programming" class="section level2">
<h2><a href="#styles-of-programming"><span class="header-section-number">5.5</span> Styles of Programming</a></h2>
<p>The implementation of Oboe is mixed paradigm. Events flow throughout the whole library but in terms of code style the components are a mix of procedural, functional and object-oriented programming. Object orientation is used only to wrap the library in an Object-oriented public API and as a tuple-like store for multiple values. Constructors are not used, nor is there any inheritance or notable polymorphism. Closures, not objects, are used as the primary means of data storage and hiding. Many of the entities painted in figure  map onto no single, addressable language construct and exist only as a set of event handlers trapped inside the same closure, taking advantage of the fact that their reachability from some event emitter prevents required parameters from being garbage collected. From outside the closure hidden values are not only private as would be seen in an OO model, they are inherently unaddressable. Although only sparingly OO, the high-level design's componentisation hasn't departed from how it might be implemented in an OO metamodel and Object Oriented design patterns remain influential despite being only loosely followed.</p>
<p>Because of the pressures on code size I decided not to use a general purpose functional library and instead create my own with only the parts that I need; see functional.js. Functional programming in Javascript is known to be slower than other styles, particularly under Firefox because it lacks Lambda Lifting and other similar optimisations <span class="citation">(Guo 2013)</span>. Considering to what degree performance concerns should dissuade us from a functional style, we may consider the library's execution context. Because of the single-threaded model any application's Javascript execution is in between frames serving concurrent concerns so to minimise the impact on latency for the other tasks it is important that no task occupies the CPU for very long. On the browser about 16ms is a fair maximum, allowing painting to occur at 60 frames per second. In Node there is no hard limit but any CPU-hogging task degrades the responsiveness of other responses. Context switching imposes a very low overhead and responsive sharing generally proffers many small frames over a few larger ones. In any case, server-side tasks especially are more often i/o bound than CPU bound. Oboe's progressive design naturally splits tasks which would otherwise be performed in a single frame over many. For example, parsing and marshaling. Although the overall computation may be higher, the total performance of the system should be improved.</p>
<p>Javascript is of course an imperative language but over many iterations Oboe has tended towards a declarative style. In incrementalContentBuilder.js programming was initially stateful and procedural, reading like the instructions to perform a task. Over many refactors the flavour of the code has changed, the reading now tending towards a description of desired behaviour.</p>
</div>
<div id="incrementally-building-up-the-content" class="section level2">
<h2><a href="#incrementally-building-up-the-content"><span class="header-section-number">5.6</span> Incrementally building up the content</a></h2>
<p>As shown in figure , there is an incremental content builder and ascent tracer which handle the output from the Clarinet JSON SAX parser. Taken together, these might be considered a variant of the Adaptor pattern, providing to the controller a simpler interface than is presented by Clarinet. However, this is not the model implementation of the pattern; the adapted interface is even-driven rather than call-driven: we receive six kinds of event and in response emmit from a narrower vocabulary of two.</p>
<p>To evaluate JSONPath expressions the controller requires a path to the current JSON node, the node itself, and any ancestor nodes. This is delivered by the incremental content builder as the payload of the NODE_FOUND and PATH_FOUND events. For each Clarinet event the builder provides a corresponding function which, working from the current path, returns the next path after the event has been applied. For example, the <code>objectopen</code> and <code>arrayopen</code> events move the current node deeper in the document and are handled by adding new items to the path, whereas for <code>closeobject</code> and <code>closearray</code> we remove one. Over the course of parsing a complete JSON file the path will in this way be manipulated to visit every node, allowing each to be tested against the registered JSONPath expressions. Internally, the builder's event handlers are declared as the combination of a smaller number of basic reusable handler parts. Oboe is largely unconcerned regarding a JSON node's type so given that several of the Clarinet events differ only by the type of the nodes they announce, Oboe is able to generify their handling by composing from a common pool of handler-parts. Picking up <code>openobject</code> and <code>openarray</code> events, both fall through to the same 'nodeFound', differing only in a parameter. Similarly, consider the <code>value</code> event which is fired when Clarinet encounters a String or Number. Because primitive nodes are always leaves the builder regards this as a node which instantaneously starts and ends, handled programmatically as the functional composition of the <code>nodeFound</code> and <code>curNodeFinished</code>. The reuse of smaller instructions to build up larger ones is perhaps slightly reminiscent of CISC CPU design in which micro-instructions are combined to implement the chip's advertised interface.</p>
<p>Although the builder functions are stateless, ultimately the state regarding the current path needs to be stored between clarinet calls. This is handled by the ascent tracker. This tiny component merely serves as a holder for this data, starting from an empty path it passes the path to each builder function and stores the result to be given to the next one.</p>
<div class="figure">
<img src="images/ascent.png" alt="List representation of an ascent from leaf to root of a JSON tree. Note the special ROOT token which represents the path mapping to the root node (of course nothing maps to the root) - this is an object, taking advantage of object identity to ensure that the token is unequal to anything but itself. This list form is built up by the incremental content builder and is the format that compiled JSONPath expressions test against for matches " /><p class="caption">List representation of an ascent from leaf to root of a JSON tree. Note the special ROOT token which represents the path mapping to the root node (of course nothing maps to the root) - this is an object, taking advantage of object identity to ensure that the token is unequal to anything but itself. This list form is built up by the incremental content builder and is the format that compiled JSONPath expressions test against for matches </p>
</div>
<p>The path of the current node is maintained as a singly linked list, with each list element holding the field name and the node and the node itself, see figure . The list is arranged with the JSON root at the far end and the current node at the head. As we traverse the JSON the current node is appended and removed many times whereas the root is immutable. This ordering was chosen because it is computationally very efficient since all updates to the list are at the head. Each link in the list is immutable, enforced by newer Javascript engines as frozen objects.<sup><a href="#fn6" class="footnoteRef" id="fnref6">6</a></sup></p>
<p>Linked lists were chosen in preference to the more conventional approach of using native Javascript Arrays for several reasons. Firstly, I find this area of the program more easy to test and debug given immutable data structures. Handling native Arrays without mutating would be very expensive because on each new path the array would have to be copied rather than edited in-place. Unpicking a stack trace is easier if I know that every value revealed is the value that has always occupied that space because I don't have to think four-dimensionally projecting my mind forwards and back in time to different values that were there when the variable was used. The lack of side effects means I can try explore new commands in the debugger's CLI without worrying about breaking the execution of the program. Most Javascript virtual machines are also quite poor at array growing and shrinking so for collections whose size changes often are outperformed by linked lists. Finally, this is a very convenient format for the JSONPath engine to perform matching on as will be discussed in the next section. The Javascript file lists.js implements the list functions: <code>cons</code>, <code>head</code>, <code>tail</code>, <code>map</code>, <code>foldR</code>, <code>all</code>.</p>
<p>Because it is more common to quote paths as descents rather than ascent, on the boundary to the outside world Oboe reverses the order and, because Javascript programmers will not be familiar with this structure, converts to arrays.</p>
</div>
<div id="oboe-jsonpath-implementation" class="section level2">
<h2><a href="#oboe-jsonpath-implementation"><span class="header-section-number">5.7</span> Oboe JSONPath Implementation</a></h2>
<p>Not surprisingly given its importance, the JSONPath implementation is one of the most refactored and considered parts of the Oboe codebase. Like many small languages, on the first commit it was little more than a series of regular expressions<sup><a href="#fn7" class="footnoteRef" id="fnref7">7</a></sup> but has slowly evolved into a featureful and efficient implementation<sup><a href="#fn8" class="footnoteRef" id="fnref8">8</a></sup>. The extent of the rewriting was possible because the correct behaviour is well defined by test specifications<sup><a href="#fn9" class="footnoteRef" id="fnref9">9</a></sup>.</p>
<p>The JSONPath compiler exposes a single higher-order function to the rest of Oboe. This function takes a JSONPath as a String and, proving it is a valid expression, returns a function which tests for matches to the JSONPath. Both the compiler and the functions that it generates benefit from being stateless. The type of the compiler, expressed as Haskell syntax would be:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Ascent</span> <span class="ot">-&gt;</span> <span class="dt">JsonPathMatchResult</span></code></pre>
<p>The match result is either a failure to match, or a hit, with the node that matched. In the case of path matching, the node may currently be unknown. If the pattern has a clause prefixed with <code>$</code>, the node matching that clause is captured and returned as the result. Otherwise, the last clause is implicitly capturing.</p>
<p>The usage profile for JSONPath expressions in Oboe is to be compiled once and then evaluated many times, once for each node encountered while parsing the JSON. Because matching is performed perhaps hundreds of times per file the most pressing performance consideration is for matching to execute quickly, the time required to compile is relatively unimportant. Oboe's JSONPath design contrasts with JSONPath's reference implementation which, because it provides a first order function, freshly reinterprets the JSONPath string each time it is invoked.</p>
<p>The compilation is performed by recursively by examining the left-most side of the string for a JSONPath clause. For each kind of clause there is a function which matches ascents against that clause, for example by checking the name field. By partial completion this function is specialised to match against one particular name. Once a clause function is generated, compilation recurs by passing to itself the remaining unparsed portion of the JSONPath string. This continues until it is called with a zero-length JSONPath. On each recursive call the clause function is wrapped in the result from the next recursive call, resulting ultimately in a linked series of clause functions. When evaluated against an ascent, each clause functions examines the head of the ascent and passes the ascent onto the next function if it passes. A special clause functions, <code>skip1</code> is used for the <code>.</code> syntax and places no condition on the head of the ascent but passes on to the next clause only the tail, thus moving evaluation of the ascent one node up the parsed JSON tree. Similarly, there is a <code>skipMany</code> which maps onto the <code>..</code> syntax and recursively consumes nodes until it can find a match in the next clause.</p>
<p>JsonPath implementation allows the compilation of complex expressions into an executable form, but each part implementing the executable form is locally simple. By using recursion, assembling the simple functions into a more function expressing a more complex rule also follows as being locally simple but gaining a usefully sophisticated behaviour through composition of simple parts. Each recursive call of the parser identifies one token for non-empty input and then recursively digests the rest.</p>
<p>As an example, the pattern <code>!.$person..{height tShirtSize}</code> once compiled would roughly resemble the Javascript functional representation below:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">statementExpr</span>(             <span class="co">// wrapper, added when JSONPath is zero-length </span>
   <span class="fu">duckTypeClause</span>(         <span class="co">// token 6, {height tShirtSize}</span>
      <span class="fu">skipMany</span>(            <span class="co">// token 5, &#39;..&#39;  </span>
         <span class="fu">capture</span>(          <span class="co">// token 4, css4-style &#39;$&#39; notation</span>
            <span class="fu">nameClause</span>(    <span class="co">// token 3, &#39;person&#39;</span>
               <span class="fu">skip1</span>(      <span class="co">// token 2, &#39;.&#39;  </span>
                  rootExpr <span class="co">// token 1, &#39;!&#39; at start of JSONPath expression</span>
               ) 
            <span class="st">&#39;person&#39;</span> )
         )
   ), [<span class="st">&#39;height&#39;</span>, <span class="st">&#39;tShirtSize&#39;</span>])
)      </code></pre>
<p>Since I am only using a side-effect free subset of Javascript for this segment of Oboe it would be safe to use a functional cache. As well as saving time by avoiding repeated execution, this could potentially also save memory because where two JSONPath strings contain a common start they could share the inner parts of their functional expression. Although Javascript doesn't come with functional caching, it can be added using the language itself.<sup><a href="#fn10" class="footnoteRef" id="fnref10">10</a></sup> I suspect, however, that hashing the parameters might be slower than performing the matching. Although the parameters are all immutable and could in theory be hashed by object identity, in practice there is no way to access an object id from inside the language so any hash of a node parsed out of JSON would have to walk the entire subtree rooted from that node.</p>
<p>The JSONPath tokenisation is split out into its own file and separately tested. The tokenisation implementation is based on regular expressions, they are the simplest form able to express the clause patterns. The regular expressions are hidden to the outside the tokenizer and only functions are exposed to the main body of the compiler. The regular expressions all start with <code>^</code> so that they only match at the head of the string. A more elegant alternative is the 'y'<sup><a href="#fn11" class="footnoteRef" id="fnref11">11</a></sup> flag but as of now this lacks wide browser support.</p>
<p>By verifying the tokens through their own unit tests it is simpler to thoroughly specify the tokenisation, producing simpler failure messages than if it were done through the full JSONPath engine. We might consider the unit test layer of the pyramid (figure ) is further split into two sub-layers. Arguably, the upper of these sub-layer is not a unit test because it is verifying two units together. There is some redundancy with the tokens being tested both individually and as full expressions. I maintain that this is the best approach regardless because stubbing out the tokenizer functions would be a considerable effort and would not improve the rigor of the JSONPath specification.</p>
<div class="figure">
<img src="images/placeholder.png" alt="Some kind of diagram showing jsonPath expressions and functions partially completed to link back to the previous function. Include the statementExpr pointing to the last clause" /><p class="caption">Some kind of diagram showing jsonPath expressions and functions partially completed to link back to the previous function. Include the statementExpr pointing to the last clause</p>
</div>
</div>
</div>
<div id="conclusion" class="section level1">
<h1><a href="#conclusion"><span class="header-section-number">6</span> Conclusion</a></h1>
<div id="benchmarking-vs-non-progressive-rest" class="section level2">
<h2><a href="#benchmarking-vs-non-progressive-rest"><span class="header-section-number">6.1</span> Benchmarking vs non-progressive REST</a></h2>
<p>I feel it is important to experimentally answer the question, <em>is this actually any faster?</em>. To do this I have created a small benchmarking suite that runs under Node.js. I chose Node because it at its code is a very basic platform which I feel it gives a more repeatable environment than modern browsers which at during the tests could be performing any number of background tasks. These tests may be seen in the <code>benchmark</code> folder of the project. Node also has the advantage in measuring the memory of a running process is not swamped by the memory taken up by the browser itself.</p>
<p>One of the proposed advantages of progressive REST is an improved user experience because of earlier, more progressive interface rendering and a perceptual improvement in speed. I am not focusing on this area for benchmarking because it would be much more difficult to measure, involving human participants. While I can't provide numbers on the perceptual improvements, I have created sites using Oboe and the improvement in responsiveness over slower networks is large enough to be obvious.</p>
<p>The benchmark mimics a relational database-backed REST service. Relational databases serve data to a cursor one tuple at a time. The simulated service writes out twenty tuples as JSON objects, one every ten milliseconds. To simulate network slowness, Apple's <em>Network Line Conditioner</em> was used. I chose the named presets &quot;3G, Average Case&quot; and &quot;Cable modem&quot; to represent poor and good networks respectively.<sup><a href="#fn12" class="footnoteRef" id="fnref12">12</a></sup> Each test involves two node processes, one acting as the client and one as the server, with data transfer between them via normal http.</p>
<p>Memory was measured using Node's built in memory reporting tool, <code>process.memoryusage()</code> and the maximum figure returned on each run was taken</p>
<p>Each object in the returned JSON contains a URL to a further resource. Each further resource is fetched and parsed. The aggregation is complete when we have them all.</p>
<table>
<thead>
<tr class="header">
<th align="left">Strategy</th>
<th align="left">Network</th>
<th align="right">First output (ms)</th>
<th align="right">Total time (ms)</th>
<th align="right">Max. Memory (Mb)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Oboe.js</td>
<td align="left">Good</td>
<td align="right">40</td>
<td align="right">804</td>
<td align="right">6.2</td>
</tr>
<tr class="even">
<td align="left">Oboe.js</td>
<td align="left">Poor</td>
<td align="right">60</td>
<td align="right">1,526</td>
<td align="right">6.2</td>
</tr>
<tr class="odd">
<td align="left">JSON.parse (DOM)</td>
<td align="left">Good</td>
<td align="right">984</td>
<td align="right">1,064</td>
<td align="right">9,0</td>
</tr>
<tr class="even">
<td align="left">JSON.parse (DOM)</td>
<td align="left">Poor</td>
<td align="right">2550</td>
<td align="right">2,609</td>
<td align="right">8.9</td>
</tr>
<tr class="odd">
<td align="left">Clarinet (SAX)</td>
<td align="left">Good</td>
<td align="right">34</td>
<td align="right">781</td>
<td align="right">5.5</td>
</tr>
<tr class="even">
<td align="left">Clarinet (SAX)</td>
<td align="left">Poor</td>
<td align="right">52</td>
<td align="right">1,510</td>
<td align="right">5.5</td>
</tr>
</tbody>
</table>
<p>Vs Json.parse shows a dramatic improvement over first output of about 96% and a smaller but significant improvement of about 40% in time required to complete the task. Oboe's performance in terms of time is about 15% slower than Clarinet; since Oboe is built on Clarinet it could not be faster but I had hoped for these results to be closer.</p>
<p>As expected, in this simulation of real-world usage, the extra computation<br />compared to JSON.parse which is needed by Oboe's more involved algorithms or Clarinet's less efficient parsing<sup><a href="#fn13" class="footnoteRef" id="fnref13">13</a></sup> have been dwarfed by better i/o management. Reacting earlier using slower handlers has been shown to be faster overall than reacting later with quicker ones. I believe that this vindicates a focus on efficient management of i/o over faster algorithms. I believe that much programming takes a &quot;Hurry up and wait&quot; approach by concentrating overly on optimal computation rather than optimal i/o management.</p>
<p>There is an unexpected improvement vs JSON.parse in terms of memory usage. It is not clear why this would be but it may be attributable to the json fetching library used to simplify the JSON.parse tests having a large dependency tree. As expected, Clarinet shows the largest improvements in terms of memory usage. For very large JSON I would expect Clarinet's memory usage to remain roughly constant whilst the two approaches rise linearly with the size of the resource.</p>
</div>
<div id="comparative-programmer-ergonomics" class="section level2">
<h2><a href="#comparative-programmer-ergonomics"><span class="header-section-number">6.2</span> Comparative Programmer Ergonomics</a></h2>
<p>For each of the benchmarks above the code was laid out in the most natural way for the strategy under test.</p>
<table>
<thead>
<tr class="header">
<th align="left">Strategy</th>
<th align="right">Code Required (lines)</th>
<th align="right">Code required (chars)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Oboe.js</td>
<td align="right">3</td>
<td align="right">64</td>
</tr>
<tr class="even">
<td align="left">JSON.parse</td>
<td align="right">5</td>
<td align="right">102</td>
</tr>
<tr class="odd">
<td align="left">Clarinet (SAX)</td>
<td align="right">30</td>
<td align="right">lots!</td>
</tr>
</tbody>
</table>
<p>Oboe was the shortest:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">oboe</span>(DB_URL).<span class="fu">node</span>(<span class="st">&#39;{id url}.url&#39;</span>, <span class="kw">function</span>(url){
        
   <span class="fu">oboe</span>(url).<span class="fu">node</span>(<span class="st">&#39;name&#39;</span>, <span class="kw">function</span>(name){
                   
      <span class="ot">console</span>.<span class="fu">log</span>(name);               
   });      
});</code></pre>
<p>Non-progressive parsing was slightly longer, requiring in addition a loop, an if statement, and programmatically selecting specific parts of the results:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// JSON.parse. The code is shortened and simplified by get-json from NPM:</span>
<span class="co">// https://npmjs.org/package/get-json</span>

<span class="fu">getJson</span>(DB_URL, <span class="kw">function</span>(err, records) {
    
   <span class="ot">records</span>.<span class="ot">data</span>.<span class="fu">forEach</span>( <span class="kw">function</span>( record ){
    
      <span class="kw">if</span>( <span class="ot">record</span>.<span class="fu">url</span> ) {
      
         <span class="fu">getJson</span>(<span class="ot">record</span>.<span class="fu">url</span>, <span class="kw">function</span>(err, record) {
         
            <span class="ot">console</span>.<span class="fu">log</span>(<span class="ot">record</span>.<span class="fu">name</span>);
         });
      }
   });
});</code></pre>
<p>The JSON.parse version is very closely coupled with the format that it is handling. We can see this in the fragments <code>records.data</code>, <code>record.url</code>, <code>record.name</code> which expects to find sub-trees at very specific locations in the JSON. The code might be said to contain a description of the format that it is for. Conversely, the Oboe version describes the format only so far as is needed to identify the parts that it is interested in; the remainder of the format could change and the code would continue to work. As well as being simpler to program against than the previous simplest mode, I believe this demonstrates a greater tolerance to changing formats.</p>
<p>The Clarinet version of the code may be seen in appendex (??). This version is greater in verbosity and obfuscation. I don't think a person could look at this source and understand what is being parsed without thinking about it for a long time. Parameter names such as 'key' or 'value' must be chosen by the position of the token in the markup, prior to understanding the semantics it represents. By contrast, Oboe and JSON.parse both allow names to be given by the meaning of the token.</p>
</div>
<div id="performance-of-code-styles-under-various-engines" class="section level2">
<h2><a href="#performance-of-code-styles-under-various-engines"><span class="header-section-number">6.3</span> Performance of code styles under various engines</a></h2>
<p>The 15% overhead of Oboe vs Clarinet suggests Oboe might be computationally expensive. With very fast networks the extra computation might outweigh a more efficient i/o strategy.</p>
<p>The file <code>test/specs/oboe.performance.spec.js</code> contains a simple benchmark. This test registeres a very complex JSONPath expression which intentionally uses all of the language and fetches a JSON file containing 100 objects, each with 8 String properties against . Correspondingly the expression is evaluated just over 800 times and 100 matches are found. Although real http is used, it is kept within the localhost. The results below are averaged from ten runs. The tests executed on a Macbook Air, except for Chrome Mobile which was tested on an iPhone 5. Tests requiring Microsoft Windows were performed inside a virtual machine.</p>
<p>Curl is a simple download to stdout from the shell and is included as a control run to provide a baseline.</p>
<table>
<thead>
<tr class="header">
<th align="left">Platform</th>
<th align="left">Total Time</th>
<th align="left">Throughput (nodes per ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Curl (control)</td>
<td align="left">42ms</td>
<td align="left"><em>n/a</em></td>
</tr>
<tr class="even">
<td align="left">Node.js v0.10.1</td>
<td align="left">172ms</td>
<td align="left">4.67</td>
</tr>
<tr class="odd">
<td align="left">Chrome 30.0.1599 (Mac OS X 10.7.5)</td>
<td align="left">202ms</td>
<td align="left">3.98</td>
</tr>
<tr class="even">
<td align="left">Safari 6.0.5 (Mac OS X 10.7.5)</td>
<td align="left">231ms</td>
<td align="left">3.48</td>
</tr>
<tr class="odd">
<td align="left">IE 10.0.0 (Windows 8)</td>
<td align="left">349ms</td>
<td align="left">2.30</td>
</tr>
<tr class="even">
<td align="left">Chrome Mobile iOS 30.0.1599 (iOS 7.0.2)</td>
<td align="left">431ms</td>
<td align="left">1.86</td>
</tr>
<tr class="odd">
<td align="left">Firefox 24.0.0 (Mac OS X 10.7)</td>
<td align="left">547ms</td>
<td align="left">1.47</td>
</tr>
<tr class="even">
<td align="left">IE 8.0.0 (Windows XP)</td>
<td align="left">3,048ms</td>
<td align="left">0.26</td>
</tr>
</tbody>
</table>
<p>We can see that Firefox is much slower than other modern browsers despite its SpiderMonkey Javascript engine being normally quite fast. This is probably explicable in part by SpiderMonkey's just-in-time compiler being poor at optimising functional Javascript <span class="citation">(Guo 2013)</span>. Because the JSON nodes are not of a common type the related callsites are not monomorphic which Firefox also optimises poorly <span class="citation">(Guo 2013)</span>. When the test was repeated using a simpler JSONPath expression Firefox showed by far the largest improvement indicating that on this platform the functional pattern matching is the bottleneck.</p>
<p>Of these results I find only the very low performance on old versions of Internet Explorer concerning, almost certainly degrading user experience more than it is improved. It might be reasonable to conclude that for complex use cases Oboe is currently not unsuited to legacy platforms. Since this platform cannot progressively interpret an XHR response, if performance on legacy platforms becomes a serious concern one option might be to create a non-progressive library with the same API which could be selectively delivered to those platforms in place of the main version.</p>
<p>Nonetheless, in its current form Oboe may slow down the total time when working over the very fastest connections.</p>
<p>For an imperative language coded in a functional style the compiler may not optimise as effectively as if a functional language was used. This is especially the case under a highly dynamic language in which everything, even the built-in constructs are mutable. I think Javascript was a good choice of language given it is already well adopted and allows the targeting of server and client side with only minimal effort, giving a very large number of applications with the potential to adopt Oboe. However, there are obvious inefficiencies such as the the descent and ancestor arrays which are always created to be handed to application callbacks but that I anticipate will be predominantly ignored. The design of Oboe is very amicable to implementation under a functional language and it would be interesting to see the results.</p>
</div>
<div id="status-as-a-micro-library" class="section level2">
<h2><a href="#status-as-a-micro-library"><span class="header-section-number">6.4</span> Status as a micro-library</a></h2>
<p>Built versions of Oboe as delivered reside in the project's <code>dist</code> folder. The file <code>oboe-browser.min.js</code> is the minified version which should be sent to browsers gzipped. After gzip is applied this file comes to 4966 bytes; close to but comfortably under the 5120 limit. At roughly the size as a very small image, the size of Oboe should not discourage adoption.</p>
</div>
<div id="potential-future-work" class="section level2">
<h2><a href="#potential-future-work"><span class="header-section-number">6.5</span> potential future work</a></h2>
<p>There is nothing about Oboe which precludes working with other tree-shaped format. If there is demand, An XML/XPATH version seems like an obvious expansion. Currently Oboe only operates on http traffic. While this restriction is reasonable in a Browser context, under Node it is unnecessarily limiting and should be lifted by allowing arbitrary streams to be read.</p>
<p>Oboe stores all items that are parsed from the JSON it receives, resulting in a memory use which is as high as a DOM parser. These are kept in order to be able to provide a match to any possible JSONPath expression. However, in most cases memory would be saved if the parsed content were only stored so far as is needed to provide matches against the JSONPath expressions which have actually been registered. For typical use cases I expect this would allow the non-storage of large branches. Likewise, the current implementation takes a rather brute force approach when examining node for pattern matches: check every registered JSONPath expression against every node and path that are found in the JSON. For many expressions we are able to know there is no possibility of matching a JSON tree, either because we have already matched or because the the current node's ancestors already mandate failure. A more sophisticated programme might disregard provably unsatisfiable handlers for the duration of a subtree. Either of these changes would involve some rather difficult programming and because matching is fast enough I think brute force is the best approach for the time being.</p>
<p>During JSONPath matching much of the computation is repeated. For example, matching the expression <code>b.*</code> against many children of a common parent will repeat the same test, checking if the parent's name is 'b', for each child node. Because the JSONPath matching is stateless, recursive and side-effect free there is a potential to cut out repeated computation by using a functional cache. This would reduce the overall amount of computation needed for JSONPath expressions with common substrings to their left side or nodes with a common ancestry. Current Javascript implementations make it difficult to manage a functional cache, or caches in general, from inside the language itself because there is no way to occupy only the unused memory. Weak references are proposed in ECMAScript 6 but currently only experimentally supported<sup><a href="#fn14" class="footnoteRef" id="fnref14">14</a></sup>. For future development they would be ideal.</p>
<p>The nodes which Oboe hands to callbacks are mutable meaning that potentially the correct workings of the library could be broken if the containing application carelessly alters them. Newer implementations of Javascript allows a whole object to be made immutable, or just certain properties via an immutability decorator and the <code>defineProperty</code> method. This would probably be an improvement.</p>
</div>
</div>
<div id="appendix_http_limits" class="section level1">
<h1><a href="#appendix_http_limits"><span class="header-section-number">7</span> Appendix i: Limits to number of simultaneous connections under various http clients</a></h1>
<table>
<col width="22%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">http Client</th>
<th align="left">connection limit per server</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Firefox</td>
<td align="left">6</td>
</tr>
<tr class="even">
<td align="left">Internet Explorer</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">Chrome / Chromium</td>
<td align="left">32 sockets per proxy 6 sockets per destination host 256 sockets per process</td>
</tr>
</tbody>
</table>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest</a></p>
<p><a href="http://msdn.microsoft.com/de-de/magazine/ee330731.aspx">http://msdn.microsoft.com/de-de/magazine/ee330731.aspx</a>#http11_max_con</p>
<p><a href="http://dev.chromium.org/developers/design-documents/network-stack">http://dev.chromium.org/developers/design-documents/network-stack</a>#TOC-Connection-Management</p>
</div>
<div id="appendix-ii-oboe.js-source-code-listing" class="section level1">
<h1><a href="#appendix-ii-oboe.js-source-code-listing"><span class="header-section-number">8</span> Appendix ii: Oboe.js source code listing</a></h1>
<div id="clarinetlisteneradaptor.js" class="section level2">
<h2><a href="#clarinetlisteneradaptor.js"><span class="header-section-number">8.1</span> clarinetListenerAdaptor.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="co">/** </span>
<span class="co"> * A bridge used to assign stateless functions to listen to clarinet.</span>
<span class="co"> * </span>
<span class="co"> * As well as the parameter from clarinet, each callback will also be passed</span>
<span class="co"> * the result of the last callback.</span>
<span class="co"> * </span>
<span class="co"> * This may also be used to clear all listeners by assigning zero handlers:</span>
<span class="co"> * </span>
<span class="co"> *    clarinetListenerAdaptor( clarinet, {} )</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">clarinetListenerAdaptor</span>(clarinetParser, handlers){
    
   <span class="kw">var</span> state;

   <span class="ot">clarinet</span>.<span class="ot">EVENTS</span>.<span class="fu">forEach</span>(<span class="kw">function</span>(eventName){
 
      <span class="kw">var</span> handlerFunction = handlers[eventName];
      
      clarinetParser[<span class="st">&#39;on&#39;</span>+eventName] = handlerFunction &amp;&amp; 
                                       <span class="kw">function</span>(param) {
                                          state = <span class="fu">handlerFunction</span>( state, param);
                                       };
   });
}</code></pre>
<p></p>
</div>
<div id="events.js" class="section level2">
<h2><a href="#events.js"><span class="header-section-number">8.2</span> events.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * This file declares some constants to use as names for event types.</span>
<span class="co"> */</span>

<span class="kw">var</span> <span class="co">// NODE_FOUND, PATH_FOUND and ERROR_EVENT feature </span>
    <span class="co">// in the public API via .on(&#39;node&#39;, ...) or .on(&#39;path&#39;, ...)</span>
    <span class="co">// so these events are strings</span>
    NODE_FOUND    = <span class="st">&#39;node&#39;</span>,  
    PATH_FOUND    = <span class="st">&#39;path&#39;</span>,   
         
    <span class="co">// these events are never exported so are kept as </span>
    <span class="co">// the smallest possible representation, numbers:</span>
    _S = <span class="dv">0</span>,
    ERROR_EVENT   = _S++,    
    ROOT_FOUND    = _S++,    
    NEW_CONTENT = _S++,
    END_OF_CONTENT = _S++,
    ABORTING = _S++;</code></pre>
<p></p>
</div>
<div id="functional.js" class="section level2">
<h2><a href="#functional.js"><span class="header-section-number">8.3</span> functional.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/** </span>
<span class="co"> * Partially complete a function.</span>
<span class="co"> * </span>
<span class="co"> * Eg: </span>
<span class="co"> *    var add3 = partialComplete( function add(a,b){return a+b}, [3] );</span>
<span class="co"> *    </span>
<span class="co"> *    add3(4) // gives 7</span>
<span class="co"> */</span>
<span class="kw">var</span> partialComplete = <span class="fu">varArgs</span>(<span class="kw">function</span>( fn, boundArgs ) {

      <span class="kw">return</span> <span class="fu">varArgs</span>(<span class="kw">function</span>( callArgs ) {
               
         <span class="kw">return</span> <span class="ot">fn</span>.<span class="fu">apply</span>(<span class="kw">this</span>, <span class="ot">boundArgs</span>.<span class="fu">concat</span>(callArgs));
      }); 
   }),


<span class="co">/**</span>
<span class="co"> * Compose zero or more functions:</span>
<span class="co"> * </span>
<span class="co"> *    compose(f1, f2, f3)(x) = f1(f2(f3(x))))</span>
<span class="co"> * </span>
<span class="co"> * The last (inner-most) function may take more than one parameter:</span>
<span class="co"> * </span>
<span class="co"> *    compose(f1, f2, f3)(x,y) = f1(f2(f3(x,y))))</span>
<span class="co"> */</span>
   compose = <span class="fu">varArgs</span>(<span class="kw">function</span>(fns) {

      <span class="kw">var</span> fnsList = <span class="fu">arrayAsList</span>(fns);
   
      <span class="kw">function</span> <span class="fu">next</span>(params, curFn) {  
         <span class="kw">return</span> [<span class="fu">apply</span>(params, curFn)];   
      }
      
      <span class="kw">return</span> <span class="fu">varArgs</span>(<span class="kw">function</span>(startParams){
        
         <span class="kw">return</span> <span class="fu">foldR</span>(next, startParams, fnsList)[<span class="dv">0</span>];
      });
   }),

<span class="co">/**</span>
<span class="co"> * Call a list of functions with the same args until one returns a </span>
<span class="co"> * truthy result. Similar to the || operator.</span>
<span class="co"> * </span>
<span class="co"> * So:</span>
<span class="co"> *      lazyUnion([f1,f2,f3 ... fn])( p1, p2 ... pn )</span>
<span class="co"> *      </span>
<span class="co"> * Is equivalent to: </span>
<span class="co"> *      apply([p1, p2 ... pn], f1) || </span>
<span class="co"> *      apply([p1, p2 ... pn], f2) || </span>
<span class="co"> *      apply([p1, p2 ... pn], f3) ... apply(fn, [p1, p2 ... pn])  </span>
<span class="co"> *  </span>
<span class="co"> * </span><span class="kw">@returns</span><span class="co"> the first return value that is given that is truthy.</span>
<span class="co"> */</span>
   lazyUnion = <span class="fu">varArgs</span>(<span class="kw">function</span>(fns) {

      <span class="kw">return</span> <span class="fu">varArgs</span>(<span class="kw">function</span>(params){
   
         <span class="kw">var</span> maybeValue;
   
         <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; <span class="fu">len</span>(fns); i++) {
   
            maybeValue = <span class="fu">apply</span>(params, fns[i]);
   
            <span class="kw">if</span>( maybeValue ) {
               <span class="kw">return</span> maybeValue;
            }
         }
      });
   });   

<span class="co">/**</span>
<span class="co"> * This file declares various pieces of functional programming.</span>
<span class="co"> * </span>
<span class="co"> * This isn&#39;t a general purpose functional library, to keep things small it</span>
<span class="co"> * has just the parts useful for Oboe.js.</span>
<span class="co"> */</span>


<span class="co">/**</span>
<span class="co"> * Call a single function with the given arguments array.</span>
<span class="co"> * Basically, a functional-style version of the OO-style Function#apply for </span>
<span class="co"> * when we don&#39;t care about the context (&#39;this&#39;) of the call.</span>
<span class="co"> * </span>
<span class="co"> * The order of arguments allows partial completion of the arguments array</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">apply</span>(args, fn) {
   <span class="kw">return</span> <span class="ot">fn</span>.<span class="fu">apply</span>(<span class="kw">undefined</span>, args);
}

<span class="co">/**</span>
<span class="co"> * Define variable argument functions but cut out all that tedious messing about </span>
<span class="co"> * with the arguments object. Delivers the variable-length part of the arguments</span>
<span class="co"> * list as an array.</span>
<span class="co"> * </span>
<span class="co"> * Eg:</span>
<span class="co"> * </span>
<span class="co"> * var myFunction = varArgs(</span>
<span class="co"> *    function( fixedArgument, otherFixedArgument, variableNumberOfArguments ){</span>
<span class="co"> *       console.log( variableNumberOfArguments );</span>
<span class="co"> *    }</span>
<span class="co"> * )</span>
<span class="co"> * </span>
<span class="co"> * myFunction(&#39;a&#39;, &#39;b&#39;, 1, 2, 3); // logs [1,2,3]</span>
<span class="co"> * </span>
<span class="co"> * var myOtherFunction = varArgs(function( variableNumberOfArguments ){</span>
<span class="co"> *    console.log( variableNumberOfArguments );</span>
<span class="co"> * })</span>
<span class="co"> * </span>
<span class="co"> * myFunction(1, 2, 3); // logs [1,2,3]</span>
<span class="co"> * </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">varArgs</span>(fn){

   <span class="kw">var</span> numberOfFixedArguments = <span class="ot">fn</span>.<span class="fu">length</span> -<span class="dv">1</span>;
         
   <span class="kw">return</span> <span class="kw">function</span>(){
   
      <span class="kw">var</span> numberOfVaraibleArguments = <span class="ot">arguments</span>.<span class="fu">length</span> - numberOfFixedArguments,
      
          argumentsToFunction = <span class="ot">Array</span>.<span class="ot">prototype</span>.<span class="ot">slice</span>.<span class="fu">call</span>(arguments);
          
      <span class="co">// remove the last n element from the array and append it onto the end of</span>
      <span class="co">// itself as a sub-array</span>
      <span class="ot">argumentsToFunction</span>.<span class="fu">push</span>( 
         <span class="ot">argumentsToFunction</span>.<span class="fu">splice</span>(numberOfFixedArguments, numberOfVaraibleArguments)
      );   
      
      <span class="kw">return</span> <span class="ot">fn</span>.<span class="fu">apply</span>( <span class="kw">this</span>, argumentsToFunction );
   }       
}


<span class="co">/**</span>
<span class="co"> * Swap the order of parameters to a binary function</span>
<span class="co"> * </span>
<span class="co"> * A bit like this flip: http://zvon.org/other/haskell/Outputprelude/flip_f.html</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">flip</span>(fn){
   <span class="kw">return</span> <span class="kw">function</span>(a, b){
      <span class="kw">return</span> <span class="fu">fn</span>(b,a);
   }
}


<span class="co">/**</span>
<span class="co"> * Create a function which is the intersection of two other functions.</span>
<span class="co"> * </span>
<span class="co"> * Like the &amp;&amp; operator, if the first is truthy, the second is never called,</span>
<span class="co"> * otherwise the return value from the second is returned.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">lazyIntersection</span>(fn1, fn2) {

   <span class="kw">return</span> <span class="kw">function</span> (param) {
                                                              
      <span class="kw">return</span> <span class="fu">fn1</span>(param) &amp;&amp; <span class="fu">fn2</span>(param);
   };   
}
</code></pre>
<p></p>
</div>
<div id="incrementalcontentbuilder.js" class="section level2">
<h2><a href="#incrementalcontentbuilder.js"><span class="header-section-number">8.4</span> incrementalContentBuilder.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/** </span>
<span class="co"> * This file provides various listeners which can be used to build up</span>
<span class="co"> * a changing ascent based on the callbacks provided by Clarinet. It listens</span>
<span class="co"> * to the low-level events from Clarinet and fires higher-level ones.</span>
<span class="co"> *  </span>
<span class="co"> * The building up is stateless so to track a JSON file</span>
<span class="co"> * clarinetListenerAdaptor.js is required to store the ascent state</span>
<span class="co"> * between calls.</span>
<span class="co"> */</span>


<span class="kw">var</span> keyOf = <span class="fu">attr</span>(<span class="st">&#39;key&#39;</span>);
<span class="kw">var</span> nodeOf = <span class="fu">attr</span>(<span class="st">&#39;node&#39;</span>);


<span class="co">/** </span>
<span class="co"> * A special value to use in the path list to represent the path &#39;to&#39; a root </span>
<span class="co"> * object (which doesn&#39;t really have any path). This prevents the need for </span>
<span class="co"> * special-casing detection of the root object and allows it to be treated </span>
<span class="co"> * like any other object. We might think of this as being similar to the </span>
<span class="co"> * &#39;unnamed root&#39; domain &quot;.&quot;, eg if I go to </span>
<span class="co"> * http://en.wikipedia.org./wiki/En/Main_page the dot after &#39;org&#39; deliminates </span>
<span class="co"> * the unnamed root of the DNS.</span>
<span class="co"> * </span>
<span class="co"> * This is kept as an object to take advantage that in Javascript&#39;s OO objects </span>
<span class="co"> * are guaranteed to be distinct, therefore no other object can possibly clash </span>
<span class="co"> * with this one. Strings, numbers etc provide no such guarantee. </span>
<span class="co"> **/</span>
<span class="kw">var</span> ROOT_PATH = {};


<span class="co">/**</span>
<span class="co"> * Create a new set of handlers for clarinet&#39;s events, bound to the fire </span>
<span class="co"> * function given.  </span>
<span class="co"> */</span> 
<span class="kw">function</span> <span class="fu">incrementalContentBuilder</span>( fire) {


   <span class="kw">function</span> <span class="fu">arrayIndicesAreKeys</span>( possiblyInconsistentAscent, newDeepestNode) {
   
      <span class="co">/* for values in arrays we aren&#39;t pre-warned of the coming paths </span>
<span class="co">         (Clarinet gives no call to onkey like it does for values in objects) </span>
<span class="co">         so if we are in an array we need to create this path ourselves. The </span>
<span class="co">         key will be len(parentNode) because array keys are always sequential </span>
<span class="co">         numbers. */</span>

      <span class="kw">var</span> parentNode = <span class="fu">nodeOf</span>( <span class="fu">head</span>( possiblyInconsistentAscent));
      
      <span class="kw">return</span>      <span class="fu">isOfType</span>( Array, parentNode)
               ?
                  <span class="fu">pathFound</span>(  possiblyInconsistentAscent, 
                              <span class="fu">len</span>(parentNode), 
                              newDeepestNode
                  )
               :  
                  <span class="co">// nothing needed, return unchanged</span>
                  possiblyInconsistentAscent 
               ;
   }
                 
   <span class="kw">function</span> <span class="fu">nodeFound</span>( ascent, newDeepestNode ) {
      
      <span class="kw">if</span>( !ascent ) {
         <span class="co">// we discovered the root node,</span>
         <span class="fu">fire</span>( ROOT_FOUND, newDeepestNode);
                    
         <span class="kw">return</span> <span class="fu">pathFound</span>( ascent, ROOT_PATH, newDeepestNode);         
      }

      <span class="co">// we discovered a non-root node</span>
                 
      <span class="kw">var</span> arrayConsistentAscent  = <span class="fu">arrayIndicesAreKeys</span>( ascent, newDeepestNode),      
          ancestorBranches       = <span class="fu">tail</span>( arrayConsistentAscent),
          previouslyUnmappedName = <span class="fu">keyOf</span>( <span class="fu">head</span>( arrayConsistentAscent));
          
      <span class="fu">appendBuiltContent</span>( 
         ancestorBranches, 
         previouslyUnmappedName, 
         newDeepestNode 
      );
                                                                                                         
      <span class="kw">return</span> <span class="fu">cons</span>( 
               <span class="fu">namedNode</span>( previouslyUnmappedName, newDeepestNode ), 
               ancestorBranches
      );                                                                          
   }


   <span class="co">/**</span>
<span class="co">    * Add a new value to the object we are building up to represent the</span>
<span class="co">    * parsed JSON</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">appendBuiltContent</span>( ancestorBranches, key, node ){
     
      <span class="fu">nodeOf</span>( <span class="fu">head</span>( ancestorBranches))[key] = node;
   }

   <span class="co">/**</span>
<span class="co">    * Get a new key-&gt;node mapping</span>
<span class="co">    * </span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String|Number}</span><span class="co"> key</span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Object|Array|String|Number|null}</span><span class="co"> node a value found in the json</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">namedNode</span>(key, node) {
      <span class="kw">return</span> {<span class="dt">key</span>:key, <span class="dt">node</span>:node};
   }
     
   <span class="co">/**</span>
<span class="co">    * For when we find a new key in the json.</span>
<span class="co">    * </span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String|Number|Object}</span><span class="co"> newDeepestName the key. If we are in an </span>
<span class="co">    *    array will be a number, otherwise a string. May take the special </span>
<span class="co">    *    value ROOT_PATH if the root node has just been found</span>
<span class="co">    *    </span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String|Number|Object|Array|Null|undefined}</span><span class="co"> [maybeNewDeepestNode] </span>
<span class="co">    *    usually this won&#39;t be known so can be undefined. Can&#39;t use null </span>
<span class="co">    *    to represent unknown because null is a valid value in JSON</span>
<span class="co">    **/</span>  
   <span class="kw">function</span> <span class="fu">pathFound</span>(ascent, newDeepestName, maybeNewDeepestNode) {

      <span class="kw">if</span>( ascent ) { <span class="co">// if not root</span>
      
         <span class="co">// If we have the key but (unless adding to an array) no known value</span>
         <span class="co">// yet. Put that key in the output but against no defined value:      </span>
         <span class="fu">appendBuiltContent</span>( ascent, newDeepestName, maybeNewDeepestNode );
      }
   
      <span class="kw">var</span> ascentWithNewPath = <span class="fu">cons</span>( 
                                 <span class="fu">namedNode</span>( newDeepestName, 
                                            maybeNewDeepestNode), 
                                 ascent
                              );
     
      <span class="fu">fire</span>( PATH_FOUND, ascentWithNewPath);
 
      <span class="kw">return</span> ascentWithNewPath;
   }


   <span class="co">/**</span>
<span class="co">    * For when the current node ends</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">curNodeFinished</span>( ascent ) {

      <span class="fu">fire</span>( NODE_FOUND, ascent);
                          
      <span class="co">// pop the complete node and its path off the list:                                    </span>
      <span class="kw">return</span> <span class="fu">tail</span>( ascent);
   }      
                 
   <span class="kw">return</span> { 

      <span class="dt">openobject </span>: <span class="kw">function</span> (ascent, firstKey) {

         <span class="kw">var</span> ascentAfterNodeFound = <span class="fu">nodeFound</span>(ascent, {});         

         <span class="co">/* It is a perculiarity of Clarinet that for non-empty objects it</span>
<span class="co">            gives the first key with the openobject event instead of</span>
<span class="co">            in a subsequent key event.</span>
<span class="co">                      </span>
<span class="co">            firstKey could be the empty string in a JSON object like </span>
<span class="co">            {&#39;&#39;:&#39;foo&#39;} which is technically valid.</span>
<span class="co">            </span>
<span class="co">            So can&#39;t check with !firstKey, have to see if has any </span>
<span class="co">            defined value. */</span>
         <span class="kw">return</span> <span class="fu">defined</span>(firstKey)
         ?          
            <span class="co">/* We know the first key of the newly parsed object. Notify that </span>
<span class="co">               path has been found but don&#39;t put firstKey permanently onto </span>
<span class="co">               pathList yet because we haven&#39;t identified what is at that key </span>
<span class="co">               yet. Give null as the value because we haven&#39;t seen that far </span>
<span class="co">               into the json yet */</span>
            <span class="fu">pathFound</span>(ascentAfterNodeFound, firstKey)
         :
            ascentAfterNodeFound
         ;
      },
    
      <span class="dt">openarray</span>: <span class="kw">function</span> (ascent) {
         <span class="kw">return</span> <span class="fu">nodeFound</span>(ascent, []);
      },

      <span class="co">// called by Clarinet when keys are found in objects               </span>
      <span class="dt">key</span>: pathFound,
      
      <span class="co">/* Emitted by Clarinet when primitive values are found, ie Strings,</span>
<span class="co">         Numbers, and null.</span>
<span class="co">         Because these are always leaves in the JSON, we find and finish the </span>
<span class="co">         node in one step, expressed as functional composition: */</span>
      <span class="dt">value</span>: <span class="fu">compose</span>( curNodeFinished, nodeFound ),
      
      <span class="co">// we make no distinction in how we handle object and arrays closing.</span>
      <span class="co">// For both, interpret as the end of the current node.</span>
      <span class="dt">closeobject</span>: curNodeFinished,
      <span class="dt">closearray</span>: curNodeFinished       
   };
}</code></pre>
<p></p>
</div>
<div id="instancecontroller.js" class="section level2">
<h2><a href="#instancecontroller.js"><span class="header-section-number">8.5</span> instanceController.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * This file implements a light-touch central controller for an instance </span>
<span class="co"> * of Oboe which provides the methods used for interacting with the instance </span>
<span class="co"> * from the calling app.</span>
<span class="co"> */</span>
 
 
<span class="kw">function</span> <span class="fu">instanceController</span>(fire, on, clarinetParser, contentBuilderHandlers) {
  
   <span class="kw">var</span> oboeApi, rootNode;

   <span class="co">// when the root node is found grap a reference to it for later      </span>
   <span class="fu">on</span>(ROOT_FOUND, <span class="kw">function</span>(root) {
      rootNode = root;   
   });
                              
   <span class="fu">on</span>(NEW_CONTENT,         
      <span class="kw">function</span> (nextDrip) {
         <span class="co">// callback for when a bit more data arrives from the streaming XHR         </span>
          
         <span class="kw">try</span> {
            
            <span class="ot">clarinetParser</span>.<span class="fu">write</span>(nextDrip);            
         } <span class="kw">catch</span>(e) { 
            <span class="co">/* we don&#39;t have to do anything here because we always assign</span>
<span class="co">               a .onerror to clarinet which will have already been called </span>
<span class="co">               by the time this exception is thrown. */</span>                
         }
      }
   );
   
   <span class="co">/* At the end of the http content close the clarinet parser.</span>
<span class="co">      This will provide an error if the total content provided was not </span>
<span class="co">      valid json, ie if not all arrays, objects and Strings closed properly */</span>
   <span class="fu">on</span>(END_OF_CONTENT, <span class="ot">clarinetParser</span>.<span class="ot">close</span>.<span class="fu">bind</span>(clarinetParser));
   

   <span class="co">/* If we abort this Oboe&#39;s request stop listening to the clarinet parser. </span>
<span class="co">      This prevents more tokens being found after we abort in the case where </span>
<span class="co">      we aborted during processing of an already filled buffer. */</span>
   <span class="fu">on</span>( ABORTING, <span class="kw">function</span>() {
      <span class="fu">clarinetListenerAdaptor</span>(clarinetParser, {});
   });   

   <span class="fu">clarinetListenerAdaptor</span>(clarinetParser, contentBuilderHandlers);
  
   <span class="co">// react to errors by putting them on the event bus</span>
   <span class="ot">clarinetParser</span>.<span class="fu">onerror</span> = <span class="kw">function</span>(e) {          
      <span class="fu">fire</span>(ERROR_EVENT, e);
      
      <span class="co">// note: don&#39;t close clarinet here because if it was not expecting</span>
      <span class="co">// end of the json it will throw an error</span>
   };

   <span class="kw">function</span> <span class="fu">addPathOrNodeCallback</span>( eventId, pattern, callback ) {
   
      <span class="kw">var</span> matchesJsonPath = <span class="fu">jsonPathCompiler</span>( pattern );
   
      <span class="co">// Add a new callback adaptor to the eventBus.</span>
      <span class="co">// This listener first checks that he pattern matches then if it does, </span>
      <span class="co">// passes it onto the callback. </span>
      <span class="fu">on</span>( eventId, <span class="kw">function</span>( ascent ){ 
 
         <span class="kw">var</span> maybeMatchingMapping = <span class="fu">matchesJsonPath</span>( ascent );
     
         <span class="co">/* Possible values for maybeMatchingMapping are now:</span>

<span class="co">            false: </span>
<span class="co">               we did not match </span>
<span class="co">  </span>
<span class="co">            an object/array/string/number/null: </span>
<span class="co">               we matched and have the node that matched.</span>
<span class="co">               Because nulls are valid json values this can be null.</span>
<span class="co">  </span>
<span class="co">            undefined: </span>
<span class="co">               we matched but don&#39;t have the matching node yet.</span>
<span class="co">               ie, we know there is an upcoming node that matches but we </span>
<span class="co">               can&#39;t say anything else about it. </span>
<span class="co">         */</span>
         <span class="kw">if</span>( maybeMatchingMapping !== <span class="kw">false</span> ) {                                 

            <span class="fu">notifyCallback</span>(callback, maybeMatchingMapping, ascent);                           
         }
      });   
   }   
   
   <span class="kw">function</span> <span class="fu">notifyCallback</span>(callback, matchingMapping, ascent) {
      <span class="co">/* </span>
<span class="co">         We&#39;re now calling back to outside of oboe where the Lisp-style </span>
<span class="co">         lists that we are using internally will not be recognised </span>
<span class="co">         so convert to standard arrays. </span>
<span class="co">  </span>
<span class="co">         Also, reverse the order because it is more common to list paths </span>
<span class="co">         &quot;root to leaf&quot; than &quot;leaf to root&quot; </span>
<span class="co">      */</span>
            
      <span class="kw">var</span> descent     = <span class="fu">reverseList</span>(ascent),
      
          <span class="co">// To make a path, strip off the last item which is the special</span>
          <span class="co">// ROOT_PATH token for the &#39;path&#39; to the root node</span>
          path       = <span class="fu">listAsArray</span>(<span class="fu">tail</span>(<span class="fu">map</span>(keyOf,descent))),
          ancestors  = <span class="fu">listAsArray</span>(<span class="fu">map</span>(nodeOf, descent)); 
      
      <span class="kw">try</span>{
      
         <span class="fu">callback</span>( <span class="fu">nodeOf</span>(matchingMapping), path, ancestors );   
      }<span class="kw">catch</span>(e)  {
      
         <span class="co">// An error occured during the callback, publish it on the event bus </span>
         <span class="fu">fire</span>(ERROR_EVENT, e);
      }          
   }

   <span class="co">/**</span>
<span class="co">    * Add several listeners at a time, from a map</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">addListenersMap</span>(eventId, listenerMap) {
   
      <span class="kw">for</span>( <span class="kw">var</span> pattern <span class="kw">in</span> listenerMap ) {
         <span class="fu">addPathOrNodeCallback</span>(eventId, pattern, listenerMap[pattern]);
      }
   }    
      
   <span class="co">/**</span>
<span class="co">    * implementation behind .onPath() and .onNode()</span>
<span class="co">    */</span>       
   <span class="kw">function</span> <span class="fu">addNodeOrPathListenerApi</span>( eventId, jsonPathOrListenerMap,
                                      callback, callbackContext ){
 
      <span class="kw">if</span>( <span class="fu">isString</span>(jsonPathOrListenerMap) ) {
         <span class="fu">addPathOrNodeCallback</span>( 
            eventId, 
            jsonPathOrListenerMap, 
            <span class="ot">callback</span>.<span class="fu">bind</span>(callbackContext||oboeApi)
         );
      } <span class="kw">else</span> {
         <span class="fu">addListenersMap</span>(eventId, jsonPathOrListenerMap);
      }
      
      <span class="kw">return</span> <span class="kw">this</span>; <span class="co">// chaining</span>
   }

   <span class="co">/**</span>
<span class="co">    * Construct and return the public API of the Oboe instance to be </span>
<span class="co">    * returned to the calling application</span>
<span class="co">    */</span>
   <span class="kw">return</span> oboeApi = { 
      <span class="dt">path  </span>:  <span class="fu">partialComplete</span>(addNodeOrPathListenerApi, PATH_FOUND), 
      <span class="dt">node  </span>:  <span class="fu">partialComplete</span>(addNodeOrPathListenerApi, NODE_FOUND),
      <span class="dt">on    </span>:  addNodeOrPathListenerApi,
      <span class="dt">fail  </span>:  <span class="fu">partialComplete</span>(on, ERROR_EVENT),
      <span class="dt">done  </span>:  <span class="fu">partialComplete</span>(addNodeOrPathListenerApi, NODE_FOUND, <span class="st">&#39;!&#39;</span>),
      <span class="dt">abort </span>:  <span class="fu">partialComplete</span>(fire, ABORTING),
      <span class="dt">root  </span>:  <span class="kw">function</span> <span class="fu">rootNodeFunctor</span>() {
                  <span class="kw">return</span> rootNode;
               }
   };
}</code></pre>
<p></p>
</div>
<div id="jsonpath.js" class="section level2">
<h2><a href="#jsonpath.js"><span class="header-section-number">8.6</span> jsonPath.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * The jsonPath evaluator compiler used for Oboe.js. </span>
<span class="co"> * </span>
<span class="co"> * One function is exposed. This function takes a String JSONPath spec and </span>
<span class="co"> * returns a function to test candidate ascents for matches.</span>
<span class="co"> * </span>
<span class="co"> *  String jsonPath -&gt; (List ascent) -&gt; Boolean|Object</span>
<span class="co"> *</span>
<span class="co"> * This file is coded in a pure functional style. That is, no function has </span>
<span class="co"> * side effects, every function evaluates to the same value for the same </span>
<span class="co"> * arguments and no variables are reassigned.</span>
<span class="co"> */</span>  
<span class="co">// the call to jsonPathSyntax injects the token syntaxes that are needed </span>
<span class="co">// inside the compiler</span>
<span class="kw">var</span> jsonPathCompiler = <span class="fu">jsonPathSyntax</span>(<span class="kw">function</span> (pathNodeSyntax, 
                                                doubleDotSyntax, 
                                                dotSyntax,
                                                bangSyntax,
                                                emptySyntax ) {

   <span class="kw">var</span> CAPTURING_INDEX = <span class="dv">1</span>;
   <span class="kw">var</span> NAME_INDEX = <span class="dv">2</span>;
   <span class="kw">var</span> FIELD_LIST_INDEX = <span class="dv">3</span>;

   <span class="kw">var</span> headKey = <span class="fu">compose</span>(keyOf, head);
                   
   <span class="co">/**</span>
<span class="co">    * Create an evaluator function for a named path node, expressed in the</span>
<span class="co">    * JSONPath like:</span>
<span class="co">    *    foo</span>
<span class="co">    *    [&quot;bar&quot;]</span>
<span class="co">    *    [2]   </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">nameClause</span>(previousExpr, detection ) {
     
      <span class="kw">var</span> name = detection[NAME_INDEX],
            
          matchesName = ( !name || name == <span class="st">&#39;*&#39;</span> ) 
                           ?  always
                           :  <span class="kw">function</span>(ascent){<span class="kw">return</span> <span class="fu">headKey</span>(ascent) == name};
     

      <span class="kw">return</span> <span class="fu">lazyIntersection</span>(matchesName, previousExpr);
   }

   <span class="co">/**</span>
<span class="co">    * Create an evaluator function for a a duck-typed node, expressed like:</span>
<span class="co">    * </span>
<span class="co">    *    {spin, taste, colour}</span>
<span class="co">    *    .particle{spin, taste, colour}</span>
<span class="co">    *    *{spin, taste, colour}</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">duckTypeClause</span>(previousExpr, detection) {

      <span class="kw">var</span> fieldListStr = detection[FIELD_LIST_INDEX];

      <span class="kw">if</span> (!fieldListStr) 
         <span class="kw">return</span> previousExpr; <span class="co">// don&#39;t wrap at all, return given expr as-is      </span>

      <span class="kw">var</span> hasAllrequiredFields = <span class="fu">partialComplete</span>(
                                    hasAllProperties, 
                                    <span class="fu">arrayAsList</span>(<span class="ot">fieldListStr</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">\W</span><span class="fl">+</span><span class="ot">/</span>))
                                 ),
                                 
          isMatch =  <span class="fu">compose</span>( 
                        hasAllrequiredFields, 
                        nodeOf, 
                        head
                     );

      <span class="kw">return</span> <span class="fu">lazyIntersection</span>(isMatch, previousExpr);
   }

   <span class="co">/**</span>
<span class="co">    * Expression for $, returns the evaluator function</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">capture</span>( previousExpr, detection ) {

      <span class="co">// extract meaning from the detection      </span>
      <span class="kw">var</span> capturing = !!detection[CAPTURING_INDEX];

      <span class="kw">if</span> (!capturing)          
         <span class="kw">return</span> previousExpr; <span class="co">// don&#39;t wrap at all, return given expr as-is      </span>
      
      <span class="kw">return</span> <span class="fu">lazyIntersection</span>(previousExpr, head);
            
   }            
      
   <span class="co">/**</span>
<span class="co">    * Create an evaluator function that moves onto the next item on the </span>
<span class="co">    * lists. This function is the place where the logic to move up a </span>
<span class="co">    * level in the ascent exists. </span>
<span class="co">    * </span>
<span class="co">    * Eg, for JSONPath &quot;.foo&quot; we need skip1(nameClause(always, [,&#39;foo&#39;]))</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">skip1</span>(previousExpr) {
   
   
      <span class="kw">if</span>( previousExpr == always ) {
         <span class="co">/* If there is no previous expression this consume command </span>
<span class="co">            is at the start of the jsonPath.</span>
<span class="co">            Since JSONPath specifies what we&#39;d like to find but not </span>
<span class="co">            necessarily everything leading down to it, when running</span>
<span class="co">            out of JSONPath to check against we default to true */</span>
         <span class="kw">return</span> always;
      }

      <span class="co">/** return true if the ascent we have contains only the JSON root,</span>
<span class="co">       *  false otherwise</span>
<span class="co">       */</span>
      <span class="kw">function</span> <span class="fu">notAtRoot</span>(ascent){
         <span class="kw">return</span> <span class="fu">headKey</span>(ascent) != ROOT_PATH;
      }
      
      <span class="kw">return</span> <span class="fu">lazyIntersection</span>(
               <span class="co">/* If we&#39;re already at the root but there are more </span>
<span class="co">                  expressions to satisfy, can&#39;t consume any more. No match.</span>

<span class="co">                  This check is why none of the other exprs have to be able </span>
<span class="co">                  to handle empty lists; skip1 is the only evaluator that </span>
<span class="co">                  moves onto the next token and it refuses to do so once it </span>
<span class="co">                  reaches the last item in the list. */</span>
               notAtRoot,
               
               <span class="co">/* We are not at the root of the ascent yet.</span>
<span class="co">                  Move to the next level of the ascent by handing only </span>
<span class="co">                  the tail to the previous expression */</span> 
               <span class="fu">compose</span>(previousExpr, tail) 
      );
                                                                                                               
   }   
   
   <span class="co">/**</span>
<span class="co">    * Create an evaluator function for the .. (double dot) token. Consumes</span>
<span class="co">    * zero or more levels of the ascent, the fewest that are required to find</span>
<span class="co">    * a match when given to previousExpr.</span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class="fu">skipMany</span>(previousExpr) {

      <span class="kw">if</span>( previousExpr == always ) {
         <span class="co">/* If there is no previous expression this consume command </span>
<span class="co">            is at the start of the jsonPath.</span>
<span class="co">            Since JSONPath specifies what we&#39;d like to find but not </span>
<span class="co">            necessarily everything leading down to it, when running</span>
<span class="co">            out of JSONPath to check against we default to true */</span>            
         <span class="kw">return</span> always;
      }
          
      <span class="kw">var</span> 
          <span class="co">// In JSONPath .. is equivalent to !.. so if .. reaches the root</span>
          <span class="co">// the match has succeeded. Ie, we might write ..foo or !..foo</span>
          <span class="co">// and both should match identically.</span>
          terminalCaseWhenArrivingAtRoot = <span class="fu">rootExpr</span>(),
          terminalCaseWhenPreviousExpressionIsSatisfied = previousExpr, 
          recursiveCase = <span class="fu">skip1</span>(skipManyInner),
          
          cases = <span class="fu">lazyUnion</span>(
                     terminalCaseWhenArrivingAtRoot
                  ,  terminalCaseWhenPreviousExpressionIsSatisfied
                  ,  recursiveCase
                  );                        
            
      <span class="kw">function</span> <span class="fu">skipManyInner</span>(ascent) {
      
         <span class="kw">if</span>( !ascent ) {
            <span class="co">// have gone past the start, not a match:         </span>
            <span class="kw">return</span> <span class="kw">false</span>;
         }      
                                                        
         <span class="kw">return</span> <span class="fu">cases</span>(ascent);
      }
      
      <span class="kw">return</span> skipManyInner;
   }      
   
   <span class="co">/**</span>
<span class="co">    * Generate an evaluator for ! - matches only the root element of the json</span>
<span class="co">    * and ignores any previous expressions since nothing may precede !. </span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class="fu">rootExpr</span>() {
      
      <span class="kw">return</span> <span class="kw">function</span>(ascent){
         <span class="kw">return</span> <span class="fu">headKey</span>(ascent) == ROOT_PATH;
      };
   }   
         
   <span class="co">/**</span>
<span class="co">    * Generate a statement wrapper to sit around the outermost </span>
<span class="co">    * clause evaluator.</span>
<span class="co">    * </span>
<span class="co">    * Handles the case where the capturing is implicit because the JSONPath</span>
<span class="co">    * did not contain a &#39;$&#39; by returning the last node.</span>
<span class="co">    */</span>   
   <span class="kw">function</span> <span class="fu">statementExpr</span>(lastClause) {
      
      <span class="kw">return</span> <span class="kw">function</span>(ascent) {
   
         <span class="co">// kick off the evaluation by passing through to the last clause</span>
         <span class="kw">var</span> exprMatch = <span class="fu">lastClause</span>(ascent);
                                                     
         <span class="kw">return</span> exprMatch === <span class="kw">true</span> ? <span class="fu">head</span>(ascent) : exprMatch;
      };
   }      
                          
   <span class="co">/**</span>
<span class="co">    * For when a token has been found in the JSONPath input.</span>
<span class="co">    * Compiles the parser for that token and returns in combination with the</span>
<span class="co">    * parser already generated.</span>
<span class="co">    * </span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> exprs  a list of the clause evaluator generators for</span>
<span class="co">    *                          the token that was found</span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> parserGeneratedSoFar the parser already found</span>
<span class="co">    * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Array}</span><span class="co"> detection the match given by the regex engine when </span>
<span class="co">    *                          the feature was found</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">expressionsReader</span>( exprs, parserGeneratedSoFar, detection ) {
                     
      <span class="co">// if exprs is zero-length foldR will pass back the </span>
      <span class="co">// parserGeneratedSoFar as-is so we don&#39;t need to treat </span>
      <span class="co">// this as a special case</span>
      
      <span class="kw">return</span>   <span class="fu">foldR</span>( 
                  <span class="kw">function</span>( parserGeneratedSoFar, expr ){
         
                     <span class="kw">return</span> <span class="fu">expr</span>(parserGeneratedSoFar, detection);
                  }, 
                  parserGeneratedSoFar, 
                  exprs
               );                     

   }

   <span class="co">/** </span>
<span class="co">    *  If jsonPath matches the given detector function, creates a function which</span>
<span class="co">    *  evaluates against every clause in the clauseEvaluatorGenerators. The</span>
<span class="co">    *  created function is propagated to the onSuccess function, along with</span>
<span class="co">    *  the remaining unparsed JSONPath substring.</span>
<span class="co">    *  </span>
<span class="co">    *  The intended use is to create a clauseMatcher by filling in</span>
<span class="co">    *  the first two arguments, thus providing a function that knows</span>
<span class="co">    *  some syntax to match and what kind of generator to create if it</span>
<span class="co">    *  finds it. The parameter list once completed is:</span>
<span class="co">    *  </span>
<span class="co">    *    (jsonPath, parserGeneratedSoFar, onSuccess)</span>
<span class="co">    *  </span>
<span class="co">    *  onSuccess may be compileJsonPathToFunction, to recursively continue </span>
<span class="co">    *  parsing after finding a match or returnFoundParser to stop here.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">generateClauseReaderIfTokenFound</span> (
     
                        tokenDetector, clauseEvaluatorGenerators,
                         
                        jsonPath, parserGeneratedSoFar, onSuccess) {
                        
      <span class="kw">var</span> detected = <span class="fu">tokenDetector</span>(jsonPath);

      <span class="kw">if</span>(detected) {
         <span class="kw">var</span> compiledParser = <span class="fu">expressionsReader</span>(
                                 clauseEvaluatorGenerators, 
                                 parserGeneratedSoFar, 
                                 detected
                              ),
         
             remainingUnparsedJsonPath = <span class="ot">jsonPath</span>.<span class="fu">substr</span>(<span class="fu">len</span>(detected[<span class="dv">0</span>]));                
                               
         <span class="kw">return</span> <span class="fu">onSuccess</span>(remainingUnparsedJsonPath, compiledParser);
      }         
   }
                 
   <span class="co">/**</span>
<span class="co">    * Partially completes generateClauseReaderIfTokenFound above. </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">clauseMatcher</span>(tokenDetector, exprs) {
        
      <span class="kw">return</span>   <span class="fu">partialComplete</span>( 
                  generateClauseReaderIfTokenFound, 
                  tokenDetector, 
                  exprs 
               );
   }

   <span class="co">/**</span>
<span class="co">    * clauseForJsonPath is a function which attempts to match against </span>
<span class="co">    * several clause matchers in order until one matches. If non match the</span>
<span class="co">    * jsonPath expression is invalid and an error is thrown.</span>
<span class="co">    * </span>
<span class="co">    * The parameter list is the same as a single clauseMatcher:</span>
<span class="co">    * </span>
<span class="co">    *    (jsonPath, parserGeneratedSoFar, onSuccess)</span>
<span class="co">    */</span>     
   <span class="kw">var</span> clauseForJsonPath = <span class="fu">lazyUnion</span>(

      <span class="fu">clauseMatcher</span>(pathNodeSyntax   , <span class="fu">list</span>( capture, 
                                             duckTypeClause, 
                                             nameClause, 
                                             skip1 ))
                                                     
   ,  <span class="fu">clauseMatcher</span>(doubleDotSyntax  , <span class="fu">list</span>( skipMany))
       
       <span class="co">// dot is a separator only (like whitespace in other languages) but </span>
       <span class="co">// rather than make it a special case, use an empty list of </span>
       <span class="co">// expressions when this token is found</span>
   ,  <span class="fu">clauseMatcher</span>(dotSyntax        , <span class="fu">list</span>() )  
                                                                                      
   ,  <span class="fu">clauseMatcher</span>(bangSyntax       , <span class="fu">list</span>( capture,
                                             rootExpr))
                                                          
   ,  <span class="fu">clauseMatcher</span>(emptySyntax      , <span class="fu">list</span>( statementExpr))
   
   ,  <span class="kw">function</span> (jsonPath) {
         <span class="kw">throw</span> <span class="fu">Error</span>(<span class="st">&#39;&quot;&#39;</span> + jsonPath + <span class="st">&#39;&quot; could not be tokenised&#39;</span>)      
      }
   );


   <span class="co">/**</span>
<span class="co">    * One of two possible values for the onSuccess argument of </span>
<span class="co">    * generateClauseReaderIfTokenFound.</span>
<span class="co">    * </span>
<span class="co">    * When this function is used, generateClauseReaderIfTokenFound simply </span>
<span class="co">    * returns the compiledParser that it made, regardless of if there is </span>
<span class="co">    * any remaining jsonPath to be compiled.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">returnFoundParser</span>(_remainingJsonPath, compiledParser){ 
      <span class="kw">return</span> compiledParser 
   }     
              
   <span class="co">/**</span>
<span class="co">    * Recursively compile a JSONPath expression.</span>
<span class="co">    * </span>
<span class="co">    * This function serves as one of two possible values for the onSuccess </span>
<span class="co">    * argument of generateClauseReaderIfTokenFound, meaning continue to</span>
<span class="co">    * recursively compile. Otherwise, returnFoundParser is given and</span>
<span class="co">    * compilation terminates.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">compileJsonPathToFunction</span>( uncompiledJsonPath, 
                                       parserGeneratedSoFar ) {

      <span class="co">/**</span>
<span class="co">       * On finding a match, if there is remaining text to be compiled</span>
<span class="co">       * we want to either continue parsing using a recursive call to </span>
<span class="co">       * compileJsonPathToFunction. Otherwise, we want to stop and return </span>
<span class="co">       * the parser that we have found so far.</span>
<span class="co">       */</span>
      <span class="kw">var</span> onFind =      uncompiledJsonPath
                     ?  compileJsonPathToFunction 
                     :  returnFoundParser;
                   
      <span class="kw">return</span>   <span class="fu">clauseForJsonPath</span>( 
                  uncompiledJsonPath, 
                  parserGeneratedSoFar, 
                  onFind
               );                              
   }

   <span class="co">/**</span>
<span class="co">    * This is the function that we expose to the rest of the library.</span>
<span class="co">    */</span>
   <span class="kw">return</span> <span class="kw">function</span>(jsonPath){
        
      <span class="kw">try</span> {
         <span class="co">// Kick off the recursive parsing of the jsonPath </span>
         <span class="kw">return</span> <span class="fu">compileJsonPathToFunction</span>(jsonPath, always);
         
      } <span class="kw">catch</span>( e ) {
         <span class="kw">throw</span> <span class="fu">Error</span>( <span class="st">&#39;Could not compile &quot;&#39;</span> + jsonPath + 
                      <span class="st">&#39;&quot; because &#39;</span> + <span class="ot">e</span>.<span class="fu">message</span>
         );
      }
   }

});</code></pre>
<p></p>
</div>
<div id="jsonpathsyntax.js" class="section level2">
<h2><a href="#jsonpathsyntax.js"><span class="header-section-number">8.7</span> jsonPathSyntax.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> jsonPathSyntax = (<span class="kw">function</span>() {
 
   <span class="kw">var</span>
   
   <span class="co">/** </span>
<span class="co">    * Export a regular expression as a simple function by exposing just </span>
<span class="co">    * the Regex#exec. This allows regex tests to be used under the same </span>
<span class="co">    * interface as differently implemented tests, or for a user of the</span>
<span class="co">    * tests to not concern themselves with their implementation as regular</span>
<span class="co">    * expressions.</span>
<span class="co">    * </span>
<span class="co">    * This could also be expressed point-free as:</span>
<span class="co">    *   Function.prototype.bind.bind(RegExp.prototype.exec),</span>
<span class="co">    *   </span>
<span class="co">    * But that&#39;s far too confusing! (and not even smaller once minified </span>
<span class="co">    * and gzipped)</span>
<span class="co">    */</span>
       regexDescriptor = <span class="kw">function</span> <span class="fu">regexDescriptor</span>(regex) {
            <span class="kw">return</span> <span class="ot">regex</span>.<span class="ot">exec</span>.<span class="fu">bind</span>(regex);
       }
       
   <span class="co">/**</span>
<span class="co">    * Join several regular expressions and express as a function.</span>
<span class="co">    * This allows the token patterns to reuse component regular expressions</span>
<span class="co">    * instead of being expressed in full using huge and confusing regular</span>
<span class="co">    * expressions.</span>
<span class="co">    */</span>       
   ,   jsonPathClause = <span class="fu">varArgs</span>(<span class="kw">function</span>( componentRegexes ) {

            <span class="co">// The regular expressions all start with ^ because we </span>
            <span class="co">// only want to find matches at the start of the </span>
            <span class="co">// JSONPath fragment we are inspecting           </span>
            <span class="ot">componentRegexes</span>.<span class="fu">unshift</span>(<span class="ot">/</span><span class="fl">^</span><span class="ot">/</span>);
            
            <span class="kw">return</span>   <span class="fu">regexDescriptor</span>(
                        <span class="fu">RegExp</span>(
                           <span class="ot">componentRegexes</span>.<span class="fu">map</span>(<span class="fu">attr</span>(<span class="st">&#39;source&#39;</span>)).<span class="fu">join</span>(<span class="st">&#39;&#39;</span>)
                        )
                     );
       })
       
   ,   possiblyCapturing =           <span class="ot">/</span><span class="fl">(\$?)</span><span class="ot">/</span>
   ,   namedNode =                   <span class="ot">/</span><span class="fl">(</span><span class="bn">[</span><span class="fl">\w</span><span class="bn">-_]</span><span class="fl">+|\*)</span><span class="ot">/</span>
   ,   namePlaceholder =             <span class="ot">/</span><span class="fl">()</span><span class="ot">/</span>
   ,   nodeInArrayNotation =         <span class="ot">/</span><span class="fl">\[</span><span class="ot">&quot;</span><span class="fl">(</span><span class="bn">[</span><span class="fl">^</span><span class="bn">&quot;]</span><span class="fl">+)</span><span class="ot">&quot;</span><span class="fl">\]</span><span class="ot">/</span>
   ,   numberedNodeInArrayNotation = <span class="ot">/</span><span class="fl">\[(</span><span class="bn">\d</span><span class="fl">+|\*)\]</span><span class="ot">/</span>
   ,   fieldList =                      <span class="ot">/{</span><span class="fl">(</span><span class="bn">[</span><span class="fl">\w</span><span class="bn"> ]</span><span class="fl">*?)</span><span class="ot">}/</span>
   ,   optionalFieldList =           <span class="ot">/</span><span class="fl">(?</span><span class="ot">:{</span><span class="fl">(</span><span class="bn">[</span><span class="fl">\w</span><span class="bn"> ]</span><span class="fl">*?)</span><span class="ot">}</span><span class="fl">)?</span><span class="ot">/</span>
    

       <span class="co">//   foo or *                  </span>
   ,   jsonPathNamedNodeInObjectNotation   = <span class="fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                namedNode, 
                                                optionalFieldList
                                             )
                                             
       <span class="co">//   [&quot;foo&quot;]   </span>
   ,   jsonPathNamedNodeInArrayNotation    = <span class="fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                nodeInArrayNotation, 
                                                optionalFieldList
                                             )  

       <span class="co">//   [2] or [*]       </span>
   ,   jsonPathNumberedNodeInArrayNotation = <span class="fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                numberedNodeInArrayNotation, 
                                                optionalFieldList
                                             )

       <span class="co">//   {a b c}      </span>
   ,   jsonPathPureDuckTyping              = <span class="fu">jsonPathClause</span>( 
                                                possiblyCapturing, 
                                                namePlaceholder, 
                                                fieldList
                                             )
   
       <span class="co">//   ..</span>
   ,   jsonPathDoubleDot                   = <span class="fu">jsonPathClause</span>(<span class="ot">/</span><span class="fl">\.\.</span><span class="ot">/</span>)                  
   
       <span class="co">//   .</span>
   ,   jsonPathDot                         = <span class="fu">jsonPathClause</span>(<span class="ot">/</span><span class="fl">\.</span><span class="ot">/</span>)                    
   
       <span class="co">//   !</span>
   ,   jsonPathBang                        = <span class="fu">jsonPathClause</span>(
                                                possiblyCapturing, 
                                                <span class="ot">/!/</span>
                                             )  
   
       <span class="co">//   nada!</span>
   ,   emptyString                         = <span class="fu">jsonPathClause</span>(<span class="ot">/</span><span class="fl">$</span><span class="ot">/</span>)                     
   
   ;
   
  
   <span class="co">/* We export only a single function. When called, this function injects </span>
<span class="co">      into another function the descriptors from above.             </span>
<span class="co">    */</span>
   <span class="kw">return</span> <span class="kw">function</span> (fn){      
      <span class="kw">return</span> <span class="fu">fn</span>(      
         <span class="fu">lazyUnion</span>(
            jsonPathNamedNodeInObjectNotation
         ,  jsonPathNamedNodeInArrayNotation
         ,  jsonPathNumberedNodeInArrayNotation
         ,  jsonPathPureDuckTyping 
         )
      ,  jsonPathDoubleDot
      ,  jsonPathDot
      ,  jsonPathBang
      ,  emptyString 
      );
   }; 

}());</code></pre>
<p></p>
</div>
<div id="lists.js" class="section level2">
<h2><a href="#lists.js"><span class="header-section-number">8.8</span> lists.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * Like cons in Lisp</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">cons</span>(x, xs) {
   
   <span class="co">/* Internally lists are linked 2-element Javascript arrays.</span>
<span class="co">    </span>
<span class="co">      So that lists are all immutable we Object.freeze in newer </span>
<span class="co">      Javascript runtimes.</span>
<span class="co">      </span>
<span class="co">      In older engines freeze should have been polyfilled as the </span>
<span class="co">      identity function. */</span>
   <span class="kw">return</span> <span class="ot">Object</span>.<span class="fu">freeze</span>([x,xs]);
}

<span class="co">/**</span>
<span class="co"> * The empty list</span>
<span class="co"> */</span>
<span class="kw">var</span> emptyList = <span class="kw">null</span>,

<span class="co">/**</span>
<span class="co"> * Get the head of a list.</span>
<span class="co"> * </span>
<span class="co"> * Ie, head(cons(a,b)) = a</span>
<span class="co"> */</span>
    head = <span class="fu">attr</span>(<span class="dv">0</span>),

<span class="co">/**</span>
<span class="co"> * Get the tail of a list.</span>
<span class="co"> * </span>
<span class="co"> * Ie, head(cons(a,b)) = a</span>
<span class="co"> */</span>
    tail = <span class="fu">attr</span>(<span class="dv">1</span>);


<span class="co">/** </span>
<span class="co"> * Converts an array to a list </span>
<span class="co"> * </span>
<span class="co"> *    asList([a,b,c])</span>
<span class="co"> * </span>
<span class="co"> * is equivalent to:</span>
<span class="co"> *    </span>
<span class="co"> *    cons(a, cons(b, cons(c, emptyList))) </span>
<span class="co"> **/</span>
<span class="kw">function</span> <span class="fu">arrayAsList</span>(inputArray){

   <span class="kw">return</span> <span class="fu">reverseList</span>( 
      <span class="ot">inputArray</span>.<span class="fu">reduce</span>(
         <span class="fu">flip</span>(cons),
         emptyList 
      )
   );
}

<span class="co">/**</span>
<span class="co"> * A varargs version of arrayAsList. Works a bit like list</span>
<span class="co"> * in LISP.</span>
<span class="co"> * </span>
<span class="co"> *    list(a,b,c) </span>
<span class="co"> *    </span>
<span class="co"> * is equivalent to:</span>
<span class="co"> * </span>
<span class="co"> *    cons(a, cons(b, cons(c, emptyList)))</span>
<span class="co"> */</span>
<span class="kw">var</span> list = <span class="fu">varArgs</span>(arrayAsList);

<span class="co">/**</span>
<span class="co"> * Convert a list back to a js native array</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">listAsArray</span>(list){

   <span class="kw">return</span> <span class="fu">foldR</span>( <span class="kw">function</span>(arraySoFar, listItem){
      
      <span class="ot">arraySoFar</span>.<span class="fu">unshift</span>(listItem);
      <span class="kw">return</span> arraySoFar;
           
   }, [], list );
   
}

<span class="co">/**</span>
<span class="co"> * Map a function over a list </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">map</span>(fn, list) {

   <span class="kw">return</span> list
            ? <span class="fu">cons</span>(<span class="fu">fn</span>(<span class="fu">head</span>(list)), <span class="fu">map</span>(fn,<span class="fu">tail</span>(list)))
            : emptyList
            ;
}

<span class="co">/**</span>
<span class="co"> * foldR implementation. Reduce a list down to a single value.</span>
<span class="co"> * </span>
<span class="co"> * </span>@pram<span class="co"> {Function} fn     (rightEval, curVal) -&gt; result </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">foldR</span>(fn, startValue, list) {
      
   <span class="kw">return</span> list 
            ? <span class="fu">fn</span>(<span class="fu">foldR</span>(fn, startValue, <span class="fu">tail</span>(list)), <span class="fu">head</span>(list))
            : startValue
            ;
}

<span class="co">/** </span>
<span class="co"> * Returns true if the given function holds for every item in </span>
<span class="co"> * the list, false otherwise </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">all</span>(fn, list) {
   
   <span class="kw">return</span> !list || 
          <span class="fu">fn</span>(<span class="fu">head</span>(list)) &amp;&amp; <span class="fu">all</span>(fn, <span class="fu">tail</span>(list));
}

<span class="co">/**</span>
<span class="co"> * Apply a function to every item in a list</span>
<span class="co"> * </span>
<span class="co"> * This doesn&#39;t make any sense if we&#39;re doing pure functional because </span>
<span class="co"> * it doesn&#39;t return anything. Hence, this is only really useful if fn </span>
<span class="co"> * has side-effects. </span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">each</span>(fn, list) {

   <span class="kw">if</span>( list ){  
      <span class="fu">fn</span>(<span class="fu">head</span>(list));
      <span class="fu">each</span>(fn, <span class="fu">tail</span>(list));
   }
}

<span class="co">/**</span>
<span class="co"> * Reverse the order of a list</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">reverseList</span>(list){ 

   <span class="co">// js re-implementation of 3rd solution from:</span>
   <span class="co">//    http://www.haskell.org/haskellwiki/99_questions/Solutions/5</span>
   <span class="kw">function</span> <span class="fu">reverseInner</span>( list, reversedAlready ) {
      <span class="kw">if</span>( !list ) {
         <span class="kw">return</span> reversedAlready;
      }
      
      <span class="kw">return</span> <span class="fu">reverseInner</span>(<span class="fu">tail</span>(list), <span class="fu">cons</span>(<span class="fu">head</span>(list), reversedAlready))
   }

   <span class="kw">return</span> <span class="fu">reverseInner</span>(list, emptyList);
}</code></pre>
<p></p>
</div>
<div id="pubsub.js" class="section level2">
<h2><a href="#pubsub.js"><span class="header-section-number">8.9</span> pubSub.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * Isn&#39;t this the cutest little pub-sub you&#39;ve ever seen?</span>
<span class="co"> * </span>
<span class="co"> * Does not allow unsubscription because is never needed inside Oboe.</span>
<span class="co"> * Instead, when an Oboe instance is finished the whole of it should be</span>
<span class="co"> * available for GC&#39;ing.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">pubSub</span>(){

   <span class="kw">var</span> listeners = {};
                             
   <span class="kw">return</span> {

      <span class="dt">on</span>:<span class="kw">function</span>( eventId, fn ) {
         
         listeners[eventId] = <span class="fu">cons</span>(fn, listeners[eventId]);

         <span class="kw">return</span> <span class="kw">this</span>; <span class="co">// chaining</span>
      }, 
    
      <span class="dt">fire</span>:<span class="kw">function</span> ( eventId, event ) {
               
         <span class="fu">each</span>(
            <span class="fu">partialComplete</span>( apply, [event || <span class="kw">undefined</span>] ), 
            listeners[eventId]
         );
      }           
   };
}</code></pre>
<p></p>
</div>
<div id="publicapi.js" class="section level2">
<h2><a href="#publicapi.js"><span class="header-section-number">8.10</span> publicApi.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// export public API</span>
<span class="kw">var</span> oboe = <span class="fu">apiMethod</span>(<span class="st">&#39;GET&#39;</span>);
<span class="ot">oboe</span>.<span class="fu">doGet</span>    = oboe;
<span class="ot">oboe</span>.<span class="fu">doDelete</span> = <span class="fu">apiMethod</span>(<span class="st">&#39;DELETE&#39;</span>);
<span class="ot">oboe</span>.<span class="fu">doPost</span>   = <span class="fu">apiMethod</span>(<span class="st">&#39;POST&#39;</span>, <span class="kw">true</span>);
<span class="ot">oboe</span>.<span class="fu">doPut</span>    = <span class="fu">apiMethod</span>(<span class="st">&#39;PUT&#39;</span>, <span class="kw">true</span>);

<span class="kw">function</span> <span class="fu">apiMethod</span>(httpMethodName, mayHaveRequestBody) {
               
   <span class="kw">return</span> <span class="kw">function</span>(firstArg){
           
      <span class="kw">if</span> (<span class="fu">isString</span>(firstArg)) {
      
         <span class="co">// parameters specified as arguments</span>
         <span class="co">//</span>
         <span class="co">//  if (mayHaveContext == true) method signature is:</span>
         <span class="co">//     .doMethod( url, content )</span>
         <span class="co">//</span>
         <span class="co">//  else it is:</span>
         <span class="co">//     .doMethod( url )            </span>
         <span class="co">//                                </span>
         <span class="kw">return</span> <span class="fu">wire</span>(
                  httpMethodName,
                  firstArg,                                  <span class="co">// url</span>
                  mayHaveRequestBody &amp;&amp; arguments[<span class="dv">1</span>]         <span class="co">// body</span>
         );
      } <span class="kw">else</span> {
      
         <span class="co">// method signature is:</span>
         <span class="co">//    .doMethod({url:u, body:b, complete:c, headers:{...}})</span>
         
         <span class="kw">return</span> <span class="fu">wire</span>(   
                  httpMethodName,
                  <span class="ot">firstArg</span>.<span class="fu">url</span>,
                  <span class="ot">firstArg</span>.<span class="fu">body</span>,
                  <span class="ot">firstArg</span>.<span class="fu">headers</span> 
         );
      }
   };
}   </code></pre>
<p></p>
</div>
<div id="streaminghttp-browser.js" class="section level2">
<h2><a href="#streaminghttp-browser.js"><span class="header-section-number">8.11</span> streamingHttp-browser.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">httpTransport</span>(){
   <span class="kw">return</span> <span class="kw">new</span> <span class="fu">XMLHttpRequest</span>();
}

<span class="co">/**</span>
<span class="co"> * A wrapper around the browser XmlHttpRequest object that raises an </span>
<span class="co"> * event whenever a new part of the response is available.</span>
<span class="co"> * </span>
<span class="co"> * In older browsers progressive reading is impossible so all the </span>
<span class="co"> * content is given in a single call. For newer ones several events</span>
<span class="co"> * should be raised, allowing progressive interpretation of the response.</span>
<span class="co"> *      </span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> fire a function to pass events to when something happens</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> on a function to use to subscribe to events</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{XMLHttpRequest}</span><span class="co"> xhr the xhr to use as the transport. Under normal</span>
<span class="co"> *          operation, will have been created using httpTransport() above</span>
<span class="co"> *          but for tests a stub can be provided instead.</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String}</span><span class="co"> method one of &#39;GET&#39; &#39;POST&#39; &#39;PUT&#39; &#39;DELETE&#39;</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String}</span><span class="co"> url the url to make a request to</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String|Object}</span><span class="co"> data some content to be sent with the request.</span>
<span class="co"> *                        Only valid if method is POST or PUT.</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Object}</span><span class="co"> [headers] the http request headers to send                       </span>
<span class="co"> */</span>  
<span class="kw">function</span> <span class="fu">streamingHttp</span>(fire, on, xhr, method, url, data, headers) {
        
   <span class="kw">var</span> numberOfCharsAlreadyGivenToCallback = <span class="dv">0</span>;

   <span class="co">// When an ABORTING message is put on the event bus abort </span>
   <span class="co">// the ajax request         </span>
   <span class="fu">on</span>( ABORTING, <span class="kw">function</span>(){
  
      <span class="co">// if we keep the onreadystatechange while aborting the XHR gives </span>
      <span class="co">// a callback like a successful call so first remove this listener</span>
      <span class="co">// by assigning null:</span>
      <span class="ot">xhr</span>.<span class="fu">onreadystatechange</span> = <span class="kw">null</span>;
            
      <span class="ot">xhr</span>.<span class="fu">abort</span>();
   });

   <span class="co">/** Given a value from the user to send as the request body, return in</span>
<span class="co">    *  a form that is suitable to sending over the wire. Returns either a </span>
<span class="co">    *  string, or null.        </span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">validatedRequestBody</span>( body ) {
      <span class="kw">if</span>( !body )
         <span class="kw">return</span> <span class="kw">null</span>;
   
      <span class="kw">return</span> <span class="fu">isString</span>(body)? body: <span class="ot">JSON</span>.<span class="fu">stringify</span>(body);
   }      

   <span class="co">/** </span>
<span class="co">    * Handle input from the underlying xhr: either a state change,</span>
<span class="co">    * the progress event or the request being complete.</span>
<span class="co">    */</span>
   <span class="kw">function</span> <span class="fu">handleProgress</span>() {
                        
      <span class="kw">var</span> textSoFar = <span class="ot">xhr</span>.<span class="fu">responseText</span>,
          newText = <span class="ot">textSoFar</span>.<span class="fu">substr</span>(numberOfCharsAlreadyGivenToCallback);
      
      
      <span class="co">/* Raise the event for new text.</span>
<span class="co">      </span>
<span class="co">         On older browsers, the new text is the whole response. </span>
<span class="co">         On newer/better ones, the fragment part that we got since </span>
<span class="co">         last progress. */</span>
         
      <span class="kw">if</span>( newText ) {
         <span class="fu">fire</span>( NEW_CONTENT, newText );
      } 

      numberOfCharsAlreadyGivenToCallback = <span class="fu">len</span>(textSoFar);
   }
   
   
   <span class="kw">if</span>(<span class="st">&#39;onprogress&#39;</span> <span class="kw">in</span> xhr){  <span class="co">// detect browser support for progressive delivery</span>
      <span class="ot">xhr</span>.<span class="fu">onprogress</span> = handleProgress;
   }
   
   <span class="ot">xhr</span>.<span class="fu">onreadystatechange</span> = <span class="kw">function</span>() {
            
      <span class="kw">if</span>(<span class="ot">xhr</span>.<span class="fu">readyState</span> == <span class="dv">4</span> ) {

         <span class="co">// is this a 2xx http code?</span>
         <span class="kw">var</span> sucessful = <span class="fu">String</span>(<span class="ot">xhr</span>.<span class="fu">status</span>)[<span class="dv">0</span>] == <span class="dv">2</span>;
         
         <span class="kw">if</span>( sucessful ) {
            <span class="co">// In Chrome 29 (not 28) no onprogress is fired when a response</span>
            <span class="co">// is complete before the onload. We need to always do handleInput</span>
            <span class="co">// in case we get the load but have not had a final progress event.</span>
            <span class="co">// This looks like a bug and may change in future but let&#39;s take</span>
            <span class="co">// the safest approach and assume we might not have received a </span>
            <span class="co">// progress event for each part of the response</span>
            <span class="fu">handleProgress</span>();
            
            <span class="fu">fire</span>( END_OF_CONTENT );
         } <span class="kw">else</span> {
         
            <span class="fu">fire</span>( ERROR_EVENT, <span class="ot">xhr</span>.<span class="fu">status</span> );
         }
      }
   };

   <span class="kw">try</span>{
   
      <span class="ot">xhr</span>.<span class="fu">open</span>(method, url, <span class="kw">true</span>);
   
      <span class="kw">for</span>( <span class="kw">var</span> headerName <span class="kw">in</span> headers ){
         <span class="ot">xhr</span>.<span class="fu">setRequestHeader</span>(headerName, headers[headerName]);
      }
      
      <span class="ot">xhr</span>.<span class="fu">send</span>(<span class="fu">validatedRequestBody</span>(data));
      
   } <span class="kw">catch</span>( e ) {
      <span class="co">// To keep a consistent interface with Node, we can&#39;t fire an event here.</span>
      <span class="co">// Node&#39;s streaming http adaptor receives the error as an asynchronous</span>
      <span class="co">// event rather than as an exception. If we fired now, the Oboe user</span>
      <span class="co">// has had no chance to add a .fail listener so there is no way</span>
      <span class="co">// the event could be useful. For both these reasons defer the</span>
      <span class="co">// firing to the next JS frame.  </span>
      <span class="ot">window</span>.<span class="fu">setTimeout</span>(<span class="fu">partialComplete</span>(fire, ERROR_EVENT, e), <span class="dv">0</span>);
   }            
}</code></pre>
<p></p>
</div>
<div id="streaminghttp-node.js" class="section level2">
<h2><a href="#streaminghttp-node.js"><span class="header-section-number">8.12</span> streamingHttp-node.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">httpTransport</span>(){
   <span class="kw">return</span> <span class="fu">require</span>(<span class="st">&#39;http&#39;</span>);
}

<span class="co">/**</span>
<span class="co"> * A wrapper around the browser XmlHttpRequest object that raises an </span>
<span class="co"> * event whenever a new part of the response is available.</span>
<span class="co"> * </span>
<span class="co"> * In older browsers progressive reading is impossible so all the </span>
<span class="co"> * content is given in a single call. For newer ones several events</span>
<span class="co"> * should be raised, allowing progressive interpretation of the response.</span>
<span class="co"> *      </span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> fire a function to pass events to when something happens</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Function}</span><span class="co"> on a function to use to subscribe to events</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{XMLHttpRequest}</span><span class="co"> http the http implementation to use as the transport. Under normal</span>
<span class="co"> *          operation, will have been created using httpTransport() above</span>
<span class="co"> *          and therefore be Node&#39;s http</span>
<span class="co"> *          but for tests a stub may be provided instead.</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String}</span><span class="co"> method one of &#39;GET&#39; &#39;POST&#39; &#39;PUT&#39; &#39;DELETE&#39;</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String}</span><span class="co"> url the url to make a request to</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{String|Object}</span><span class="co"> data some content to be sent with the request.</span>
<span class="co"> *                        Only valid if method is POST or PUT.</span>
<span class="co"> * </span><span class="kw">@param</span><span class="co"> </span><span class="kw">{Object}</span><span class="co"> [headers] the http request headers to send                       </span>
<span class="co"> */</span>  
<span class="kw">function</span> <span class="fu">streamingHttp</span>(fire, on, http, method, url, data, headers) {
                        
   <span class="kw">if</span>( !<span class="ot">url</span>.<span class="fu">match</span>(<span class="ot">/http:</span><span class="fl">\/\/</span><span class="ot">/</span>) ) {
      url = <span class="st">&#39;http://&#39;</span> + url;
   }                           
                        
   <span class="kw">var</span> parsedUrl = <span class="fu">require</span>(<span class="st">&#39;url&#39;</span>).<span class="fu">parse</span>(url);

   <span class="kw">var</span> req = <span class="ot">http</span>.<span class="fu">request</span>({
      <span class="dt">hostname</span>: <span class="ot">parsedUrl</span>.<span class="fu">hostname</span>,
      <span class="dt">port</span>: <span class="ot">parsedUrl</span>.<span class="fu">port</span>,
      <span class="dt">path</span>: <span class="ot">parsedUrl</span>.<span class="fu">pathname</span>,
      <span class="dt">method</span>: method,
      <span class="dt">headers</span>: headers
   }, <span class="kw">function</span>(res) {
      
      <span class="kw">var</span> statusCode = <span class="ot">res</span>.<span class="fu">statusCode</span>,
          sucessful = <span class="fu">String</span>(statusCode)[<span class="dv">0</span>] == <span class="dv">2</span>;
                             
      <span class="kw">if</span>( sucessful ) {          
            
         <span class="ot">res</span>.<span class="fu">on</span>(<span class="st">&#39;data&#39;</span>, <span class="kw">function</span> (chunk) {
                           
            <span class="fu">fire</span>( NEW_CONTENT, <span class="ot">chunk</span>.<span class="fu">toString</span>() );
         });
         
         <span class="ot">res</span>.<span class="fu">on</span>(<span class="st">&#39;end&#39;</span>, <span class="kw">function</span>() {
                  
            <span class="fu">fire</span>( END_OF_CONTENT );
         });
         
      } <span class="kw">else</span> {
      
         <span class="fu">fire</span>( ERROR_EVENT, statusCode );
      }
   });
   
   <span class="ot">req</span>.<span class="fu">on</span>(<span class="st">&#39;error&#39;</span>, <span class="kw">function</span>(e) {
      <span class="fu">fire</span>( ERROR_EVENT, e );
   });
   
   <span class="fu">on</span>( ABORTING, <span class="kw">function</span>(){              
      <span class="ot">req</span>.<span class="fu">abort</span>();
   });
      
   <span class="kw">if</span>( data ) {
      <span class="kw">var</span> body = <span class="fu">isString</span>(data)? data: <span class="ot">JSON</span>.<span class="fu">stringify</span>(data);
      <span class="ot">req</span>.<span class="fu">write</span>(body);
   }
   
   <span class="ot">req</span>.<span class="fu">end</span>();

}</code></pre>
<p></p>
</div>
<div id="util.js" class="section level2">
<h2><a href="#util.js"><span class="header-section-number">8.13</span> util.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * This file defines some loosely associated syntactic sugar for </span>
<span class="co"> * Javascript programming </span>
<span class="co"> */</span>


<span class="co">/**</span>
<span class="co"> * Returns true if the given candidate is of type T</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">isOfType</span>(T, maybeSomething){
   <span class="kw">return</span> maybeSomething &amp;&amp; <span class="ot">maybeSomething</span>.<span class="fu">constructor</span> === T;
}
<span class="kw">function</span> <span class="fu">pluck</span>(key, object){
   <span class="kw">return</span> object[key];
}

<span class="kw">var</span> attr = <span class="fu">partialComplete</span>(partialComplete, pluck),
    len = <span class="fu">attr</span>(<span class="st">&#39;length&#39;</span>),    
    isString = <span class="fu">partialComplete</span>(isOfType, String);

<span class="co">/** </span>
<span class="co"> * I don&#39;t like saying this:</span>
<span class="co"> * </span>
<span class="co"> *    foo !=== undefined</span>
<span class="co"> *    </span>
<span class="co"> * because of the double-negative. I find this:</span>
<span class="co"> * </span>
<span class="co"> *    defined(foo)</span>
<span class="co"> *    </span>
<span class="co"> * easier to read.</span>
<span class="co"> */</span> 
<span class="kw">function</span> <span class="fu">defined</span>( value ) {
   <span class="kw">return</span> value !== <span class="kw">undefined</span>;
}

<span class="kw">function</span> <span class="fu">always</span>(){<span class="kw">return</span> <span class="kw">true</span>}

<span class="co">/**</span>
<span class="co"> * Returns true if object o has a key named like every property in </span>
<span class="co"> * the properties array. Will give false if any are missing, or if o </span>
<span class="co"> * is not an object.</span>
<span class="co"> */</span>
<span class="kw">function</span> <span class="fu">hasAllProperties</span>(fieldList, o) {

   <span class="kw">return</span>      (o <span class="kw">instanceof</span> Object) 
            &amp;&amp;
               <span class="fu">all</span>(<span class="kw">function</span> (field) {         
                  <span class="kw">return</span> (field <span class="kw">in</span> o);         
               }, fieldList);
}</code></pre>
<p></p>
</div>
<div id="wire.js" class="section level2">
<h2><a href="#wire.js"><span class="header-section-number">8.14</span> wire.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**</span>
<span class="co"> * This file sits just behind the API which is used to attain a new</span>
<span class="co"> * Oboe instance. It creates the new components that are required</span>
<span class="co"> * and introduces them to each other.</span>
<span class="co"> */</span>

<span class="kw">function</span> <span class="fu">wire</span> (httpMethodName, url, body, headers){

   <span class="kw">var</span> eventBus = <span class="fu">pubSub</span>();
               
   <span class="fu">streamingHttp</span>( <span class="ot">eventBus</span>.<span class="fu">fire</span>, <span class="ot">eventBus</span>.<span class="fu">on</span>,
                  <span class="fu">httpTransport</span>(), 
                  httpMethodName, url, body, headers );                              
     
   <span class="kw">return</span> <span class="fu">instanceController</span>( 
               <span class="ot">eventBus</span>.<span class="fu">fire</span>, <span class="ot">eventBus</span>.<span class="fu">on</span>, 
               <span class="ot">clarinet</span>.<span class="fu">parser</span>(), 
               <span class="fu">incrementalContentBuilder</span>(<span class="ot">eventBus</span>.<span class="fu">fire</span>) 
   );
}</code></pre>
</div>
</div>
<div id="appendix-iii-benchmarking" class="section level1">
<h1><a href="#appendix-iii-benchmarking"><span class="header-section-number">9</span> Appendix iii: Benchmarking</a></h1>
<div id="benchmarkclient.js" class="section level2">
<h2><a href="#benchmarkclient.js"><span class="header-section-number">9.1</span> benchmarkClient.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="co">/* call this script from the command line with first argument either</span>
<span class="co">    oboe, jsonParse, or clarinet.</span>
<span class="co">    </span>
<span class="co">   This script won&#39;t time the events, I&#39;m using `time` on the command line</span>
<span class="co">   to keep things simple.</span>
<span class="co"> */</span>

<span class="fu">require</span>(<span class="st">&#39;color&#39;</span>);

<span class="kw">var</span> DB_URL = <span class="st">&#39;http://localhost:4444/db&#39;</span>;  


<span class="kw">function</span> <span class="fu">aggregateWithOboe</span>() {

   <span class="kw">var</span> oboe = <span class="fu">require</span>(<span class="st">&#39;../dist/oboe-node.js&#39;</span>);
   
   <span class="fu">oboe</span>(DB_URL).<span class="fu">node</span>(<span class="st">&#39;{id url}.url&#39;</span>, <span class="kw">function</span>(url){
           
      <span class="fu">oboe</span>(url).<span class="fu">node</span>(<span class="st">&#39;name&#39;</span>, <span class="kw">function</span>(name){
                      
         <span class="ot">console</span>.<span class="fu">log</span>(name);
         <span class="kw">this</span>.<span class="fu">abort</span>();
         <span class="ot">console</span>.<span class="fu">log</span>( <span class="ot">process</span>.<span class="fu">memoryUsage</span>().<span class="fu">heapUsed</span> );         
      });      
   });                 
}

<span class="kw">function</span> <span class="fu">aggregateWithJsonParse</span>() {

   <span class="kw">var</span> getJson = <span class="fu">require</span>(<span class="st">&#39;get-json&#39;</span>);

   <span class="fu">getJson</span>(DB_URL, <span class="kw">function</span>(err, records) {
       
      <span class="ot">records</span>.<span class="ot">data</span>.<span class="fu">forEach</span>( <span class="kw">function</span>( record ){
       
         <span class="kw">var</span> url = <span class="ot">record</span>.<span class="fu">url</span>;
         
         <span class="fu">getJson</span>(url, <span class="kw">function</span>(err, record) {
            <span class="ot">console</span>.<span class="fu">log</span>(<span class="ot">record</span>.<span class="fu">name</span>);
            <span class="ot">console</span>.<span class="fu">log</span>( <span class="ot">process</span>.<span class="fu">memoryUsage</span>().<span class="fu">heapUsed</span> );
         });
      });

   });   

}


<span class="kw">function</span> <span class="fu">aggregateWithClarinet</span>() {

   <span class="kw">var</span> clarinet = <span class="fu">require</span>(<span class="st">&#39;clarinet&#39;</span>);   
   <span class="kw">var</span> http = <span class="fu">require</span>(<span class="st">&#39;http&#39;</span>);
   <span class="kw">var</span> outerClarinetStream = <span class="ot">clarinet</span>.<span class="fu">createStream</span>();
   <span class="kw">var</span> outerKey;
   
   <span class="kw">var</span> outerRequest = <span class="ot">http</span>.<span class="fu">request</span>(DB_URL, <span class="kw">function</span>(res) {
                              
      <span class="ot">res</span>.<span class="fu">pipe</span>(outerClarinetStream);
   });
   
   outerClarinetStream = <span class="ot">clarinet</span>.<span class="fu">createStream</span>();
      
   <span class="ot">outerRequest</span>.<span class="fu">end</span>();
      
   <span class="ot">outerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;openobject&#39;</span>, <span class="kw">function</span>( keyName ){      
      <span class="kw">if</span>( keyName ) {
         outerKey = keyName;      
      }
   });
   
   <span class="ot">outerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;key&#39;</span>, <span class="kw">function</span>(keyName){
      outerKey = keyName;
   });
   
   <span class="ot">outerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;value&#39;</span>, <span class="kw">function</span>(value){
      <span class="kw">if</span>( outerKey == <span class="st">&#39;url&#39;</span> ) {
         <span class="fu">innerRequest</span>(value)
      }
   });      
   
   
   <span class="kw">function</span> <span class="fu">innerRequest</span>(url) {
      
      <span class="kw">var</span> innerRequest = <span class="ot">http</span>.<span class="fu">request</span>(url, <span class="kw">function</span>(res) {
                                 
         <span class="ot">res</span>.<span class="fu">pipe</span>(innerClarinetStream);
      });
      
      <span class="kw">var</span> innerClarinetStream = <span class="ot">clarinet</span>.<span class="fu">createStream</span>();
      
      <span class="ot">innerRequest</span>.<span class="fu">end</span>();            
      
      <span class="kw">var</span> innerKey;
      
      <span class="ot">innerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;openobject&#39;</span>, <span class="kw">function</span>( keyName ){      
         <span class="kw">if</span>( keyName ) {
            innerKey = keyName;      
         }
      });
      
      <span class="ot">innerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;key&#39;</span>, <span class="kw">function</span>(keyName){
         innerKey = keyName;
      });
      
      <span class="ot">innerClarinetStream</span>.<span class="fu">on</span>(<span class="st">&#39;value&#39;</span>, <span class="kw">function</span>(value){
         <span class="kw">if</span>( innerKey == <span class="st">&#39;name&#39;</span> ) {
            <span class="ot">console</span>.<span class="fu">log</span>( value )
            <span class="ot">console</span>.<span class="fu">log</span>( <span class="ot">process</span>.<span class="fu">memoryUsage</span>().<span class="fu">heapUsed</span> );            
         }
      });            
   }
}

<span class="kw">var</span> strategies = {
   <span class="dt">oboe</span>:       aggregateWithOboe,
   <span class="dt">jsonParse</span>:  aggregateWithJsonParse,
   <span class="dt">clarinet</span>:   aggregateWithClarinet
}

<span class="kw">var</span> strategyName = <span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>];

<span class="co">// use any of the above three strategies depending on a command line argument:</span>
<span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;benchmarking strategy&#39;</span>, strategyName);

strategies[strategyName]();
</code></pre>
<p></p>
</div>
<div id="benchmarkserver.js" class="section level2">
<h2><a href="#benchmarkserver.js"><span class="header-section-number">9.2</span> benchmarkServer.js</a></h2>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/**   </span>
<span class="co"> */</span>

<span class="st">&quot;use strict&quot;</span>;

<span class="kw">var</span> PORT = <span class="dv">4444</span>;

<span class="kw">var</span> TIME_BETWEEN_RECORDS = <span class="dv">15</span>;
<span class="co">// 80 records but only every other one has a URL:</span>
<span class="kw">var</span> NUMBER_OF_RECORDS = <span class="dv">80</span>;

<span class="kw">function</span> <span class="fu">sendJsonHeaders</span>(res) {
   <span class="kw">var</span> JSON_MIME_TYPE = <span class="st">&quot;application/octet-stream&quot;</span>;
   <span class="ot">res</span>.<span class="fu">setHeader</span>(<span class="st">&quot;Content-Type&quot;</span>, JSON_MIME_TYPE);
   <span class="ot">res</span>.<span class="fu">writeHead</span>(<span class="dv">200</span>);
}

<span class="kw">function</span> <span class="fu">serveItemList</span>(_req, res) {

   <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;slow number server: send simulated database data&#39;</span>);

   <span class="ot">res</span>.<span class="fu">write</span>(<span class="st">&#39;{&quot;data&quot;: [&#39;</span>);

   <span class="kw">var</span> i = <span class="dv">0</span>;

   <span class="kw">var</span> inervalId = <span class="fu">setInterval</span>(<span class="kw">function</span> () {

      <span class="kw">if</span>( i % <span class="dv">2</span> == <span class="dv">0</span> ) {

         <span class="ot">res</span>.<span class="fu">write</span>(<span class="ot">JSON</span>.<span class="fu">stringify</span>({
            <span class="st">&quot;id&quot;</span>: i,
            <span class="st">&quot;url&quot;</span>: <span class="st">&quot;http://localhost:4444/item/&quot;</span> + i         
         }));
      } <span class="kw">else</span> {
         <span class="ot">res</span>.<span class="fu">write</span>(<span class="ot">JSON</span>.<span class="fu">stringify</span>({
            <span class="st">&quot;id&quot;</span>: i         
         }));      
      }
      
      <span class="kw">if</span> (i == NUMBER_OF_RECORDS) {

         <span class="ot">res</span>.<span class="fu">end</span>(<span class="st">&#39;]}&#39;</span>);
         
         <span class="fu">clearInterval</span>(inervalId);
         
         <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;db server: finished writing to stream&#39;</span>);
      } <span class="kw">else</span> {
         <span class="ot">res</span>.<span class="fu">write</span>(<span class="st">&#39;,&#39;</span>);
      }
      
      i++;  

   }, TIME_BETWEEN_RECORDS);
}

<span class="kw">function</span> <span class="fu">serveItem</span>(req, res){

   <span class="kw">var</span> id = <span class="ot">req</span>.<span class="ot">params</span>.<span class="fu">id</span>;
   
   <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;will output fake record with id&#39;</span>, id);     

   <span class="fu">setTimeout</span>(<span class="kw">function</span>(){
      <span class="co">// the items served are all the same except for the id field.</span>
      <span class="co">// this is realistic looking but randomly generated object fro</span>
      <span class="co">// &lt;project&gt;/test/json/oneHundredrecords.json   </span>
      <span class="ot">res</span>.<span class="fu">end</span>(<span class="ot">JSON</span>.<span class="fu">stringify</span>({
         <span class="st">&quot;id&quot;</span> : id,
         <span class="st">&quot;url&quot;</span>: <span class="st">&quot;http://localhost:4444/item/&quot;</span> + id,      
         <span class="st">&quot;guid&quot;</span>: <span class="st">&quot;046447ee-da78-478c-b518-b612111942a5&quot;</span>,
         <span class="st">&quot;picture&quot;</span>: <span class="st">&quot;http://placehold.it/32x32&quot;</span>,
         <span class="st">&quot;age&quot;</span>: <span class="dv">37</span>,
         <span class="st">&quot;name&quot;</span>: <span class="st">&quot;Humanoid robot number &quot;</span> + id,
         <span class="st">&quot;company&quot;</span>: <span class="st">&quot;Robotomic&quot;</span>,
         <span class="st">&quot;phone&quot;</span>: <span class="st">&quot;806-587-2379&quot;</span>,
         <span class="st">&quot;email&quot;</span>: <span class="st">&quot;payton@robotomic.com&quot;</span>
      }));
            
   }, TIME_BETWEEN_RECORDS);

}

<span class="kw">function</span> <span class="fu">routing</span>() {
   <span class="kw">var</span> Router = <span class="fu">require</span>(<span class="st">&#39;node-simple-router&#39;</span>),
       router = <span class="fu">Router</span>();

   <span class="ot">router</span>.<span class="fu">get</span>( <span class="st">&#39;/db&#39;</span>,         serveItemList);
   <span class="ot">router</span>.<span class="fu">get</span>( <span class="st">&#39;/item/:id&#39;</span>,   serveItem);
   
   <span class="kw">return</span> router;
}
      
<span class="kw">var</span> server = <span class="fu">require</span>(<span class="st">&#39;http&#39;</span>).<span class="fu">createServer</span>(<span class="fu">routing</span>()).<span class="fu">listen</span>(PORT);

<span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&#39;Benchmark server started on port&#39;</span>, <span class="fu">String</span>(PORT));</code></pre>
</div>
</div>
<div id="bibliography" class="section level1">
<h1><a href="#bibliography"><span class="header-section-number">10</span> Bibliography</a></h1>
<p>Ahuvia, Yogev. 2013. “Design Patterns: Infinite Scrolling: Let’s Get To The Bottom Of This http://uxdesign.smashingmagazine.com/2013/05/03/infinite-scrolling-get-bottom/.” Smashing Magazine.</p>
<p>Conway, Mel. 2004. <em>Humanizing Application Building: An Anthropological Perspective</em>. <a href="http://melconway.com/Home/pdf/humanize.pdf" title="http://melconway.com/Home/pdf/humanize.pdf">http://melconway.com/Home/pdf/humanize.pdf</a>.</p>
<p>Douglas, Crockford. 2009. “JSON: The fat-free alternative to XML.” <a href="http://json.org" title="http://json.org">http://json.org</a>.</p>
<p>Etemad, Elika J, and Tab Atkins. 2013. “Selectors Level 4.” <a href="http://dev.w3.org/csswg/selectors4/" title="http://dev.w3.org/csswg/selectors4/">http://dev.w3.org/csswg/selectors4/</a>.</p>
<p>Fielding, R. T. 2000. “Principled design of the modern Web architecture.”</p>
<p>Geelhoed, Erik, Peter Toft, Suzanne Roberts, and Patrick Hyland. 1995. “To influence Time Perception.” Hewlett Packard Labs. <a href="http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm" title="http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm">http://www.sigchi.org/chi95/proceedings/shortppr/egd_bdy.htm</a>.</p>
<p>Gill, Brendan. 2013. “OpenSignal.”</p>
<p>Guo, shu-yu. 2013. “Two Reasons Functional Style Is Slow in SpiderMonkey.” <a href="http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html" title="http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html">http://rfrn.org//~shu/2013/03/20/two-reasons-functional-style-is-slow-in-spidermonkey.html</a>.</p>
<p>Lea, Tom. 2012. “Improving performance on twitter.com.” <a href="[https://blog.twitter.com/2012/improving-performance-twittercom]" title="[https://blog.twitter.com/2012/improving-performance-twittercom]">[https://blog.twitter.com/2012/improving-performance-twittercom]</a>.</p>
<p>Martin, Robert “Uncle Bob.” 2008. <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>.</p>
<p>McLuhan, Marshall. 1964. <em>Understanding Media: The Extensions of Man</em>.</p>
<p>Mullany, Michael. 2013. “5 Myths About Mobile Web Performance.” <a href="http://www.sencha.com/blog/5-myths-about-mobile-web-performance" title="http://www.sencha.com/blog/5-myths-about-mobile-web-performance">http://www.sencha.com/blog/5-myths-about-mobile-web-performance</a>.</p>
<p>Ogden, Max. 2012. “Streaming XHR.” <a href="http://maxogden.com/a-proposal-for-streaming-xhr.html" title="http://maxogden.com/a-proposal-for-streaming-xhr.html">http://maxogden.com/a-proposal-for-streaming-xhr.html</a>.</p>
<p>Reis, Eric. 2011. <em>The Lean Startup: How Today’s Entrepreneurs Use Continuous Innovation to Create Radically Successful Businesses.</em> Crown Business Publishing.</p>
<p>Stefanov, Stoyan. 2009. “Progressive rendering via multiple flushes.” <a href="http://www.phpied.com/progressive-rendering-via-multiple-flushes/" title="http://www.phpied.com/progressive-rendering-via-multiple-flushes/">http://www.phpied.com/progressive-rendering-via-multiple-flushes/</a>.</p>
<p>Whorf, B. L. 1956. “Language, Thought and Reality (ed. J. B. Carroll).” Cambridge, MA: MIT Press.</p>
<p>Yukihiro, Matsumoto. 2003. “The Power and Philosophy of Ruby.” <a href="http://www.rubyist.net/~matz/slides/oscon2003/index.html" title="http://www.rubyist.net/~matz/slides/oscon2003/index.html">http://www.rubyist.net/~matz/slides/oscon2003/index.html</a>.</p>
<p>van Kesteren, Anne. 2012. “XMLHttpRequest Level 2 Working Draft.” <a href="http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications" title="http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications">http://www.w3.org/TR/XMLHttpRequest2/#make-progress-notifications</a>.</p>
<p>van Kesteren, Anne, and Dean Jackson. 2006. “The XMLHttpRequest Object.” <a href="http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/" title="http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/">http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/</a>.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For quite an obviously visible example of progressive SVG loading, try loading this SVG using a recent version of Google Chrome: <a href="http://upload.wikimedia.org/wikipedia/commons/0/04/Marriage_(Same-Sex_Couples)_Bill,_Second_Reading.svg">http://upload.wikimedia.org/wikipedia/commons/0/04/Marriage_(Same-Sex_Couples)_Bill,_Second_Reading.svg</a> For the perfectionist SVG artist, not just the final image should be considered but also the XML source order, for example in this case it would be helpful if the outline of the UK appeared first and the exploded sections last.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>See <a href="http://jackson.codehaus.org/1.0.1/javadoc/org/codehaus/jackson/node/NullNode.html">http://jackson.codehaus.org/1.0.1/javadoc/org/codehaus/jackson/node/NullNode.html</a>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://microjs.com/">Http://microjs.com/</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://github.com/substack/http-browserify">Https://github.com/substack/http-browserify</a>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="https://github.com/jimhigson/oboe.js/blob/master/src/streamingXhr.js">Https://github.com/jimhigson/oboe.js/blob/master/src/streamingXhr.js</a> This version is shorter mostly because it is not a generic solution.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Object/freeze">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Object/freeze</a>. Although older engines don't provide any ability to create immutable objects at run-time, we can be fairly certain that the code does not mutate these objects or the tests would fail when run in environments which are able to enforce this.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>JSONPath compiler from the first commit can be found at line 159 here: <a href="https://github.com/jimhigson/oboe.js/blob/a17db7accc3a371853a2a0fd755153b10994c91e/src/main/progressive.js">https://github.com/jimhigson/oboe.js/blob/a17db7accc3a371853a2a0fd755153b10994c91e/src/main/progressive.js</a>#L159.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>For contrast, the current source can be found at <a href="https://github.com/jimhigson/oboe.js/blob/master/src/jsonPath.js">https://github.com/jimhigson/oboe.js/blob/master/src/jsonPath.js</a>.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>The current tests are viewable at <a href="https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPath.unit.spec.js">https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPath.unit.spec.js</a> and <a href="https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPathTokens.unit.spec.js">https://github.com/jimhigson/oboe.js/blob/master/test/specs/jsonPathTokens.unit.spec.js</a>.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Probably the best known example being <code>memoize</code> from Underscore.js: <a href="http://underscorejs.org/">http://underscorejs.org/</a>#memoize.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular\_Expressions">Https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular\_Expressions</a>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p><a href="http://mattgemmell.com/2011/07/25/network-link-conditioner-in-lion/">Http://mattgemmell.com/2011/07/25/network-link-conditioner-in-lion/</a>.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p><a href="http://writings.nunojob.com/2011/12/clarinet-sax-based-evented-streaming-json-parser-in-javascript-for-the-browser-and-nodejs.html">Http://writings.nunojob.com/2011/12/clarinet-sax-based-evented-streaming-json-parser-in-javascript-for-the-browser-and-nodejs.html</a>.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>At time of writing, Firefox is the only engine supporting WeakHashMap by default. In Chome it is implemented but not available to Javascript unless explicitly enabled by a browser flag. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/WeakMap">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/WeakMap</a> retrieved 11th October 2013.<a href="#fnref14">↩</a></p></li>
</ol>
</div>
</body>
</html>
