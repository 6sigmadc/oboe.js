<h1 id="abstract"><a href="#abstract"><span class="header-section-number">1</span> Abstract</a></h1>
<p><strong>100-200 words</strong></p>
<h1 id="introduction"><a href="#introduction"><span class="header-section-number">2</span> Introduction</a></h1>
<p><strong>introduction should be 2-5 pages</strong></p>
<h1 id="background"><a href="#background"><span class="header-section-number">3</span> Background</a></h1>
<p><strong>background should be 2-10 pages</strong></p>
<p>SOA</p>
<p>REST/WebServices (WSDL etc)</p>
<p>What is a rest client in this context (a client library)</p>
<p>Marshalling/ de-marshalling. Benefits and the problems that it causes. Allows one model to be written out to XML or JSON</p>
<p>Big/small message problem and granularity. With small: http overhead. With big: not all may be needed.</p>
<h2 id="parsing-sax-and-dom"><a href="#parsing-sax-and-dom"><span class="header-section-number">3.1</span> Parsing: SAX and Dom</a></h2>
<p>Why sax is difficult</p>
<p>DOM parser can be built on a SAX parser</p>
<h2 id="state-of-http-as-a-streaming-technology"><a href="#state-of-http-as-a-streaming-technology"><span class="header-section-number">3.2</span> State of http as a streaming technology</a></h2>
<p>Dichotamy between streaming and downloading in the browser for downloading data. But not for html (progressive rendering) or images (progressive PNGs and progressive JPEGs)</p>
<p>Lack of support in browser Long poll - for infrequent push messages. Must be read Writing script tags</p>
<p>All require server to have a special mode. Encoding is specific to get arround restrictions.</p>
<h2 id="xmlhttprequest"><a href="#xmlhttprequest"><span class="header-section-number">3.3</span> XmlHttpRequest</a></h2>
<p><em>XmlHttpRequest</em> (XHR)</p>
<p>Xhr2 and the .onprogress callback</p>
<h1 id="applicaiton-and-reflection"><a href="#applicaiton-and-reflection"><span class="header-section-number">4</span> Applicaiton and Reflection</a></h1>
<p><strong>40 to 60 pages</strong></p>
<p>Focus on replacing ajax, rather than streaming. In older browsers, getting the whole message at once is no worse than it is now.</p>
<div class="figure">
<img src="images/timeline.png" alt="Over several hops of aggregation, the benefits of finding the interesting parts early" /><p class="caption">Over several hops of aggregation, the benefits of finding the interesting parts early</p>
</div>
<h2 id="choice-of-technologies"><a href="#choice-of-technologies"><span class="header-section-number">4.1</span> choice of technologies</a></h2>
<p>can justify why js as:</p>
<p>Most widely deployable.</p>
<p>Node: asynchronous model built into language already, no 'concurrent' library needed. Closures convenient for picking up again where left off.</p>
<p>Node programs often so asynchronous and callback based they become unclear in structure. Promises approach to avoid pyramid-shaped code and callback spaghetti.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// example of pyramid code</span></code></pre>
<p>In comparison to typical Tomcat-style threading model. Threaded model is powerful for genuine parallel computation but Wasteful of resources where the tasks are more io-bound than cpu-bound. Resources consumed by threads while doing nothing but waiting.</p>
<p>Compare to Erlang. Waiter model. Node resturaunt much more efficient use of expensive resources.</p>
<p>funcitonal, pure functional possible [FPR] but not as nicely as in a pure functional language, ie function caches although can be implemented, not universal on all functions.</p>
<p>easy to distribute softare (npm etc)</p>
<h2 id="summary-of-json"><a href="#summary-of-json"><span class="header-section-number">4.2</span> summary of json</a></h2>
<p>Why json?</p>
<p>A bridge between languages that isn't too different from the common types in the languages themselves a common bridge between languages</p>
<p>Also very simple. Easy to parse.</p>
<h2 id="identifying-interesting-objects-in-the-stream"><a href="#identifying-interesting-objects-in-the-stream"><span class="header-section-number">4.3</span> identifying interesting objects in the stream</a></h2>
<p>The failure of sax: requires programmer to do a lot of work to identify interesting things. Eg, to find tag address inside tag person with a given name, have to recognise three things while reieving a callback for every single element and attribute in the document. As a principle, the programmer should only have to handle the cases which are interesting to them, not wade manually through a haystack in search of a needle, which means the library should provide an expressive way of associating the nodes of interest with their targetted callbacks.</p>
<p>First way to identify an interesting thing is by its location in the document. In the absense of node typing beyond the categorisation as objects, arrays and various primative types, the key immediately mapping to the object is often taken as a lose concept of the type of the object. Quite fortunately, rather than because of a well considered object design, this tends to play well with automatically marshaling of domain objects expressed in a Java-style OO language because there is a stong tendency for field names -- and by extension, 'get' methods -- to be named after the <em>type</em> of the field, the name of the type also serving as a rough summary of the relationship between two objects. See figure  below.</p>
<div class="figure">
<img src="images/marshall.png" alt="UML class diagram showing a person class in relationship with an address class. In implementation as Java the &#39;hasAddress&#39; relationship would typically be reified as a getAddress method. This co-incidence of object type and the name of the field referring to the type lends itself well to the tendency for the immediate key before an object to be taken as the type when Java models are marshaled into json " /><p class="caption">UML class diagram showing a person class in relationship with an address class. In implementation as Java the 'hasAddress' relationship would typically be reified as a getAddress method. This co-incidence of object type and the name of the field referring to the type lends itself well to the tendency for the immediate key before an object to be taken as the type when Java models are marshaled into json </p>
</div>
<p>By sensible convention, even in a serialisation format with only a loose definition of lists, lists contain only items of the same type. This gives way to a sister convention, that for lists of items, the key immediately linking to the</p>
<p>Essentially two ways to identify an interesting node - by location (covered by existing jsonpath)</p>
<p>Why duck typing is desirable in absense of genuine types in the json standard (ala tag names in XML). or by a loose concept of type which is not well supported by existing jsonpath spec. Object syntax for listing fields.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">
Examples of jsonpath syntax</code></pre>
<h2 id="breaking-out-of-bigsmall-tradeoff"><a href="#breaking-out-of-bigsmall-tradeoff"><span class="header-section-number">4.4</span> breaking out of big/small tradeoff</a></h2>
<p>Best of both modes</p>
<p>Granularity: only need read as far as necessary. Services could be designed to write the big picture first. Alternatively, where resources link to one another, can stop reading at the link. Eg, looking for a person's publications, start with an index of people but no need to read whole list of people.</p>
<p>Aborting http request may not stop processing on the server. Why this is perhaps desirable - transactions, leaving resources in a half-complete state.</p>
<h2 id="styles-of-programming"><a href="#styles-of-programming"><span class="header-section-number">4.5</span> styles of programming</a></h2>
<p>some of it is pure functional (jsonPath, controller) ie, only semantically different from a Haskell programme others, syntactically functional but stateful to fit in with expected APIs etc</p>
<p>JsonPath implementation allows the compilation of complex expressions into an executable form, but each part implementing the executable form is locally simple. By using recursion, assembling the simple functions into a more function expressing a more complex rule also follows as being locally simple but gaining a usefully sophisticated behaviour through composition of simple parts. Each recursive call of the parser identifies one token for non-empty input and then recursively digests the rest.</p>
<p>The style of implementation of the generator of functions corresponding to json path expressions is reminiscent of a traditional parser generator, although rather than generating source, functions are dynamically composed. Reflecting on this, parser gens only went to source to break out of the ability to compose the expressive power of the language itself from inside the language itself. With a functional approach, assembly from very small pieces gives a similar level of expressivity as writing the logic out as source code.</p>
<h2 id="composition-of-several-source-files-into-a-distributable-binary-like-text-file"><a href="#composition-of-several-source-files-into-a-distributable-binary-like-text-file"><span class="header-section-number">4.6</span> composition of several source files into a distributable binary-like text file</a></h2>
<p>Why distributed javascript is more like a binary than a source file. Licencing implications?</p>
<p>Inherent hiding by wrapping in a scope.</p>
<p>Names of functions and variable names which are provably not possible to reference are lost for the sake of reduction of size of the source.</p>
<p>Packaging for node or browser. No need to minify for node but concatenation still done for ease of inclusion in projects</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">typical pattern <span class="kw">for</span> packaging to work <span class="kw">in</span> either a <span class="ot">node</span>.<span class="fu">js</span> <span class="fu">server</span> <span class="fu">or</span> <span class="fu">a</span> <span class="fu">web</span> <span class="fu">browser</span></code></pre>
<h2 id="automated-testing"><a href="#automated-testing"><span class="header-section-number">4.7</span> automated testing</a></h2>
<p>How automated testing improves what can be written, not just making what is written more reliable.</p>
<div class="figure">
<img src="images/pyramid.png" alt="The testing pyramid is a common concept, relying on the assumption that verification of small parts provides a solid base from which to compose system-level behaviours. A Lot of testing is done on the low-level components of the system, whereas for the high-level tests only smoke tests are provided. " /><p class="caption">The testing pyramid is a common concept, relying on the assumption that verification of small parts provides a solid base from which to compose system-level behaviours. A Lot of testing is done on the low-level components of the system, whereas for the high-level tests only smoke tests are provided. </p>
</div>
<p>Jstd can serve example files but need to write out slowly which it has no concept of. Customistation is via configuration rather than by plug-in, but even if it were, the threading model is not suitable to create this kind of timed output.</p>
<p>Why jstd's built in proxy isn't sufficient. An example of a typical Java webserver, features thread-based mutlithreading in which threads wait for a while response to be received.</p>
<p>Testing via node - slowserver. Proxy.</p>
<p>The test pyramid concept  fits in well with the hiding that is provided. Under the testing pyramid only very high level behaviours are tested as ??? tests. While this is a lucky co-incidence, it is also an unavoidable restriction. Once compiled into a single source file, the individual components are hidden, callable only from withing their closure. Hence, it would not be possible to test the composed parts individually post-concatenation into a single javascript file, not even via a workarround for data hiding such as found in Java's reflection. Whereas in Java the protection is a means of protecting otherwise addressable resources, once a function is trapped inside a javascript closure without external exposure it is not just protected but, appearing in no namespaces, inherently unreferenceable.</p>
<p>TDD fits well into an object pattern because the software is well composed into separate parts. The objects are almost tangible in their distinction as separate encapsulated entities. However, the multi-paradigm style of my implementation draws much fainter borders over the implementation's landscape.</p>
<p>One dilemma in implementing the testing is how far to test the more generic sections of the codebase as generic components. A purist approach to TDD would say</p>
<p>Could implement a resume function for if transmission stops halfway</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">   .<span class="fu">onError</span>( error ) {
      <span class="kw">this</span>.<span class="fu">resume</span>();
   }</code></pre>
<h2 id="stability-over-upgrades"><a href="#stability-over-upgrades"><span class="header-section-number">4.8</span> stability over upgrades</a></h2>
<p>why jsonpath-like syntax allows upgrading message semantics without causing problems [SOA] how to guarantee non-breakages? could publish 'supported queries' that are guaranteed to work</p>
<h2 id="support-for-older-browsers"><a href="#support-for-older-browsers"><span class="header-section-number">4.9</span> support for older browsers</a></h2>
<p>Still works as well as non-progressive json Could be used for content that is inherently streaming (wouldn't make sense without streaming)</p>
<h2 id="suitability-for-databases"><a href="#suitability-for-databases"><span class="header-section-number">4.10</span> suitability for databases</a></h2>
<p>Databases offer data one row at a time, not as a big lump.</p>
<h2 id="weaknesses"><a href="#weaknesses"><span class="header-section-number">4.11</span> weaknesses</a></h2>
<p>implementation keeps 'unreachable' listeners difficult decidability/proof type problem to get completely right but could cover most of the easy cases</p>
<p>Parse time for large files spread out over a long time. Reaction to parsed content spread out over a long time, for example de-marshalling to domain objects. For UX may be preferable to have many small delays rather than one large one.</p>
<p>Doesn't support all of jsonpath. Not a strict subset of the language.</p>
<p>Rest client as a library is passing mutable objects to the caller. too inefficient to re-create a new map/array every time an item is not as efficient in immutability as list head-tail type storage</p>
<p>An imutability wrapper might be possible with defineProperty. Can't casually overwrite via assignment but still possible to do defineProperty again.</p>
<p>Would benefit from a stateless language where everything is stateless at all times to avoid having to program defensively.</p>
<h1 id="conclusion"><a href="#conclusion"><span class="header-section-number">5</span> Conclusion</a></h1>
<p><strong>1 to 5 pages</strong></p>
<h1 id="bibliography"><a href="#bibliography"><span class="header-section-number">6</span> Bibliography</a></h1>
<h1 id="appendix"><a href="#appendix"><span class="header-section-number">7</span> Appendix</a></h1>
